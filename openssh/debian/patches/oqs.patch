This patch applies the OQS openssh-portable 7.9 source code over the Debian OpenSSH 7.9p1-10 package source.
The intent is to wrap the OQS openssh source into a package. We use the Debian package based on the same openssh
source that the OQS openssh is based on.

See:
	https://openquantumsafe.org/
	https://github.com/open-quantum-safe/openssh


---
 LICENCE                                                               |    1 
 Makefile.in                                                           |    4 
 README.md                                                             |  266 ++
 RELEASE.md                                                            |   28 
 authfd.c                                                              |    3 
 authfile.c                                                            |    7 
 configure.ac                                                          |  322 ++
 dns.c                                                                 |    2 
 ietf_pre_draft_sike_bike_hybrid_kex.txt                               | 1176 ++++++++++
 kex.c                                                                 |  274 ++
 kex.h                                                                 |  154 +
 kexhy.h                                                               |  134 +
 kexhyecdh.c                                                           |  199 +
 kexhyecdhoqs.c                                                        |  228 +
 kexhyecdhoqsc.c                                                       |  372 +++
 kexhyecdhoqss.c                                                       |  353 +++
 kexoqs.c                                                              |  628 +++++
 kexoqs.h                                                              |   96 
 kexpq.h                                                               |   99 
 kexpqoqs.c                                                            |  167 +
 kexpqoqsc.c                                                           |  332 ++
 kexpqoqss.c                                                           |  315 ++
 monitor.c                                                             |    2 
 monitor_wrap.c                                                        |    5 
 msg.c                                                                 |    5 
 myproposal.h                                                          |  313 ++
 oqs-scripts/build_liboqs.sh                                           |   19 
 oqs-scripts/build_openssh.sh                                          |   36 
 oqs-scripts/clone_liboqs.sh                                           |   17 
 oqs-template/configure.ac/test_pq_alg_support.fragment                |   32 
 oqs-template/generate.py                                              |   80 
 oqs-template/generate.yml                                             |  614 +++++
 oqs-template/kex.c/define_hybrid_kexs.fragment                        |    8 
 oqs-template/kex.c/define_pq_kexs.fragment                            |    8 
 oqs-template/kex.h/define_hybrid_kexs.fragment                        |    6 
 oqs-template/kex.h/define_pq_kexs.fragment                            |    6 
 oqs-template/kexoqs.c/define_hybrid_kexs.fragment                     |    9 
 oqs-template/kexoqs.c/define_pq_kexs.fragment                         |    9 
 oqs-template/myproposal.h/define_hybrid_kexs.fragment                 |   11 
 oqs-template/myproposal.h/define_pq_kexs.fragment                     |   12 
 oqs-template/myproposal.h/list_hybrid_kexs.fragment                   |    7 
 oqs-template/myproposal.h/list_pq_kexs.fragment                       |    7 
 oqs-template/myproposal.h/undefine_hybrid_kexs.fragment               |    4 
 oqs-template/myproposal.h/undefine_pq_kexs.fragment                   |    4 
 oqs-template/oqs-test/test_openssh.py/list_kexs.fragment              |    8 
 oqs-template/oqs-test/test_openssh.py/list_sigs.fragment              |   12 
 oqs-template/oqs-utils.h/assign_pq_kt.fragment                        |    9 
 oqs-template/oqs-utils.h/define_hybrid_macros.fragment                |   40 
 oqs-template/oqs-utils.h/define_hybrid_switch_cases.fragment          |   35 
 oqs-template/oqs-utils.h/define_pq_switch_cases.fragment              |    9 
 oqs-template/pathnames.h/define_oqs_id_files.fragment                 |   13 
 oqs-template/pathnames.h/define_oqs_key_files.fragment                |   13 
 oqs-template/readconf.c/add_hybrid_id_files.fragment                  |    8 
 oqs-template/readconf.c/add_pq_id_files.fragment                      |    6 
 oqs-template/regress/unittests/kex/test_kex.c/do_hybrid_kexs.fragment |    8 
 oqs-template/regress/unittests/kex/test_kex.c/do_pq_kexs.fragment     |    8 
 oqs-template/servconf.c/add_hybrid_hostkeys.fragment                  |    9 
 oqs-template/servconf.c/add_pq_hostkeys.fragment                      |    7 
 oqs-template/ssh-add.c/list_hybrid_id_paths.fragment                  |    8 
 oqs-template/ssh-add.c/list_pq_id_paths.fragment                      |    6 
 oqs-template/ssh-keygen.c/add_hybrid_kt.fragment                      |   28 
 oqs-template/ssh-keygen.c/add_pq_kt.fragment                          |    6 
 oqs-template/ssh-keygen.c/assign_pq_id_paths.fragment                 |    8 
 oqs-template/ssh-keygen.c/print_pq_rr.fragment                        |    7 
 oqs-template/ssh-keygen.c/set_bits.fragment                           |   23 
 oqs-template/ssh-keyscan.c/assign_kt_markers.fragment                 |   22 
 oqs-template/ssh-keyscan.c/get_kt.fragment                            |   16 
 oqs-template/ssh-keyscan.c/switch_kt.fragment                         |   17 
 oqs-template/ssh-keysign.c/count_kt.fragment                          |   11 
 oqs-template/ssh-keysign.c/open_keyfiles.fragment                     |   13 
 oqs-template/ssh-oqs.c/ossh_kt_to_oqs_meth.fragment                   |   10 
 oqs-template/ssh.c/count_keys.fragment                                |   11 
 oqs-template/ssh.c/load_pubkeys.fragment                              |   16 
 oqs-template/ssh2.h/assign_hybrid_kex_markers.fragment                |    4 
 oqs-template/ssh2.h/assign_pq_kex_markers.fragment                    |    4 
 oqs-template/sshconnect.c/list_kt.fragment                            |   13 
 oqs-template/sshkey.c/add_hybrid_kt.fragment                          |    9 
 oqs-template/sshkey.c/add_pq_kt.fragment                              |    6 
 oqs-template/sshkey.h/enum_kt.fragment                                |   13 
 oqs-test/README.md                                                    |   61 
 oqs-test/do_openssh.sh                                                |   77 
 oqs-test/helpers.py                                                   |   50 
 oqs-test/test_openssh.py                                              |   89 
 oqs-utils.h                                                           |  118 +
 packet.c                                                              |    5 
 pathnames.h                                                           |   78 
 readconf.c                                                            |   45 
 regress/misc/kexfuzz/kexfuzz.c                                        |    2 
 regress/unittests/kex/Makefile                                        |    4 
 regress/unittests/kex/test_kex.c                                      |  184 +
 servconf.c                                                            |   82 
 ssh-add.c                                                             |   45 
 ssh-ecdsa.c                                                           |    7 
 ssh-keygen.c                                                          |  161 +
 ssh-keyscan.c                                                         |  215 +
 ssh-keysign.c                                                         |   48 
 ssh-oqs.c                                                             |  222 +
 ssh-oqs.h                                                             |   11 
 ssh-rsa.c                                                             |   15 
 ssh.c                                                                 |   43 
 ssh2.h                                                                |   77 
 ssh_api.c                                                             |    4 
 sshconnect.c                                                          |   39 
 sshconnect2.c                                                         |    2 
 sshd.c                                                                |   11 
 sshkey.c                                                              |  641 +++++
 sshkey.h                                                              |   51 
 version.h                                                             |    2 
 108 files changed, 9135 insertions(+), 64 deletions(-)

--- a/LICENCE
+++ b/LICENCE
@@ -164,6 +164,7 @@
     Portable OpenSSH additionally includes code from the following copyright
     holders, also under the 2-term BSD license:
 
+	Amazon.com, Inc. or its affiliates
 	Ben Lindstrom
 	Tim Rice
 	Andre Lucas
--- a/Makefile.in
+++ b/Makefile.in
@@ -81,6 +81,7 @@
 	sshbuf-getput-crypto.o \
 	krl.o \
 	bitmap.o \
+	ssh-oqs.o \
 	${XMSS_OBJS}
 
 LIBSSH_OBJS=${LIBOPENSSH_OBJS} \
@@ -100,6 +101,9 @@
 	kex.o kexdh.o kexgex.o kexecdh.o kexc25519.o \
 	kexdhc.o kexgexc.o kexecdhc.o kexc25519c.o \
 	kexdhs.o kexgexs.o kexecdhs.o kexc25519s.o \
+	kexoqs.o kexhyecdh.o \
+	kexpqoqs.o kexpqoqsc.o kexpqoqss.o \
+	kexhyecdhoqs.o kexhyecdhoqsc.o kexhyecdhoqss.o \
 	kexgssc.o \
 	platform-pledge.o platform-tracing.o platform-misc.o
 
--- /dev/null
+++ b/README.md
@@ -0,0 +1,266 @@
+[![Build status image](https://circleci.com/gh/open-quantum-safe/openssh/tree/OQS-master.svg?style=svg)](https://circleci.com/gh/open-quantum-safe/openssh/tree/OQS-master)
+
+OQS-OpenSSH
+==================================
+
+[OpenSSH](https://openssh.org/) is an open-source implementation of the Secure Shell protocol.  ([View the original README](https://github.com/open-quantum-safe/openssh-portable/blob/OQS-master/README).)
+
+OQS-OpenSSH is a fork of OpenSSH that adds quantum-safe key exchange and signature algorithms using [liboqs](https://github.com/open-quantum-safe/liboqs) for prototyping and evaluation purposes. This fork is not endorsed by the OpenSSH project.
+
+- [Overview](#overview)
+- [Status](#status)
+  * [Limitations and Security](#limitations-and-security)
+  * [Supported Algorithms](#supported-algorithms)
+- [Quickstart](#quickstart)
+  * [Building OQS-OpenSSH](#building-oqs-openssh)
+  * [Running OQS-OpenSSH](#running-oqs-openssh)
+- [Contributing](#contributing)
+- [License](#license)
+- [Team](#team)
+- [Acknowledgements](#acknowledgements)
+
+## Overview
+
+**liboqs** is an open source C library for quantum-resistant cryptographic algorithms. See [here](https://github.com/open-quantum-safe/liboqs/) for more information.
+
+**OQS-OpenSSH** is a fork of OpenSSH that adds quantum-safe cryptography to enable its use and evaluation in the SSH protocol.
+
+Both liboqs and this fork are part of the **Open Quantum Safe (OQS) project**, which aims to develop and prototype quantum-safe cryptography. More information about the project can be found [here](https://openquantumsafe.org/).
+
+## Status
+
+This fork is currently based on OpenSSH version **7.9** (Git tag V_7_9_P1); release notes can be found [here](RELEASE.md). **IT IS AT AN EXPERIMENTAL STAGE**, and has not received the same level of auditing and analysis that OpenSSH has received. See the [Limitations and Security](#limitations-and-security) section below for more information.
+
+**WE DO NOT RECOMMEND RELYING ON THIS FORK TO PROTECT SENSITIVE DATA.**
+
+liboqs is provided "as is", without warranty of any kind.  See [LICENSE.txt](https://github.com/open-quantum-safe/liboqs/blob/master/LICENSE.txt) for the full disclaimer.
+
+This fork also contains an experimental (pre-draft) [IETF draft](https://github.com/open-quantum-safe/openssh-portable/blob/OQS-master/ietf_pre_draft_sike_bike_hybrid_kex.txt) for hybrid key exchange algorithms ECDH-SIKE and ECDH-BIKE. This document has **not** been submitted to IETF.
+
+### Limitations and security
+
+As research advances, the supported algorithms may see rapid changes in their security, and may even prove insecure against both classical and quantum computers.
+
+We believe that the NIST Post-Quantum Cryptography standardization project is currently the best avenue to identifying potentially quantum-resistant algorithms, and strongly recommend that applications and protocols rely on the outcomes of the NIST standardization project when deploying quantum-safe cryptography.
+
+While at the time of this writing there are no vulnerabilities known in any of the quantum-safe algorithms used in this fork, it is advisable to wait on deploying quantum-safe algorithms until further guidance is provided by the standards community, especially from the NIST standardization project.
+
+We realize some parties may want to deploy quantum-safe cryptography prior to the conclusion of the standardization project.  We strongly recommend such attempts make use of so-called **hybrid cryptography**, in which quantum-safe public-key algorithms are combined with traditional public key algorithms (like RSA or elliptic curves) such that the solution is at least no less secure than existing traditional cryptography. This fork provides the ability to use hybrid cryptography.
+
+### Supported Algorithms
+
+If an algorithm is provided by liboqs but is not listed below, it can still be used in the fork through [either one of two ways](https://github.com/open-quantum-safe/openssh-portable/wiki/Using-liboqs-supported-algorithms-in-the-fork).
+
+#### Key Exchange
+
+The following quantum-safe algorithms from liboqs are supported (assuming they have been enabled in liboqs):
+
+- `oqsdefault` (see [here](https://github.com/open-quantum-safe/openssh-portable/wiki/Using-liboqs-supported-algorithms-in-the-fork) for what this denotes)
+- **BIKE**:`bike1-l1-cpa`, `bike1-l3-cpa`, `bike1-l1-fo`, `bike2-l3-fo`
+- **Classic McEliece**: `classic-mceliece-348864`, `classic-mceliece-348864f`, `classic-mceliece-460896`, `classic-mceliece-460896f`, `classic-mceliece-6688128`, `classic-mceliece-6688128f`, `classic-mceliece-6960119`, `classic-mceliece-6960119f`, `classic-mceliece-8192128`, `classic-mceliece-8192128f`
+- **FrodoKEM**:`frodo-640-aes`, `frodo-640-shake`, `frodo-976-aes`, `frodo-976-shake`, `frodo-1344-aes`, `frodo-1344-shake`
+- **HQC**: `hqc-128-1-cca2`, `hqc-192-1-cca2`, `hqc-192-2-cca2`, `hqc-256-1-cca2`†, `hqc-256-2-cca2`†, `hqc-256-3-cca2`†
+- **Kyber**:`kyber-512`, `kyber-768`, `kyber-1024`, `kyber-512-90s`, `kyber-768-90s`, `kyber-1024-90s`
+- **NewHope**:`newhope-512`, `newhope-1024`
+- **NTRU**:`ntru-hps-2048-509`, `ntru-hps-2048-677`
+- **Saber**:`saber-lightsaber`, `saber-saber`, `saber-firesaber`
+- **SIDH**:`sidh-p434`, `sidh-p503`, `sidh-p610`, `sidh-p751`, `sidh-p434-compressed`, `sidh-p503-compressed`, `sidh-p610-compressed`, `sidh-p751-compressed`
+- **SIKE**:`sike-p434`, `sike-p503`, `sike-p610`, `sike-p751`, `sike-p434-compressed`, `sike-p503-compressed`, `sike-p610-compressed`, `sike-p751-compressed`
+- **ThreeBears**:`babybear`, `mamabear`, `papabear`, `babybear-ephem`, `mamabear-ephem`, `papabear-ephem`
+
+The following hybrid algorithms are supported; they combine a quantum-safe algorithm listed above with ECDH that uses NIST's P384 curve:
+
+- `ecdh-nistp384-<KEX>`, where ``<KEX>`` is any one of the algorithms listed above.
+
+Note that algorithms marked with a dagger (†) have large stack usage and may cause failures when run on threads or in constrained environments.
+
+#### Digital Signature
+
+The following digital signature algorithms from liboqs are supported (assuming they have been enabled in liboqs). Note that only L1 signature and all **Rainbow** variants are enabled by default, and should you wish to enable additional variants, consult [the "Code Generation" section of the documentation in the wiki](https://github.com/open-quantum-safe/openssh/wiki/Using-liboqs-supported-algorithms-in-the-for://github.com/open-quantum-safe/openssh/wiki/Using-liboqs-supported-algorithms-in-the-fork#code-generation).
+
+- `oqsdefault` (see [here](https://github.com/open-quantum-safe/openssh-portable/wiki/Using-liboqs-supported-algorithms-in-the-fork) for what this denotes)
+- **Dilithium**:`dilithium2`, `dilithium3`, `dilithium4`
+- **MQDSS**:`mqdss3148`, `mqdss3164`
+- **Picnic**:`picnicl1fs`, `picnicl1ur`, `picnicl3fs`, `picnicl3ur`, `picnicl5fs`, `picnicl5ur`, `picnic2l1fs`, `picnic2l3fs`
+- **qTesla**:`qteslapi`, `qteslapiii`
+- **Rainbow**: `rainbowiaclassic`, `rainbowiacyclic`, `rainbowiacycliccompressed`, `rainbowiiicclassic`, `rainbowiiiccyclic`, `rainbowiiiccycliccompressed`, `rainbowvcclassic`, `rainbowvccylic`, `rainbowvccycliccompressed`
+- **SPHINCS-Haraka**: `sphincsharaka128frobust`, `sphincsharaka128fsimple`, `sphincsharaka128srobust`, `sphincsharaka128ssimple`, `sphincsharaka192frobust`, `sphincsharaka192fsimple`, `sphincsharaka192srobust`, `sphincsharaka192ssimple`, `sphincsharaka256frobust`, `sphincsharaka256fsimple`, `sphincsharaka256srobust`, `sphincsharaka256ssimple`
+- **SPHINCS-SHA256**: `sphincssha256128frobust`, `sphincssha256128fsimple`, `sphincssha256128srobust`, `sphincssha256128ssimple`, `sphincssha256192frobust`, `sphincssha256192fsimple`, `sphincssha256192srobust`, `sphincssha256192ssimple`, `sphincssha256256frobust`, `sphincssha256256fsimple`, `sphincssha256256srobust`, `sphincssha256256ssimple`
+- **SPHINCS-SHAKE256**: `sphincsshake256128frobust`, `sphincsshake256128fsimple`, `sphincsshake256128srobust`, `sphincsshake256128ssimple`, `sphincsshake256192frobust`, `sphincsshake256192fsimple`, `sphincsshake256192srobust`, `sphincsshake256192ssimple`, `sphincsshake256256frobust`, `sphincsshake256256fsimple`, `sphincsshake256256srobust`, `sphincsshake256256ssimple`
+
+The following hybrid algorithms are supported; they combine a quantum-safe algorithm listed above with a traditional digital signature algorithm (`<SIG>` is any one of the algorithms listed above):
+
+- if `<SIG>` has L1 security, then the fork provides the methods `rsa3072-<SIG>` and `p256-<SIG>`, which combine `<SIG>` with RSA3072 and with ECDSA using NIST's P256 curve respectively.
+- if `<SIG>` has L3 security, the fork provides the method `p384-<SIG>`, which combines `<SIG>` with ECDSA using NIST's P384 curve.
+- if `<SIG>` has L5 security, the fork provides the method `p521-<SIG>`, which combines `<SIG>` with ECDSA using NIST's P521 curve.
+
+## Quickstart
+
+The steps below have been confirmed to work on macOS 10.14 (clang 10.0.0) and Ubuntu 18.04.1 Bionic (gcc-7).
+
+### Building OQS-OpenSSH
+
+### Step 0: Install dependencies
+
+On **Ubuntu**, you need to install the following packages:
+
+	sudo apt install autoconf automake cmake gcc libtool libssl-dev make ninja-build zlib1g-dev
+
+On **Linux**, you also may need to do the following:
+
+- You may need to create the privilege separation directory:
+
+		sudo mkdir -p -m 0755 /var/empty
+
+- You may need to create the privilege separation user:
+
+		sudo groupadd sshd
+		sudo useradd -g sshd -c 'sshd privsep' -d /var/empty -s /bin/false sshd
+
+On **macOS**, you need to install the following packages using brew (or a package manager of your choice):
+
+	brew install autoconf automake cmake libtool ninja openssl@1.1 wget
+
+### Step 1: Build and install liboqs
+
+The following instructions install liboqs into a subdirectory inside the OpenSSH source. If `<OPENSSH_ROOT>` is the root of the OpenSSH source:
+
+```
+git clone --branch master --single-branch --depth 1 https://github.com/open-quantum-safe/liboqs.git
+cd liboqs
+mkdir build && cd build
+cmake .. -GNinja -DCMAKE_POSITION_INDEPENDENT_CODE=ON -DCMAKE_INSTALL_PREFIX=<OPENSSH_ROOT>/oqs
+ninja
+ninja install
+```
+
+Building liboqs requires your system to have OpenSSL 1.1.1 or higher already installed. It will automatically be detected if it in a standard location, such as `/usr` or `/usr/local/opt/openssl@1.1` (for brew on macOS).  Otherwise, you may need to specify it with `-DOPENSSL_ROOT_DIR=<path-to-system-openssl-dir>` added to the `cmake` command.
+
+### Step 2: Build the fork
+
+In `<OPENSSH_ROOT>`, first run:
+
+```
+export LIBOQS_INSTALL=<path-to-liboqs>
+export OPENSSH_INSTALL=<path-to-install-openssh>
+autoreconf
+```
+
+Then, run the following:
+
+	./configure --with-ssl-dir=<path-to-openssl>/include \
+	            --with-ldflags=-L<path-to-openssl>/lib   \
+	            --with-libs=-lm                          \
+	            --prefix=$OPENSSH_INSTALL                \
+	            --sysconfdir=$OPENSSH_INSTALL            \
+	            --with-liboqs-dir=$LIBOQS_INSTALL
+	make -j
+	make install
+
+To test the build, run:
+
+	make tests
+
+To run OQS-specific tests of all the post-quantum key-exchanges:
+
+```
+python3 -m nose --rednose --verbose
+```
+
+To run OQS-specific tests of all combinations of post-quantum key-exchange and authentication algorithms:
+
+```
+env WITH_PQAUTH=true python3 -m nose --rednose --verbose
+```
+
+### Running OQS-OpenSSH
+
+The following instructions explain how to establish an SSH connection that uses quantum-safe key exchange and authentication.
+
+#### Generating quantum-safe authentication keys
+
+To setup quantum-safe authentication, the server (and optionally, the client) need to generate quantum-safe keys. In what follows, `<SIG>` is one of the quantum-safe digital signature algorithms listed in [Supported Algorithms](#supported-algorithms) section above.
+
+The server generates its key files with the right permissions, and then generates its key pair:
+
+	mkdir ~/ssh_server/
+	chmod 700 ~/ssh_server/
+	touch ~/ssh_server/authorized_keys
+	chmod 600 ~/ssh_server/authorized_keys
+	<path-to-openssh>/bin/ssh-keygen -t ssh-<SIG> -f ~/ssh_server/id_<SIG>
+
+To enable client-side public-key authentication, the client generates its key pair:
+
+	mkdir ~/ssh_client/
+	<path-to-openssh>/bin/ssh-keygen -t ssh-<SIG> -f ~/ssh_client/id_<SIG>
+
+The server then adds the client's public key to its authorized keys
+
+	cat ~/ssh_client/id_<SIG>.pub >> ~/ssh_server/authorized_keys
+
+#### Establishing a quantum-safe SSH connection
+
+In one terminal, run a server (the arguments between `[...]` can be omitted if only classical authentication is required):
+
+	sudo <path-to-openssh>/sbin/sshd -p 2222 -d             \
+	    -o KexAlgorithms=<OPENSSH_KEX_ALGORITHM>             \
+	    [-o AuthorizedKeysFile=<absolute-path-to>/ssh_server/authorized_keys \
+	     -o HostKeyAlgorithms=<OPENSSH_SIG_ALGORITHM>        \
+	     -o PubkeyAcceptedKeyTypes=<OPENSSH_SIG_ALGORITHM>   \
+	     -h <absolute-path-to>/ssh_server/id_<SIG>]
+
+where `<OPENSSH_SIG_ALGORITHM>` is `ssh-<SIG>` (all in lowercase) and `<OPENSSH_KEX_ALGORITM>` can be one of:
+
+- `<KEX>-sha384@openquantumsafe.org` (for quantum-safe-only key exchange)
+- `ecdh-nistp384-<KEX>-sha384@openquantumsafe.org` (for hybrid quantum-safe and elliptic curve key exchange)
+
+`<KEX>` and `<SIG>` are respectively one of the key exchange and signature (PQ-only or hybrid) algorithms listed in the [Supported Algorithms](#supported-algorithms) section above.
+
+The `-o` options can also be added to the server/client configuration file instead of being specified on the command line.
+
+The server automatically supports all available hybrid and PQ-only key exchange algorithms.  `sudo` is required on Linux so that sshd can read the shadow password file.
+
+In another terminal, run a client(the arguments between `[...]` can be omitted if only classical authentication is required):
+
+	<path-to-openssh>/bin/ssh                             \
+	    -p 2222 localhost                                 \
+	    -o KexAlgorithms=<OPENSSH_KEX_ALGORITHM>          \
+	   [-o HostKeyAlgorithms=<OPENSSH_SIG_ALGORITHM>      \
+	    -o PubkeyAcceptedKeyTypes=<OPENSSH_SIG_ALGORITHM> \
+	    -o StrictHostKeyChecking=no                       \
+	    -i ~/ssh_client/id_<SIG>]
+
+The `StrictHostKeyChecking` option is used to allow trusting the newly generated server key; alternatively, the key could be added manually to the client's trusted keys.
+
+## Contributing
+
+Contributions are gratefully welcomed. See our [Contributing Guide](https://github.com/open-quantum-safe/openssh-portable/wiki/Contributing-Guide) for more details.
+
+## License
+
+This fork is released under the same license(s) as Portable OpenSSH. More information can be found in the [LICENSE](LICENSE) file.
+
+## Team
+
+The Open Quantum Safe project is led by [Douglas Stebila](https://www.douglas.stebila.ca/research/) and [Michele Mosca](http://faculty.iqc.uwaterloo.ca/mmosca/) at the University of Waterloo.
+
+Contributors to this fork of OpenSSH include:
+
+- Eric Crockett (Amazon Web Services)
+- Ben Davies (University of Waterloo)
+- Torben Hansen (Amazon Web Services and Royal Holloway, University of London)
+- Christian Paquin (Microsoft Research)
+- Douglas Stebila (University of Waterloo)
+- Goutam Tamvada (University of Waterloo)
+
+Contributors to an earlier OQS fork of OpenSSH included:
+
+- Mira Belenkiy (Microsoft Research)
+- Karl Knopf (McMaster University)
+
+## Acknowledgments
+
+Financial support for the development of Open Quantum Safe has been provided by Amazon Web Services and the Tutte Institute for Mathematics and Computing.
+We'd like to make a special acknowledgement to the companies who have dedicated programmer time to contribute source code to OQS, including Amazon Web Services, evolutionQ, Microsoft Research, Cisco Systems, and IBM Research.
+
+Research projects which developed specific components of OQS have been supported by various research grants, including funding from the Natural Sciences and Engineering Research Council of Canada (NSERC); see [here](https://openquantumsafe.org/papers/SAC-SteMos16.pdf) and [here](https://openquantumsafe.org/papers/NISTPQC-CroPaqSte19.pdf) for funding acknowledgments.
--- /dev/null
+++ b/RELEASE.md
@@ -0,0 +1,28 @@
+OQS-OpenSSH snapshot 2020-08
+============================
+
+About
+-----
+
+The **Open Quantum Safe (OQS) project** has the goal of developing and prototyping quantum-resistant cryptography.  More information on OQS can be found on our website: https://openquantumsafe.org/ and on Github at https://github.com/open-quantum-safe/.
+
+**liboqs** is an open source C library for quantum-resistant cryptographic algorithms.
+
+**OQS-OpenSSH** is an integration of liboqs into (a fork of) OpenSSH.  The goal of this integration is to provide easy prototyping of quantum-resistant cryptography.  The integration should not be considered "production quality".
+
+Release notes
+=============
+
+This is the 2020-08 snapshot release of OQS-OpenSSH, released on August 11, 2020. Its release page on GitHub is https://github.com/open-quantum-safe/openssh/releases/tag/OQS-OpenSSH-snapshot-2020-08. This release is intended to be used with liboqs version 0.4.0.
+
+What's New
+----------
+
+This is the fourth snapshot release of the OQS fork of OpenSSH.  It is based on OpenSSH 7.9 portable 1.
+
+- Uses the updated NIST Round 2 submissions added to liboqs 0.4.0, as described in the [liboqs release notes](https://github.com/open-quantum-safe/liboqs/blob/master/RELEASE.md).
+
+Deprecations
+------------
+
+As a result of NIST's announcement of Round 3 of the Post-Quantum Cryptography Standardization Project, this is the last release of OQS-OpenSSH that contain algorithms from Round 2 that are not Round 3 finalists or alternate candidates. Those algorithms will be removed in the next release. The algorithms in question are: NewHope, ThreeBears, MQDSS, and qTesla. These algorithms are considered deprecated within OQS-OpenSSH will receive no updates after this release.
--- a/authfd.c
+++ b/authfd.c
@@ -60,6 +60,7 @@
 #include "atomicio.h"
 #include "misc.h"
 #include "ssherr.h"
+#include "oqs-utils.h"
 
 #define MAX_AGENT_IDENTITIES	2048		/* Max keys in agent reply */
 #define MAX_AGENT_REPLY_LEN	(256 * 1024) 	/* Max bytes in agent reply */
@@ -446,6 +447,8 @@
 	case KEY_ED25519_CERT:
 	case KEY_XMSS:
 	case KEY_XMSS_CERT:
+	CASE_KEY_OQS:
+	CASE_KEY_HYBRID:
 		type = constrained ?
 		    SSH2_AGENTC_ADD_ID_CONSTRAINED :
 		    SSH2_AGENTC_ADD_IDENTITY;
--- a/authfile.c
+++ b/authfile.c
@@ -48,8 +48,11 @@
 #include "sshbuf.h"
 #include "ssherr.h"
 #include "krl.h"
+#include "oqs-utils.h"
 
-#define MAX_KEY_FILE_SIZE	(1024 * 1024)
+/* OQS note: We increased this value
+ * from (1024 * 1024) to 67108864 */
+#define MAX_KEY_FILE_SIZE	67108864
 
 /* Save a key blob to a file */
 static int
@@ -403,6 +406,8 @@
 #endif /* WITH_OPENSSL */
 	case KEY_ED25519:
 	case KEY_XMSS:
+	CASE_KEY_OQS:
+	CASE_KEY_HYBRID:
 	case KEY_UNSPEC:
 		break;
 	default:
--- a/configure.ac
+++ b/configure.ac
@@ -3587,6 +3587,328 @@
 	AC_MSG_ERROR([unsupported --with-sandbox])
 fi
 
+# Check for LibOQS
+with_liboqs=no
+AC_ARG_WITH([liboqs-dir],
+	[  --with-liboqs-dir=PATH     Specify path to LibOQS installation ],
+	[
+		if test "x$withval" != "xno" ; then
+			with_liboqs=yes
+			case "$withval" in
+				# Relative paths
+				./*|../*)	withval="`pwd`/$withval"
+			esac
+			if test -d "$withval/lib"; then
+				if test -n "${need_dash_r}"; then
+					LDFLAGS="-L${withval}/lib -R${withval}/lib ${LDFLAGS}"
+				else
+					LDFLAGS="-L${withval}/lib ${LDFLAGS}"
+				fi
+			elif test -d "$withval/lib64"; then
+				if test -n "${need_dash_r}"; then
+					LDFLAGS="-L${withval}/lib64 -R${withval}/lib64 ${LDFLAGS}"
+				else
+					LDFLAGS="-L${withval}/lib64 ${LDFLAGS}"
+				fi
+			else
+				if test -n "${need_dash_r}"; then
+					LDFLAGS="-L${withval} -R${withval} ${LDFLAGS}"
+				else
+					LDFLAGS="-L${withval} ${LDFLAGS}"
+				fi
+			fi
+			if test -d "$withval/include"; then
+				CPPFLAGS="-I${withval}/include ${CPPFLAGS}"
+			else
+				CPPFLAGS="-I${withval} ${CPPFLAGS}"
+			fi
+		fi
+	]
+)
+
+if test "x$with_liboqs" = "xyes" ; then
+	dnl Check for LibOQS library
+	AC_DEFINE_UNQUOTED([WITH_OQS], [1], [use LibOQS for post-quantum and hybrid key exchange and authentication])
+	LIBS="-loqs -lcrypto $LIBS"
+	AC_CHECK_HEADER([oqs/kem.h], ,[AC_MSG_ERROR([*** LibOQS headers missing - please install first or check config.log ***])])
+	AC_TRY_LINK([#include <oqs/kem.h>],
+				[
+					char *alg = OQS_KEM_alg_identifier(0);
+					if (alg == NULL) {
+						return 1;
+					}
+				],
+				,
+				[
+					AC_MSG_ERROR([*** Can't find LibOQS library (see config.log for details) ***])
+				]
+			)
+	dnl End LibOQS library check
+fi
+
+if test "x$with_liboqs" = "xyes" ; then
+	AC_DEFINE([WITH_PQ_KEX], [1], [Define if post-quantum key exchange methods are supported])
+	AC_DEFINE([WITH_HYBRID_KEX], [1], [Define if hybrid key exchange methods are supported])
+	AC_DEFINE([WITH_PQ_AUTH], [1], [Define if post-quantum authentication methods are supported])
+	AC_DEFINE([WITH_HYBRID_AUTH], [1], [Define if hybrid authentication methods are supported])
+	dnl Check which post-quantum schemes are enabled in LibOQS library
+##### OQS_TEMPLATE_FRAGMENT_TEST_PQ_ALG_SUPPORT_START
+	AC_MSG_CHECKING([for libOQS BIKE support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_KEM_BIKE) || (defined(OQS_ENABLE_KEM_bike1_l1_cpa) && defined(OQS_ENABLE_KEM_bike1_l3_cpa) && defined(OQS_ENABLE_KEM_bike1_l1_fo) && defined(OQS_ENABLE_KEM_bike1_l3_fo))
+					#else
+					#error "BIKE is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_BIKE], [1], [Define to 1 if LibOQS library is compiled with support for BIKE])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS CLASSIC_MCELIECE support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_KEM_CLASSIC_MCELIECE) || (defined(OQS_ENABLE_KEM_classic_mceliece_348864) && defined(OQS_ENABLE_KEM_classic_mceliece_348864f) && defined(OQS_ENABLE_KEM_classic_mceliece_460896) && defined(OQS_ENABLE_KEM_classic_mceliece_460896f) && defined(OQS_ENABLE_KEM_classic_mceliece_6688128) && defined(OQS_ENABLE_KEM_classic_mceliece_6688128f) && defined(OQS_ENABLE_KEM_classic_mceliece_6960119) && defined(OQS_ENABLE_KEM_classic_mceliece_6960119f) && defined(OQS_ENABLE_KEM_classic_mceliece_8192128) && defined(OQS_ENABLE_KEM_classic_mceliece_8192128f))
+					#else
+					#error "CLASSIC_MCELIECE is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_CLASSIC_MCELIECE], [1], [Define to 1 if LibOQS library is compiled with support for CLASSIC_MCELIECE])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS FRODO support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_KEM_FRODO) || (defined(OQS_ENABLE_KEM_frodokem_640_aes) && defined(OQS_ENABLE_KEM_frodokem_640_shake) && defined(OQS_ENABLE_KEM_frodokem_976_aes) && defined(OQS_ENABLE_KEM_frodokem_976_shake) && defined(OQS_ENABLE_KEM_frodokem_1344_aes) && defined(OQS_ENABLE_KEM_frodokem_1344_shake))
+					#else
+					#error "FRODO is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_FRODO], [1], [Define to 1 if LibOQS library is compiled with support for FRODO])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS KYBER support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_KEM_KYBER) || (defined(OQS_ENABLE_KEM_kyber_512) && defined(OQS_ENABLE_KEM_kyber_768) && defined(OQS_ENABLE_KEM_kyber_1024) && defined(OQS_ENABLE_KEM_kyber_512_90s) && defined(OQS_ENABLE_KEM_kyber_768_90s) && defined(OQS_ENABLE_KEM_kyber_1024_90s))
+					#else
+					#error "KYBER is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_KYBER], [1], [Define to 1 if LibOQS library is compiled with support for KYBER])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS NEWHOPE support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_KEM_NEWHOPE) || (defined(OQS_ENABLE_KEM_newhope_512cca) && defined(OQS_ENABLE_KEM_newhope_1024cca))
+					#else
+					#error "NEWHOPE is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_NEWHOPE], [1], [Define to 1 if LibOQS library is compiled with support for NEWHOPE])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS NTRU support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_KEM_NTRU) || (defined(OQS_ENABLE_KEM_ntru_hps2048509) && defined(OQS_ENABLE_KEM_ntru_hps2048677) && defined(OQS_ENABLE_KEM_ntru_hrss701) && defined(OQS_ENABLE_KEM_ntru_hps4096821))
+					#else
+					#error "NTRU is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_NTRU], [1], [Define to 1 if LibOQS library is compiled with support for NTRU])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS SABER support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_KEM_SABER) || (defined(OQS_ENABLE_KEM_saber_lightsaber) && defined(OQS_ENABLE_KEM_saber_saber) && defined(OQS_ENABLE_KEM_saber_firesaber))
+					#else
+					#error "SABER is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_SABER], [1], [Define to 1 if LibOQS library is compiled with support for SABER])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS SIDH support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_KEM_SIDH) || (defined(OQS_ENABLE_KEM_sidh_p434) && defined(OQS_ENABLE_KEM_sidh_p503) && defined(OQS_ENABLE_KEM_sidh_p610) && defined(OQS_ENABLE_KEM_sidh_p751) && defined(OQS_ENABLE_KEM_sidh_p434_compressed) && defined(OQS_ENABLE_KEM_sidh_p503_compressed) && defined(OQS_ENABLE_KEM_sidh_p610_compressed) && defined(OQS_ENABLE_KEM_sidh_p751_compressed))
+					#else
+					#error "SIDH is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_SIDH], [1], [Define to 1 if LibOQS library is compiled with support for SIDH])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS SIKE support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_KEM_SIKE) || (defined(OQS_ENABLE_KEM_sike_p434) && defined(OQS_ENABLE_KEM_sike_p503) && defined(OQS_ENABLE_KEM_sike_p610) && defined(OQS_ENABLE_KEM_sike_p751) && defined(OQS_ENABLE_KEM_sike_p434_compressed) && defined(OQS_ENABLE_KEM_sike_p503_compressed) && defined(OQS_ENABLE_KEM_sike_p610_compressed) && defined(OQS_ENABLE_KEM_sike_p751_compressed))
+					#else
+					#error "SIKE is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_SIKE], [1], [Define to 1 if LibOQS library is compiled with support for SIKE])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS THREEBEARS support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_KEM_THREEBEARS) || (defined(OQS_ENABLE_KEM_threebears_babybear) && defined(OQS_ENABLE_KEM_threebears_babybear_ephem) && defined(OQS_ENABLE_KEM_threebears_mamabear) && defined(OQS_ENABLE_KEM_threebears_mamabear_ephem) && defined(OQS_ENABLE_KEM_threebears_papabear) && defined(OQS_ENABLE_KEM_threebears_papabear_ephem))
+					#else
+					#error "THREEBEARS is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_THREEBEARS], [1], [Define to 1 if LibOQS library is compiled with support for THREEBEARS])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS HQC support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_KEM_HQC) || (defined(OQS_ENABLE_KEM_hqc_128_1_cca2) && defined(OQS_ENABLE_KEM_hqc_192_1_cca2) && defined(OQS_ENABLE_KEM_hqc_192_2_cca2) && defined(OQS_ENABLE_KEM_hqc_256_1_cca2) && defined(OQS_ENABLE_KEM_hqc_256_2_cca2) && defined(OQS_ENABLE_KEM_hqc_256_3_cca2))
+					#else
+					#error "HQC is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_HQC], [1], [Define to 1 if LibOQS library is compiled with support for HQC])
+			], [AC_MSG_RESULT([no])
+	])
+
+
+	AC_MSG_CHECKING([for libOQS DILITHIUM support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_SIG_DILITHIUM) || (defined(OQS_ENABLE_SIG_dilithium_2))
+					#else
+					#error "DILITHIUM is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_DILITHIUM], [1], [Define to 1 if LibOQS library is compiled with support for DILITHIUM])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS FALCON support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_SIG_FALCON) || (defined(OQS_ENABLE_SIG_falcon_512))
+					#else
+					#error "FALCON is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_FALCON], [1], [Define to 1 if LibOQS library is compiled with support for FALCON])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS MQDSS support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_SIG_MQDSS) || (defined(OQS_ENABLE_SIG_mqdss_31_48))
+					#else
+					#error "MQDSS is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_MQDSS], [1], [Define to 1 if LibOQS library is compiled with support for MQDSS])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS PICNIC support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_SIG_PICNIC) || (defined(OQS_ENABLE_SIG_picnic_L1_FS) && defined(OQS_ENABLE_SIG_picnic3_L1))
+					#else
+					#error "PICNIC is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_PICNIC], [1], [Define to 1 if LibOQS library is compiled with support for PICNIC])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS QTESLA support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_SIG_QTESLA) || (defined(OQS_ENABLE_SIG_qTesla_p_I))
+					#else
+					#error "QTESLA is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_QTESLA], [1], [Define to 1 if LibOQS library is compiled with support for QTESLA])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS RAINBOW support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_SIG_RAINBOW) || (defined(OQS_ENABLE_SIG_rainbow_Ia_classic) && defined(OQS_ENABLE_SIG_rainbow_IIIc_classic) && defined(OQS_ENABLE_SIG_rainbow_Vc_classic))
+					#else
+					#error "RAINBOW is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_RAINBOW], [1], [Define to 1 if LibOQS library is compiled with support for RAINBOW])
+			], [AC_MSG_RESULT([no])
+	])
+
+	AC_MSG_CHECKING([for libOQS SPHINCS support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_SIG_SPHINCS) || (defined(OQS_ENABLE_SIG_sphincs_haraka_128f_robust) && defined(OQS_ENABLE_SIG_sphincs_sha256_128f_robust) && defined(OQS_ENABLE_SIG_sphincs_shake256_128f_robust))
+					#else
+					#error "SPHINCS is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_SPHINCS], [1], [Define to 1 if LibOQS library is compiled with support for SPHINCS])
+			], [AC_MSG_RESULT([no])
+	])
+##### OQS_TEMPLATE_FRAGMENT_TEST_PQ_ALG_SUPPORT_END
+	dnl End supported post-quantum schemes in LibOQS check
+fi
+
 # Cheap hack to ensure NEWS-OS libraries are arranged right.
 if test ! -z "$SONY" ; then
   LIBS="$LIBS -liberty";
--- a/dns.c
+++ b/dns.c
@@ -25,6 +25,8 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+/* FIXMEOQS: enable PQ DNS auth? */
+
 #include "includes.h"
 
 #include <sys/types.h>
--- /dev/null
+++ b/ietf_pre_draft_sike_bike_hybrid_kex.txt
@@ -0,0 +1,1176 @@
+
+
+
+
+T. Hansen
+M. Campagna
+E. Crockett
+Amazon
+June 21, 2018
+
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the Secure Shell Transport
+                                 Layer
+                      draft-ietf-ssh-hybrid-kex-XY
+
+Abstract
+
+   _This document is not submitted to IETF_
+
+   This document defines hybrid key exchange methods based on classical
+   ECDH key exchange and the post-quantum key exchange schemes SIKE and
+   BIKE.  The hybrid key exchange methods are defined for use in the SSH
+   Transport Layer Protocol.
+
+Status of This Memo
+
+   This Internet-Draft is submitted in full conformance with the
+   provisions of BCP 78 and BCP 79.
+
+   Internet-Drafts are working documents of the Internet Engineering
+   Task Force (IETF).  Note that other groups may also distribute
+   working documents as Internet-Drafts.  The list of current Internet-
+   Drafts is at https://datatracker.ietf.org/drafts/current/.
+
+   Internet-Drafts are draft documents valid for a maximum of six months
+   and may be updated, replaced, or obsoleted by other documents at any
+   time.  It is inappropriate to use Internet-Drafts as reference
+   material or to cite them other than as "work in progress."
+
+   This Internet-Draft will expire on December 23, 2018.
+
+Copyright Notice
+
+   Copyright (c) 2018 IETF Trust and the persons identified as the
+   document authors.  All rights reserved.
+
+   This document is subject to BCP 78 and the IETF Trust's Legal
+   Provisions Relating to IETF Documents
+   (https://trustee.ietf.org/license-info) in effect on the date of
+   publication of this document.  Please review these documents
+   carefully, as they describe your rights and restrictions with respect
+   to this document.  Code Components extracted from this document must
+
+
+
+Hansen, et al.                         [Page 1]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+   include Simplified BSD License text as described in Section 4.e of
+   the Trust Legal Provisions and are provided without warranty as
+   described in the Simplified BSD License.
+
+1.  Introduction
+
+   This document defines a hybrid key exchange method for SSH in
+   abstract terms.  It further provides two concrete instantiantions of
+   this abstract hybrid key exchange method by combining ECDH with
+   either SIKE or BIKE.
+
+   Secure Shell (SSH) [RFC4251] performs key establishment using key
+   exchange methods based exclusively on Diffie-Hellman style schemes.
+   The cryptographic security of these Diffie-Hellman style schemes rely
+   on certain instances of the discrete logarithm problem being
+   computationally infeasable to solve for adversaries.  However, when
+   sufficiently large quantum computers becomes available these
+   instances would no longer be computationally infeasable rendering the
+   current key exchange methods in SSH insecure.  While large quantum
+   computers are not available today an adversary can record the
+   encrypted communication sent between the client and server in an SSH
+   session and then later decrypt the communication when sufficiently
+   large quantum computers become available.  This kind of attack is
+   known as a "record-and-harvest" attack.
+
+   This document proposes to solve the problem by extending the SSH
+   transport layer protocol [RFC4253] with hybrid key exchange methods.
+   A hybrid key exchange methods maintain the same level of security
+   provided by current key exchange methods, but also add quantum
+   resistantance.  The security provided by the individual key exchange
+   scheme in a hybrid key exchange method is independent.  This means
+   that the hybrid key exchange method will always be at least as secure
+   as the most secure key exchange scheme executed as part of the hybrid
+   key exchange method.  See Section 11 for a more comprehensive
+   security analysis.
+
+   The reason for proposing the use of hybrid key exchange methods, is
+   that the current quantum-resistant key exchange schemes have not yet
+   been subject to extensive cryptanalysis.  Hence, such schemes do not
+   have the same level of trust as associated with key exchange schemes
+   that have existed for a long time and which have been subject to
+   extensive cryptanalysis.
+
+   This document is concerned with SSH key exchange methods.  Signature
+   algorithms used to establish an SSH sessions, in particular the use
+   of post-quantum signature algorithms, is out of scope for this
+   document.
+
+
+
+
+Hansen, et al.                         [Page 2]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+   Implementation of this specification requires familiarity with the
+   SSH RFCs [RFC4250], [RFC4251], [RFC4253], the ECC standard [SEC1],
+   and the post-quantum algorithm specs SIKE [SIKE] and BIKE [BIKE].
+   The purpose of this document is to provide SSH implementation details
+   and not details of the specification of the cryptographic algorithms
+   used.  These can be found in their respective references.
+
+1.1.  Terminology
+
+   Key exchange scheme: Used to describe a key exchange primitive.  The
+   key exchange primitive defines the mathematical operations used to
+   execute the scheme.
+
+   Key exchange methods: Used to describe an SSH named key exchange
+   scheme, describing a specific SSH implementation of a key exchange
+   scheme.
+
+2.  Notation
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in [RFC2119].
+
+   The data types byte, string and mpint are to be intepreted in this
+   document as described in [RFC4251].
+
+   Protocol fields and possible values to fill them are defined in this
+   document.  Protocol fields will be defined in the message
+   definitions, together with a data type appearing before the field
+   separated by a whitespace.  In addition, an optional piece of
+   information identifying the field will appear after the field,
+   separated by a comma and a whitespace.  As an example, the
+   (hypothetical) message SSH_MSG_EXAMPLE is defined as follows:
+
+      byte SSH_MSG_EXAMPLE
+
+      string str, information identifying str
+
+   Throughout this document, when the fields are referenced, they will
+   appear within single quotes.  When the values to fill those fields
+   are referenced, they will appear within double quotes.  Using the
+   above example, possible values for 'str' are "foo" or "bar".
+
+3.  Hybrid Key Exchange
+
+   A hybrid key exchange produces a shared secret by running more than
+   one key exchange scheme concurrently and combining the resulting
+   shared secrets from each key exchange scheme into a single shared
+
+
+
+Hansen, et al.                         [Page 3]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+   secret.  This document only defines hybrid key exchanges that run two
+   key exchange schemes concurrently.  Section 3.1 provides an overview
+   of the SSH-specific hybrid key exchange construction.  In Section 3.2
+   an abstract hybrid key exchange method is defined.  The key exchange
+   schemes used to instantiate the abstract hybrid key exchange method
+   are defined in Section 4, with specific hybrid key exchange method
+   instantiations defined in Section 5.
+
+   The hybrid key exchange methods defined in this document provide
+   explicit server authentication as defined in [RFC4253] using a
+   signature on the exchange hash.  The public key algorithm for signing
+   is negotiated with the SSH_MSG_KEXINIT message, which also negotiates
+   the method name of the hybrid key exchange.  The method name of the
+   hybrid key exchange determines the specific key exchange method as
+   well as the hash function used to compute the exchange hash.
+   Section 6 lists the set of method names for the hybrid key exchange
+   methods defined in this document.
+
+3.1.  Hybrid Key Exchange Protocol Overview
+
+   The following diagram is a high-level representation of the SSH key
+   exchange defined in [RFC4253]:
+
+   Client                      Server
+   ------                      ------
+   SSH_MSG_KEXINIT <-----> SSH_MSG_KEXINIT
+
+           |-----------------------|
+           |Key exchange method run|
+           |-----------------------|
+
+   SSH_MSG_NEWKEYS <-----> SSH_MSG_NEWKEYS
+
+   After both sides have sent the SSH_MSG_KEXINIT message, the key
+   exchange method is run.  The key exchange method may involve
+   exchanging several messages.  A key exchange method produces two
+   values: an SSH shared secret K and an exchange hash H.  These two
+   values are used to derive encryption and authentication keys.
+
+   A hybrid key exchange, in the context of SSH, is a particular key
+   exchange method that implements the abstract hybrid key exchange
+   method in Section 3.2.
+
+3.2.  Abstract Hybrid Key Exchange Method
+
+   This section defines the abstract structure of a hybrid key exchange
+   method.  The structure must be instantiated with two key exchange
+
+
+
+
+Hansen, et al.                         [Page 4]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+   schemes.  Given key exchange schemes X and Y, the X+Y hybrid key
+   exchange method is implemented using the following exchange messages.
+
+   The client sends:
+
+      byte SSH_MSG_HY_X_Y_INIT
+
+      string C_X, X client message octet string
+
+      string C_Y, Y client message octet string
+
+   The server sends:
+
+      byte SSH_MSG_HY_X_Y_REPLY
+
+      string S_X, X server message octet string
+
+      string S_Y, Y server message octet string
+
+   The string name of the key exchange schemes X and Y will replace the
+   X and Y in the message names 'SSH_MSG_HY_X_Y_INIT' and
+   'SSH_MSG_HY_X_Y_REPLY' in specific instantiations.
+
+   A named hybrid key exchange name includes a named hash.  The exchange
+   hash H is the result of computing the HASH, where HASH is the hash
+   algorithm specified in the named hybrid key exchange method name,
+   over the concatenation of the following:
+
+      string V_C, client identification string (CR and LF excluded)
+
+      string V_S, server identification string (CR and LF excluded)
+
+      string I_C, payload of the client's SSH_MSG_KEXINIT
+
+      string I_S, payload of the server's SSH_MSG_KEXINIT
+
+      string C_X, X client message octet string
+
+      string C_Y, Y client message octet string
+
+      string S_X, X server message octet string
+
+      string S_Y, Y server message octet string
+
+      mpint K, SSH shared secret
+
+
+
+
+
+
+Hansen, et al.                         [Page 5]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+   Let K_X and K_Y be the shared secrets resulting from key exchange
+   scheme X and Y, respectively.  The SSH shared secret K is computed
+   from K_X and K_Y following the process in Section 3.3.
+
+3.3.  Derivation of Encryption and Authentication Keys
+
+   Derivation of encryption and authentication keys MUST be done
+   according to Section 7.2 in [RFC4253] with the following
+   modifications.  The shared secrets K_X and K_Y are the output from
+   the two key exchange schemes X and Y, respectively, that instantiates
+   an abstract hybrid key exchange method (see Section 3.2).  The SSH
+   shared secret K is the concatenation of the two shared secrets K_X
+   and K_Y.  The order of concatenation is the order that the
+   corresponding key exchange scheme appears in the hybrid key exchange
+   method name.  K MUST be encoded as an mpint.  However, K_X and K_Y
+   MUST be encoded as octet strings.
+
+4.  Key Exchange Schemes
+
+   This section defines key exchange schemes that can be used to
+   instantiate the abstract hybrid key exchange scheme defined in
+   Section 3.2.
+
+4.1.  ECDH
+
+   The ECDH key exchange scheme is the Elliptic Curve Cofactor Diffie-
+   Hellman Primitive that can be found in Section 3.3.2 of [SEC1].  The
+   algorithm for generating the client ephemeral key (C_ECDH) and the
+   server ephemeral public key (S_ECDH) can be found in Section 3.2.1 of
+   [SEC1].  The ephemeral elliptic curve public keys (points) that must
+   be transmitted MUST be encoded into octet strings before they are
+   transmitted.  The transformation between elliptic curve points and
+   octet strings is specified in Sections 2.3.3 and 2.3.4 of [SEC1];
+   point compression MAY be used.  The shared secret (K_ECDH) resulting
+   from the ECDH key exchange is a field element xp.  The field element
+   xp MUST be encoded as an octet string following the conversion
+   algorithm defined in Section 2.3.5 of [SEC1].
+
+   C_ECDH is defined as the ECDH client message octet string.
+
+   S_ECDH is defined as the ECDH server message octet string.
+
+   ECDH is used throughout to refer to the key exchange scheme defined
+   in this section.
+
+   The ECDH key exchange scheme defined in this section, is identical to
+   the key exchange scheme used to construct the ECDH key exchange
+
+
+
+
+Hansen, et al.                         [Page 6]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+   method defined in [RFC5656] except for the encoding of the shared
+   secret.
+
+4.2.  BIKE
+
+   The BIKE key exchange scheme is the key encapsulation mechanism (KEM)
+   bike-1 defined in Section 2.1 of [BIKE].  The following octet string
+   encodings for the public key (C_BIKE), ciphertext (S_BIKE) and shared
+   secret (K_BIKE) MUST be used:
+
+   The public key C_BIKE consists of two elements: f_0 and f_1. f_0 and
+   f_1 are elements of the polynomial ring R = F_2[X]/(X^{r} - 1).
+   C_BIKE MUST be encoded into a single octet string in the following
+   way: f_0 and f_1 are encoded into their octet representation using
+   the encoding function BIKE_2_OCTET defined in Section 10.1 and then
+   concatenated (f_0 followed by f_1) producing a single octet string.
+
+   The ciphertext S_BIKE consists of two elements: c_0 and c_1. c_0 and
+   c_1 are elements of the polynomial ring R = F_2[X]/(X^{r} - 1).
+   S_BIKE MUST be encoded into a single octet string in the following
+   way: c_0 and c_1 are encoded into their octet representation using
+   the encoding function BIKE_2_OCTET defined in Section 10.1 and then
+   concatenated (c_0 followed by c_1) producing a single octet string.
+
+   The shared secret K_BIKE returned by BIKE is the octet string
+   returned by the decaps algorithm of bike-1 (see Section 2.1.3
+   [BIKE]).  The KDF algorithm used in the decaps algorithm of bike-1
+   MUST be SHA-384 from the SHA2 family of hash functions [FIPS-180-3].
+
+   C_BIKE is defined as the BIKE client message octet string.
+
+   S_BIKE is defined as the BIKE server message octet string.
+
+   BIKE is used throughout to refer to the key exchange scheme defined
+   in this section.
+
+4.3.  SIKE
+
+   The SIKE key exchange scheme is the key encapsulation mechanism (KEM)
+   defined in Section 1.3.10 ('Algorithm 2') of [SIKE].  The specific
+   instantiation given in Section 1.4 of [SIKE] MUST be used.  The SIKE
+   key exchange scheme MUST follow the body of the functions KeyGen,
+   Encaps and Decaps defined in algorithm 2.  The starting curve E_0/
+   F_{p^2} is described in Section 1.3.2 of [SIKE] and fully specified
+   by the named parameter sets given in Section 7.2.  The following
+   encoding for the public key (P_C), ciphertext (C_S) and shared secret
+   (K_SIKE) MUST be used:
+
+
+
+
+Hansen, et al.                         [Page 7]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+   The public key C_SIKE consists of one element pk_3 (the last output
+   from the 'KeyGen' algorithm, see 'Algorithm 2' in [SIKE].  C_SIKE
+   MUST be encoded into a single octet string in the following way: pk_3
+   must be used as input to the encoding function 'pktoos', defined in
+   Section 1.2.8 of [SIKE], producing a single octet string.
+
+   The ciphertext S_SIKE consist of two elements: c_0 and c_1.  S_SIKE
+   MUST be encoded into a single octet string in the following way:
+   Concate c_0 with c_1, producing a single octet string.
+
+   The shared secret K_SIKE returned by SIKE is the octet string
+   returned by the algorithm 'decaps', see 'Algorithm 2' [SIKE].
+
+   The public key C_SIKE element pk_3 and ciphertext S_SIKE elements c_0
+   and c_1 MUST be encoded into their single octet string
+   representation, using the encodings described above, before being
+   used as an input to the hash functions G and H, respectively.
+
+   C_SIKE is defined as the SIKE client message octet string.
+
+   S_SIKE is defined as the SIKE server message octet string.
+
+   SIKE is used throughout to refer to the key exchange scheme defined
+   in this section.
+
+5.  Hybrid Key Exchange Methods
+
+   Specification of message numbers for each instantiation of the
+   abstract key exchange method can be found in Section 8.
+
+5.1.  ECDH+BIKE
+
+   The ECDH+BIKE hybrid key exchange method is implemented using the
+   messages defined by the abstract hybrid key exchange method using
+   X=ECDH and Y=BIKE.
+
+   The value of the ECDH client message octet string 'C_X' is the ECDH
+   client message octet string "C_ECDH".  The value of the ECDH server
+   message octet string 'S_X' is the ECDH server message octet string
+   "S_SIKE".  Both values are defined in Section 4.1.
+
+   The value of the BIKE client message octet string 'C_Y' is the BIKE
+   client message octet string "C_BIKE".  The value of the BIKE server
+   message octet string 'S_Y' is the BIKE server message octet string
+   "S_BIKE".  Both values are defined in Section 4.2.
+
+   The curve used in ECDH MUST be the named curve nistp384 defined in
+   [SEC2].
+
+
+
+Hansen, et al.                         [Page 8]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+5.2.  ECDH+SIKE
+
+   The ECDH+BIKE hybrid key exchange method is implemented using the
+   messages defined by the abstract hybrid key exchange method using
+   X=ECDH and Y=SIKE.
+
+   The value of the ECDH client message octet string 'C_X' is the ECDH
+   client message octet string "C_ECDH".  The value of the ECDH server
+   message octet string 'S_X' is the ECDH server message octet string
+   "S_SIKE".  Both values are defined in Section 4.1.
+
+   The value of the SIKE client message octet string 'C_Y' is the SIKE
+   client message octet string "C_SIKE".  The value of the SIKE server
+   message octet string 'S_Y' is the SIKE server message octet string
+   "S_SIKE".  Both values are defined in Section 4.3.
+
+   The curve used in ECDH MUST be the named curve nistp384 defined in
+   [SEC2].
+
+6.  Hybrid Key Exchange Method Names
+
+   The hashing algorithm defined by each family of method names is
+   SHA-384 from the SHA2 family of hashing algorithms [FIPS-180-3] and
+   is represented by the string "sha384".
+
+6.1.  BIKE Domain Parameter Identifiers
+
+   This section specifies identifiers encoding named BIKE domain
+   parameters.  Each identifier will encode one parameter set.  The
+   identifier for the BIKE parameter sets BIKE1-L1, BIKE1-L3 and
+   BIKE1-L5 are the strings, respectively, "bike1-L1", "bike1-L3" and
+   "bike1-L5".
+
+6.2.  SIKE Domain Parameter Identifiers
+
+   This section specifies identifiers encoding named SIKE domain
+   parameters.  Each identifier will encode one parameter set.  The
+   identifier for the SIKE parameter sets SIKEp503, SIKEp751 and
+   SIKEp964 are the strings, respectively, "sike-503", "sike-751" and
+   "sike-964".
+
+6.3.  Hybrid Key Exchange ECDH+BIKE Names
+
+   Each ECDH+BIKE hybrid key exchange method name is a concatenation of
+   three parts:
+
+   1.  The string "ecdh-nistp384-"
+
+
+
+
+Hansen, et al.                         [Page 9]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+   2.  One BIKE domain identifier
+
+   3.  The string "-sha384"
+
+   4.  The string "@openquantumsafe.org"
+
+   The order of concatenation is the order each part appear in the the
+   above list.
+
+6.4.  Hybrid Key Exchange ECDH+SIKE Names
+
+   Each ECDH+SIKE hybrid key exchange method name is concatenation of
+   three parts:
+
+   1.  The string "ecdh-nistp384-"
+
+   2.  One SIKE domain identifier
+
+   3.  The string "-sha384"
+
+   4.  The string "@openquantumsafe.org"
+
+   The order of concatenation is the order each part appear in the the
+   above list.
+
+7.  Named Domain Parameters
+
+7.1.  Named BIKE Domain Parameters
+
+7.1.1.  Required
+
+   Parameter names used in this section relates to parameter names used
+   in [BIKE].
+
+              +---------------+--------+--------+-----+-----+
+              | Parameter set | n      | r      | w   | t   |
+              +---------------+--------+--------+-----+-----+
+              | BIKE1-L1      | 20'326 | 10'163 | 142 | 134 |
+              |               |        |        |     |     |
+              | BIKE1-L3      | 39'706 | 19'835 | 206 | 199 |
+              |               |        |        |     |     |
+              | BIKE1-L5      | 65'498 | 32'749 | 274 | 264 |
+              +---------------+--------+--------+-----+-----+
+
+
+
+
+
+
+
+
+Hansen, et al.                        [Page 10]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+7.1.2.  Recommended
+
+   This document does not specify any recommended parameters for BIKE.
+
+7.2.  Named SIKE Domain Parameters
+
+7.2.1.  Required
+
+   Parameter names used in this section relates to parameter names used
+   in [SIKE].
+
+7.2.1.1.  SIKEp503
+
+   p =   00000004 066F5418 11E1E604 5C6BDDA7 7A4D01B9 BF6C87B7 E7DAF130
+      85BDA221 1E7A0ABF 809FFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF
+      FFFFFFFF FFFFFFFF FFFFFFFF
+
+   e2 =  000000FA
+
+   e3 =  0000009F
+
+   xQ20 =  00097453 912E12F3 DAF32EEF FD618BD9 3D3BBBF3 99137BD3
+      9858CADE FAE382E4 2D6E60A6 2FD62417 AD61A14B 60DB2612 5273EC98
+      0981325D 86E55C45 E3BB46B1
+
+   xQ21 =  00000000
+
+   yQ20 =  0009B666 40A4CC79 F82B68D7 26092338 12DF76E8 B0422EF3
+      527A1F2A 9915EFF1 6E094004 0DF4A15A 84A5ACF0 24FC2ED8 A50102A7
+      31E8D20D 033B4803 5B63DD62
+
+   yQ21 =  00000000
+
+   xP20 =  001F6D52 A7563BB9 356B98A1 16A0CA97 75DBB738 2EB29E24
+      E45299D8 939959EA EEB47FF3 113F6088 2D12103E 4B8B8CD2 B97DA146
+      57AE8C12 8BE82209 D2DDFCA9
+
+   xP21 =  002D44C3 FAD24E4C BDDC8A2D 9DE336A9 2A9912EE 6D09E2DD
+      5C33AB26 D60A268A C91F38E1 AF4C2D5B FA2B87DD 55C8CA60 19C6B0C0
+      8ED92B5A EB6C65A8 E06E53E9
+
+   yP20 =  003C9F7C 397283C0 871F78D9 F74ECC0A 8F89579C CBEF8FE6
+      0D07338A F0A0322E 3F0C66CA 826AA5BF 85EB5366 6C272C8E AEC9B808
+      B3B78E64 22330617 AC23D6F2
+
+   yP21 =  0038222A E95DA234 ABD1B90F D897C2E2 E7995B2C 0006DC92
+      CC079B7C 60C94DCA E9961CC7 A4BAEAC9 D294F6D5 760D4D65 4821193A
+      E92AD42A C0047ADE 55C343FC
+
+
+
+Hansen, et al.                        [Page 11]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+   xR20 =  00173775 ECBEC79C 78FD1ED5 FE36075A ACE1F53F 8FFB97D2
+      A7E80DFC 2875E77E C72D1D4A 99E13353 EC9D147B ADD96126 948A72B3
+      0BDD7CEB AD7B54F8 DDB5CD06
+
+   xR21 =  0002EAA2 24DDDA14 9BBBB908 9D2B2C47 1D068ECA 203465CE
+      97DBC1C8 ED0EBB0F F90E4FBE 7E266BBA 99CBAE05 1797B4D3 5D28E36C
+      1B1CB994 AEEED1CB 59FE5015
+
+   xQ30 =  001E7D6E BCEEC9CF C47779AF FD696A88 A971CDF3 EC61E009
+      DF55CAF4 B6E01903 B2CD1A12 089C2ECE 106BDF74 5894C14D 7E39B699
+      7F70023E 0A23B4B3 787EF08F
+
+   xQ31 =  00000000
+
+   yQ30 =  002EC0AA EF9FBBDD 75FBDA11 DA19725F 79E842FB C355071F
+      D631C1CD F90E08E6 01929FAE C5DAEB0D 96BBB4AD 50FC7C8A D47064F0
+      5C06DC5D 4AAE61CC CEFF1F26
+
+   yQ31 =  00000000
+
+   xP30 =  0021B709 8B640A01 D88708B7 29837E87 0CFF9DF6 D4DF86D8
+      6A7409F4 1156CB5F 7B851482 2730940C 9B51E0D9 821B0A67 DD7ED98B
+      9793685F A2E22D6D 89D66A4E
+
+   xP31 =  002F37F5 75BEBBC3 3851F75B 7AB5D89F C3F07E4D F3CC5234
+      9804B8D1 7A17000A 42FC6C57 34B9FCFD E669730F 3E8569CE B53821D3
+      E8012F7F 391F5736 4F402909
+
+   yP30 =  0000078F 8A30AB36 B301BDF6 72D9E351 8AF741F8 227CC95A
+      9F351B99 623A826D E3F8D90D D6ED42FF 298E394E 77B7AEFE E6010CDF
+      34A7DE9F 9E239B10 3E7B3EEE
+
+   yP31 =  0037F3C6 00488EBB 6B11462C 4CAFC41C D5DC611A 9B0C804E
+      3BF50D6D 8F75C4E7 A136E29E 00D80EB8 653CA830 F2AED61D 04F9F3A8
+      317F7916 E016F273 3B828AC0
+
+   xR30 =  000D4818 D120A24A BF48DB51 D129E6B1 F24F4BBB 2C16FACC
+      0C8C0632 3EEEC2FA 5B5E887E 17226417 B1907310 BFE6784F DEBBAC8C
+      2A9ABBE7 53F52259 A7B7D70E
+
+   xR31 =  0019E75F 0F03312D 22CBBF15 3747525D 89E5155B ABB8BF0C
+      130CB567 CA532F69 AAF57EA7 682B9957 021D9041 4433ABBE EDC233E9
+      08218578 1C16724C 8C356777
+
+
+
+
+
+
+
+
+Hansen, et al.                        [Page 12]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+7.2.1.2.  SIKEp751
+
+   p =   00000004 066F5418 11E1E604 5C6BDDA7 7A4D01B9 BF6C87B7 E7DAF130
+      85BDA221 1E7A0ABF 809FFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF
+      FFFFFFFF FFFFFFFF FFFFFFFF
+
+   e2 =  00000174
+
+   e3 =  000000EF
+
+   xQ20 =  00003E82 027A38E9 429C8D36 FF46BCC9 3FA23F89 F6BE06D2
+      B1317AD9 04386217 83FDB7A4 AD3E83E8 6CAE096D 5DB822C9 8E561E00
+      8FA0E3F3 B9AC2F40 C56D6FA4 A58A2044 9AF1F133 5661D14A B7347693
+      63264608 6CE3ACD5 4B0346F5 CCE233E9
+
+   xQ21 =  00000000
+
+   yQ20 =  00003BBF 8DCD4E7E B6236F5F 598D56EB 5E15915A 755883B7
+      C331B043 DA010E6A 163A7421 DFA8378D 1E911F50 BF3F721A 8ED5950D
+      80325A8D 0F147EF3 BD0CFEC5 236C7FAC 9E69F7FD 5A99EBEC 3B5B8B00
+      0F8EEA73 70893430 12E0D620 BFB341D
+
+   yQ21 =  00000000
+
+   xP20 =  00005492 1C31F0DC 9531CB89 0FC5EC66 DF2E7F0D 55761363
+      C6E375DA 69B0682C ABE5C0FF FCBE6E1A D46563F0 42FA06B9 F207FCF3
+      CDD26736 52828FF5 0C3F7B75 5C0BE072 950D16CA 747C1467 75C0267A
+      401FFC73 8B03A49E 9A36B395 72AFB363
+
+   xP21 =  00002884 9BC0D81E 01993137 A5B63D6E 633C4E97 AB4FF118
+      CCF63DFE 623092AC 86B6D4A9 B751797C BA1A1775 00E9EB5A F7852B7D
+      F02C3348 44D652EF C4729178 A1DBAD8C A47BB7E7 57C6D43B 799811A6
+      3BEBE649 C18101F0 3AD752CD CD73BF66
+
+   yP20 =  00001961 19D87272 DC3AA722 3476C8C3 269D48CA EFAE692F
+      68DCF2D6 E1BEB5B9 7525D502 6C157C7C 740B41AD E80A8CF2 E1E0B37E
+      5F5FD4ED 88235BF7 404BE391 89C137E2 1C035EF6 339D7FAC BA38E72D
+      69043710 E76266A5 FC14EFB9 5E5FBC7C
+
+   yP21 =  0000D3AC 09A67D59 CC8D78B0 FA6681AE 78BDF0C8 F558E386
+      6005E435 5B0B1993 18D9CDD6 7C0A7DB2 34F9EA1E C4C5F1E5 9168B7DB
+      D14281F0 9E8DF904 A3D574CA D526DC5A 3667490A DE1A4C13 B09F7B11
+      5C4E488F D4DD5F76 70B58973 22AD41D
+
+   xR20 =  000022A0 B5A35A2B 0C56135A 7CEC5CFB 97964A7C 6226FE90
+      9F374362 A8ECA3AB 14A1B7B0 C87AC875 DCE5888D 83B623BF 0011A4AC
+      138F62EF 6B2D2D84 F636548A 9F920F23 8336E5A3 6E45E405 5940E3C9
+      4385B8FC 53743964 32EEF2AE 178CEFDD
+
+
+
+Hansen, et al.                        [Page 13]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+   xR21 =  00000F9C 4AFCDA80 9C3358B0 96B250C6 9B20310F DF2EF631
+      711AA4EF EC49A4E7 6483F320 B793F2EB C63365EE D14AA3F6 EA33FEB5
+      6796F011 BA6C6DFB 4D0A00AA C4D27866 46D914AD 026CBB4A 592EC74B
+      5485372E 51382D44 528DD491 B83D9547
+
+   xQ30 =  00002F1D 80EF06EF 960A01AB 8FF409A2 F8D5BCE8 59ED725D
+      E145FE2D 525160E0 A3AD8E17 B9F9238C D5E69CF2 6DF23742 9BD37786
+      59023B9E CB610E30 288A7770 D3785AAA A4D646C5 76AECB94 B919AEED
+      D9E1DF56 6C1D26D3 76ED2325 DCC93103
+
+   xQ31 =  00000000
+
+   yQ30 =  00000127 A46D082A 1ACAF351 F09AB55A 15445287 ED1CC55D
+      C3589212 3951D4B6 E302C512 9C049EEB 399A6EDB 2EEB2F9B 0A94F06C
+      DFB3EADE 76EBA0C8 419745E9 7D12754F 00E898A3 15B52912 2CFE3CA6
+      BBC6BAF5 F6BA40BB 91479226 A0687894
+
+   yQ31 =  00000000
+
+   xP30 =  000005FD 1A3C4DD0 F6309741 96FED351 9152BC70 98B9E2B1
+      21ECA46B D10A5CC9 F4BCC6C6 89B8E4C0 63B37980 75FCEE6E DAA9EB10
+      8B3CD004 95CF04DD 8CE4A08F BE685A12 7D40E45F 4CF45098 A578DEB4
+      43686993 94C43BFC 9BC5E000 52F78E8D
+
+   xP31 =  00002B88 A03360B3 38954773 2C9140C0 5DEA6516 881FE108
+      211BE887 CC43FCB8 0C06A1D8 6FF5457D 3BB7DB93 6394EC33 821AA393
+      33A60AF8 4B537974 CFA0BA82 87D699D2 BF79BA55 9026C64A 6ED61050
+      1D2357C1 0B9A6C8F 83742492 2275ACBF
+
+   yP30 =  000053B5 5053E3F0 4FC315EF B1B7B2C4 AFCB4FEF 12CE744A
+      F3B243C6 E6B1417E 94A78D49 80DDE181 89646492 3E01AACC 3DA040A0
+      747CA675 54A35268 4DA207C4 9022D930 732DF6BD 0BF37E1F 5C169176
+      69A70F88 059C1C73 9A79D7CF A0C529D9
+
+   yP31 =  0000044E 44196909 252ECD7B 91643238 15294F02 AED22C4E
+      4EB43D2C E2BC5F29 EB575D45 CA8B6B4C 4242E369 AE3A1EFC 844E9D1C
+      57B0AE33 74BC2CED AD16B0C6 99158332 E2D9AB3F 0025C034 8C5F70FD
+      C4DD7C48 65E64B8B 843F03D8 07447D5E
+
+   xR30 =  0000077B 3BB69009 428A327D 43CA6016 9715F547 454F88CD
+      017B32DF 58A7252C 2B3C3D00 D52CCD31 33D54041 D8BCAEA2 91F20572
+      02328712 CD395575 CD7CCD3C E70C0A1E BF633BA9 46559458 878F41F9
+      FDD1727E 2C31125B 2FE5B713 06704829
+
+   xR31 =  00006D91 393A57DB F47FD6DC F841F17E CD719CAE 1D33C683
+      2A75B0F1 68855BCC 38D2A479 2DFF9BC8 6DEACA10 B1AA808D 539B167D
+      73BBA321 68687FA3 F85AE93A 1ADDE5BD 1FD5B681 DCC6C344 54D44969
+      76C22D80 C95E42B1 2576FC0F B4074B9F
+
+
+
+Hansen, et al.                        [Page 14]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+7.2.1.3.  SIKEp964
+
+   p =   00000008 6B5BFF76 43C64F7A 10028248 AD4FC4B1 50CBAA75 A2A1FA44
+      CBAB2451 35469BAB 093F2B8D AD5281E7 E56EF6AA 57A94749 ABB38EAB
+      467ACDE5 451CD4BF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF
+      FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF
+      FFFFFFFF FFFFFFFF FFFFFFFF
+
+   e2 =  000001E6
+
+   e3 =  0000012D
+
+   xQ20 =  00000001 CD5AEB4E 02DBE2CE B712A45E ED7720D3 EA94116F
+      1E45C834 FDFF3A86 7BBB267B F8F5F9B1 9C369F7A FE141B85 D591243E
+      7310B6D0 2E78DB88 8615254D F178C1F7 5F2BDAF7 03E83BB9 7DBCDC3D
+      FDB60BA3 85EC8F42 D4AD1505 21ECA6EC 4D3086A7 783698A7 1544E10A
+      45EA605E 1B86A894 7F14FA2E 03845DAE
+
+   xQ21 =  00000000
+
+   yQ20 =  00000002 2E751F1F 60841CF4 E8D4D3BD 8D400F58 9761CA1F
+      71A9C1F3 83C0FE55 3E6492DB E1F78D5F 9A768920 B682786E 8125398F
+      765A481B 32913561 FD16B270 19D9C10C 4F9062AC 1513FEB2 FE942DD2
+      2AC53F6E C319C4D1 8A53A481 430F3DFA 22E57EDA 0D067C37 F91EA8F1
+      3E4B1C65 4E974856 781F8E0A 397ED362
+
+   yQ21 =  00000000
+
+   xP20 =  00000006 ED767E28 04975D81 80368FB9 A72CE64E 838A5497
+      4865BFF1 A86AEF07 D6171A8A 4DF351F1 D4C94AAF 82BD6EBD 396F3342
+      48282F50 73178AB5 7B906BEF 89A2A152 A10D04A5 B20A0FFF 96B0B48F
+      0599FC9B D2AD52E0 81BB7FEA 7B5E8BF4 C3B0AB13 0731F4C5 A974CFA5
+      AD678121 7A20F9EC D30691D9 D1941D03
+
+   xP21 =  00000003 FE63FBDC A589518A 3DA694EC C8B65934 6693C45B
+      D8AC86B6 F0C778CF 290C9F42 9163FEF6 4AFAD182 ADE1B0C4 DFC8CF29
+      C35455C7 BA69C225 59F2E0D4 20AE05BB 0AE3ADC0 9A4A0AF2 8CE1A1C5
+      93171033 7AA68884 EFCCD60A C76FD3F1 7ED50205 305509E0 5955F60D
+      5008D788 B83F5FA4 57FD79EC DC7179D1
+
+   yP20 =  00000000 4E0A8662 85403BC0 408F9BCA 912025E3 17111896
+      1C865461 2AE20CEE AF91A98A 4F278EAE BB704602 8AD90CD9 5B99BF6B
+      34233CD4 B084B2CA 4598DF3A 6D4839CA 6EA493ED 420CF4C1 3A1F37F1
+      EC59620F 08693649 C72380A8 479E3753 93D3F4A7 59DF65F1 F74B4C65
+      6B79DF2A 5DA2959E FB006BDA D015D252
+
+   yP21 =  00000007 38846048 2319281B 78C6AC1F E1A91DB7 2A2C9AA3
+      4BEE1EBE A33EF043 AA1BFA0C 45894142 95E94C91 1E19E808 246B2A0A
+
+
+
+Hansen, et al.                        [Page 15]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+      98593958 E1F70888 E00332DE AE7D7FDB CA53398E 59530E5D 2A292463
+      7533F46C 4684373D DDB8D09B 2A75C307 3EA3C19E CF946FCB 2B428B6E
+      9CF93F22 33DD257C 5CAD4041 3F78CD1D
+
+   xR20 =  00000008 44F024B8 D993B660 48C9DA7F 1724AE2E 4C6162F8
+      4804FE3F E290FBEB 5ABF7DF2 5C395121 77C8E4A4 7A35F8EC D037B699
+      E34F58EF 675AE188 A1537838 A4DDBA69 FC7BC3FA CB7E3815 F3031244
+      AF1BCCE1 95AF45B4 2A587EE8 7A00BF2D A1E972D8 D662F4DC 5EC1CDB1
+      03D9EED2 215D4DD7 48004985 8925A63A
+
+   xR21 =  00000007 35F06B97 66B69FF9 17835EAD C539A00F FC186ED2
+      5947F701 FDA7EDEA F517039F 9B0DA172 1FDAE978 4838C75B 46A452DC
+      902EC8DD 1F462564 3B42C596 C2CF0404 5A7AA804 3F07C9A9 F82611D2
+      02F06834 512A3803 EF64650E 5309163F 25CCC336 CC852764 9E340F59
+      CDDFB51B 24D1C02E 8CB2653E 7A05B709
+
+   xQ30 =  00000003 81DBCAB1 EE7A4CA3 192CDA85 3F4E0F42 6522EB9D
+      3277421C 29D73CC4 F70BEFE7 009767C4 AE451600 3B237223 422C0E75
+      2ACD9D8F CE07263D 2C1D1013 08C0B97E DB8D4A8C 53C2064B 05DF9A61
+      E8216CA1 FFAC55F4 CA043972 52704945 C27136A0 56F6B5CF 8838B7F6
+      52BC16C1 392B5597 36CAF63B F0058A53
+
+   xQ31 =  00000000
+
+   yQ30 =  00000001 AFBFA81B 55C7D789 B6E89BC7 A311F3CE E4B733B0
+      FA5B7D56 D29A644B 596B7729 778E0773 F908D76E 0377B3CA 41C03D79
+      7DE4F0B7 985EB512 7D2151EC 4B6C1136 1AEB4CEA A3F776E0 8E4AD01B
+      7BB46074 D425C8A2 61E88B14 5C4153BF 67732E82 9986EB9D 29C88385
+      1EEEB87C C4FD96A0 84332542 6C108687
+
+   yQ31 =  00000000
+
+   xP30 =  00000004 FE46F0B0 09171C87 0FE840B7 FD0C3F14 93813CD1
+      25C2191C 9FA4BDE4 0941A603 124F1B81 BBFBEBFD AC06F808 07562639
+      FC61A579 62AE6E6B 7EE793CF 7B359746 FEB0DA11 0D704681 F83EF6B4
+      40DC5DED D2A42471 49D0A44C 452ED374 A394319A 8888A2A0 9CC4A0F3
+      5A07AA3D 248CF780 3E77EAD2 A4BEA308
+
+   xP31 =  00000006 DD4FC176 8E1ADEE5 4DC4E41C FAA7B810 4644DD69
+      0616D374 A9139013 FD847C2C D11BA6CA 4C4FC26A 63FE198B 666B7912
+      FBF889E9 91CF4B90 3651F441 4CD4AA50 BC02CE2E C986A7BF C1A8D364
+      F93410AD E3B959FF 1F036F36 EF3AFF88 D28DB500 8276C340 2158ADB4
+      A44BAECE D2AF6503 093FD8B6 A58EC136
+
+   yP30 =  000000003 EA8CDCF4 BC1C1B9D 2D449022 387D4DDE F05CE98C
+      B63E722B 0EA14717 C5FFA82E E107832E 5FE58C28 90185D2C 90D1BD94
+      AC13C69F D483AC80 66B1F1A4 844F7655 884B2379 0088A6DA 915FD709
+
+
+
+
+Hansen, et al.                        [Page 16]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+      EFE79A88 028108F4 D4DFBFAD BA65EFBB C5D621BA 31F12BE6 FB717D3B
+      1D8CD78D CD05B0D2 B7E87C10 3D1897C0
+
+   yP31 =  00000007 77607A21 85C04FBF CFA5EAF7 7F38F40F 42746739
+      748CA176 BBE31739 4BDA28F3 D971DFB9 CCB67207 E201FFB0 0A9A3E6B
+      9B7E804F BB6EF61E CEBDB8AC 68831E10 E8A72613 A47F132B D9A2309E
+      404FCFFF 7EA7BC87 AD448B8B 8798AB61 CA6F97DB 3B240887 9DEB8A9F
+      930C4EE4 69486FA1 129E89B6 7C084CD9
+
+   xR30 =  00000007 DE290085 EBBDC801 A1D6292D 1F2E89FF 463669ED
+      2F5F6C02 B8010A75 245C4D39 84002821 B8A243C7 56512A5F C1FC0867
+      A84583D7 6B0404E7 E73CEB70 71E2AE3B F43BFB77 A87BC98F DF888E28
+      5CD4A3C9 4E4D1795 009E41ED B8A3AD8F 81321138 E4A87B69 416AEFF0
+      94E541F4 8681863B AD30FB2F 32EA019A
+
+   xR31 =  00000007 A2A2DFA4 FB567336 60ACCB80 308A4482 B1A46D3B
+      9BB20313 F164CC80 9A3A6B4D 2FBC4357 4994354D C06D409F 9F647E82
+      F4F05D6C 5A70E340 DF4B9555 9787F82E AD7F7295 590FDCD9 D54B8001
+      094DC809 29EF4C5A BB8E388A 53AA0BD3 88D890B5 980F1FD1 9404025B
+      582C640D DFDA1BDF 46D37046 4A812732
+
+7.2.2.  Recommened
+
+   This document does not specify any recommended parameters for SIKE.
+
+8.  Summary of Message Numbers
+
+   The message numbers 30-39 are key-exchange-specific and in a private
+   namespace defined in [RFC4250] that may be redefined by any key
+   exchange method [RFC4253] without requiring an IANA registration
+   process.  The following message numbers have been defined in this
+   document.
+
+8.1.  ECDH+BIKE Message Numbers
+
+   #define SSH_MSG_HY_ECDH_BIKE_INIT \  30
+
+   #define SSH_MSG_HY_ECDH_BIKE_REPLY \  31
+
+8.2.  ECDH+SIKE Message Numbers
+
+   #define SSH_MSG_HY_ECDH_SIKE_INIT \  30
+
+   #define SSH_MSG_HY_ECDH_SIKE_REPLY \  31
+
+
+
+
+
+
+
+Hansen, et al.                        [Page 17]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+9.  Handling Long Messages
+
+   An implementaton adhering to [RFC4253] must be able to support
+   packets with an uncompressed payload length of 32768 bytes or less
+   and a total packet size of 35000 bytes or less (including
+   'packet_length', 'padding_length', 'payload', 'random padding', and
+   'mac').  These numbers represent what must be 'minimally supported'
+   by implementations.  This can present a problem when using post-
+   quantum key exchange schemes because some post-quantum schemes can
+   produce much larger messages than what is normally produced by
+   existing key exchange methods defined for SSH.  This document does
+   not define any named domain parameters (see Section 7) that cause any
+   hybrid key exchange method related packets to exceed the minimally
+   supported packet length.  This document does not define behaviour in
+   cases where a hybrid key exchange message cause a packet to exceed
+   the minimally supported packet length.
+
+10.  Defined Encoding Functions
+
+10.1.  Defined BIKE Encoding Functions
+
+   The input to the function BIKE_2_OCTET is an element, e, from a
+   polynomial ring R = F_2[X]/(X^{r}-1).
+
+   BIKE_2_OCTET(e) {
+       size := ((r + 7) / 8) //Round up to nearest multiple of 8
+       parse e: a_0 + a_1 * X + a_2 * X^2 + ... a_{r-1} X^{r-1}
+       out := a_0a_1a_2...a_{r-1} //little endian
+       append to out, a (size - r)-number of zero bits
+       return out
+   }
+
+11.  Security Considerations
+
+   The ECDH key exchange scheme defined in this document is identical to
+   the ECDH scheme defined in [RFC5656].  The security considerations
+   given in [RFC5656] therefore also applies to the ECDH key exchange
+   scheme defined in this document.
+
+   The key exchange schemes BIKE and SIKE defined in this document are
+   build from post-quantum key encapsulation methods (KEM) of the same
+   name.  Both KEMs are submitted to the NIST Post-Quantum Cryptography
+   Standardization process [NIST].  The claimed security of BIKE [BIKE]
+   and SIKE [SIKE] therefore does not have the same level of trust as
+   older cryptographic algorithms that have been subject to more
+   extensive cryptanalysis.
+
+
+
+
+
+Hansen, et al.                        [Page 18]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+   The hybrid key exchange methods defined in this document maintain the
+   same level of classical security provided by ECDH, but also adds the
+   level of classical security and quantum resistance offered by BIKE or
+   SIKE (depending on the particular hybrid key exchange method).  The
+   hybrid key exchange methods will always be at least as secure as the
+   most secure key exchange scheme executed as part of the hybrid key
+   exchange method.  This previous statement is true against classical
+   adversaries.  However, the hybrid key exchange methods defined in
+   this document will only inheret quantum resistance from BIKE or SIKE
+   (depending on the particular hybrid key exchange method).
+
+   The combination of the shared secrets defined in Section 3.3
+   additively adds the entropy from both shared secrets.  That is, if
+   shared secret K_X has entropy a and shared secret K_Y has entropy b
+   then the entropy of the combined shared secret K is equal to a+b.
+
+12.  IANA Considerations
+
+   This document creates no new registries.
+
+13.  References
+
+13.1.  Normative References
+
+   [BIKE]     Aragon, N., Barreto, S. L. M., P., Bettaieb, S., Bideoux,
+              L., Blazy, O., Deneuville, J., Gaborit, P., Gueron, S.,
+              Guneysu, T., Melchor, C., Misoczki, R., Persichetti, E.,
+              Sendrier, N., Tillich, J., and G. Zemor, "BIKE: Bit
+              Flipping Key Encapsulation", BIKE Spec V2, March 2018,
+              <http://bikesuite.org/files/BIKE.pdf>.
+
+   [FIPS-180-3]
+              National Institute of Standards and Technology, "Secure
+              Hash Standard", FIPS 180-3, October 2008,
+              <http://www.secg.org/sec1-v2.pdf>.
+
+   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
+              Requirement Levels", BCP 14, RFC 2119,
+              DOI 10.17487/RFC2119, March 1997,
+              <https://www.rfc-editor.org/info/rfc2119>.
+
+   [RFC4250]  Ylonen, T. and C. Lonvick, Ed, "The Secure Shell (SSH)
+              Protocol Assigned Numbers", RFC 4250,
+              DOI 10.17487/RFC4250, January 2006,
+              <https://www.rfc-editor.org/info/rfc4250>.
+
+
+
+
+
+
+Hansen, et al.                        [Page 19]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+   [RFC4251]  Ylonen, T. and C. Lonvick, Ed, "The Secure Shell (SSH)
+              Transport Layer Protocol", RFC 4251, DOI 10.17487/RFC4251,
+              January 2006, <https://www.rfc-editor.org/info/rfc4250>.
+
+   [RFC4253]  Ylonen, T. and C. Lonvick, Ed, "The Secure Shell (SSH)
+              Transport Layer Protocol", RFC 4253, DOI 10.17487/RFC4253,
+              January 2006, <https://www.rfc-editor.org/info/rfc4253>.
+
+   [RFC5656]  Stebila, D. and J. Green, "Elliptic Cure Algortihm
+              Integration in the Secure Shell Transport Layer",
+              RFC 5656, DOI 10.17487/RFC5656, December 2009,
+              <https://www.rfc-editor.org/info/rfc5656>.
+
+   [SEC1]     Standards for Efficient Cryptography Group, "Ellipctic
+              Curve Cryptography", SEC 1, May 2009,
+              <http://www.secg.org/sec1-v2.pdf>.
+
+   [SEC2]     Standards for Efficient Cryptography Group, "Ellipctic
+              Curve Cryptography", SEC 1, Jan 2010,
+              <http://www.secg.org/sec2-v2.pdf>.
+
+   [SIKE]     Jao, D., Azarderakhsh, R., Campagna, M., Costello, C.,
+              Feo, L., Hess, B., Jalali, A., Koziel, B., LaMacchia, B.,
+              Longa, P., Naehrig, M., Renes, J., Soukharev, V., and D.
+              Urbanik, "Supersingular Isogeny Key Encapsulation", SIKE
+              Spec V1, November 2017, <http://sike.org/files/SIKE.zip>.
+
+13.2.  Informative References
+
+   [NIST]     National Institute of Standards and Technology, "Post-
+              Quantum Cryptography Standardization", Jan 2018,
+              <https://csrc.nist.gov/Projects/Post-Quantum-Cryptography/
+              Post-Quantum-Cryptography-Standardization>.
+
+Authors' Addresses
+
+   Torben Brandt Hansen
+   Amazon
+
+   Email: htorben@amazon.com
+
+
+   Matthew Campagna
+   Amazon
+
+   Email: campagna@amazon.com
+
+
+
+
+
+Hansen, et al.                        [Page 20]
+
+PRE-DRAFT: Hybrid Key Exchange Integration in the  June 2018
+
+
+   Eric Crockett
+   Amazon
+
+   Email: erricron@amazon.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Hansen, et al.          Expires December 23, 2018              [Page 21]
--- a/kex.c
+++ b/kex.c
@@ -81,6 +81,14 @@
 	int ec_nid;
 	int hash_alg;
 };
+
+#ifdef WITH_HYBRID_KEX
+#define HYBRID_ECDH_OQS_KEX(X) { X, KEX_HY_ECDH_OQS, NID_secp384r1, SSH_DIGEST_SHA384},
+#endif /* WITH_HYBRID_KEX */
+#ifdef WITH_PQ_KEX
+#define PQ_OQS_KEX(X) { X, KEX_PQ_OQS, 0, SSH_DIGEST_SHA384},
+#endif /* WITH_PQ_KEX */
+
 static const struct kexalg kexalgs[] = {
 #ifdef WITH_OPENSSL
 	{ KEX_DH1, KEX_DH_GRP1_SHA1, 0, SSH_DIGEST_SHA1 },
@@ -97,12 +105,192 @@
 	    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },
 	{ KEX_ECDH_SHA2_NISTP384, KEX_ECDH_SHA2, NID_secp384r1,
 	    SSH_DIGEST_SHA384 },
+#if defined(WITH_OQS) && defined(WITH_HYBRID_KEX)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_OQSDEFAULT_SHA384)
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_HYBRID_KEXS_START
+#ifdef HAVE_BIKE
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_BIKE1_L1_CPA_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_BIKE1_L3_CPA_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_BIKE1_L1_FO_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_BIKE1_L3_FO_SHA384)
+#endif /* HAVE_BIKE */
+#ifdef HAVE_CLASSIC_MCELIECE
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_348864_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_348864F_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_460896_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_460896F_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_6688128_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_6688128F_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_6960119_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_6960119F_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_8192128_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_8192128F_SHA384)
+#endif /* HAVE_CLASSIC_MCELIECE */
+#ifdef HAVE_FRODO
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_FRODO_640_AES_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_FRODO_640_SHAKE_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_FRODO_976_AES_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_FRODO_976_SHAKE_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_FRODO_1344_AES_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_FRODO_1344_SHAKE_SHA384)
+#endif /* HAVE_FRODO */
+#ifdef HAVE_KYBER
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_KYBER_512_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_KYBER_768_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_KYBER_1024_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_KYBER_512_90S_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_KYBER_768_90S_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_KYBER_1024_90S_SHA384)
+#endif /* HAVE_KYBER */
+#ifdef HAVE_NEWHOPE
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_NEWHOPE_512_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_NEWHOPE_1024_SHA384)
+#endif /* HAVE_NEWHOPE */
+#ifdef HAVE_NTRU
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_NTRU_HPS_2048_509_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_NTRU_HPS_2048_677_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_NTRU_HRSS_701_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_NTRU_HPS_4096_821_SHA384)
+#endif /* HAVE_NTRU */
+#ifdef HAVE_SABER
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SABER_LIGHTSABER_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SABER_SABER_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SABER_FIRESABER_SHA384)
+#endif /* HAVE_SABER */
+#ifdef HAVE_SIDH
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SIDH_p434_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SIDH_p503_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SIDH_p610_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SIDH_p751_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SIDH_P434_COMPRESSED_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SIDH_P503_COMPRESSED_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SIDH_P610_COMPRESSED_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SIDH_P751_COMPRESSED_SHA384)
+#endif /* HAVE_SIDH */
+#ifdef HAVE_SIKE
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SIKE_P434_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SIKE_P503_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SIKE_P610_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SIKE_P751_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384__SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SIKE_P503_COMPRESSED_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SIKE_P610_COMPRESSED_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_SIKE_P751_COMPRESSED_SHA384)
+#endif /* HAVE_SIKE */
+#ifdef HAVE_THREEBEARS
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_BABYBEAR_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_BABYBEAR_EPHEM_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_MAMABEAR_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_MAMABEAR_EPHEM_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_PAPABEAR_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_PAPABEAR_EPHEM_SHA384)
+#endif /* HAVE_THREEBEARS */
+#ifdef HAVE_HQC
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_HQC_128_1_CCA2_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_HQC_192_1_CCA2_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_HQC_192_2_CCA2_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_HQC_256_1_CCA2_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_HQC_256_2_CCA2_SHA384)
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_HQC_256_3_CCA2_SHA384)
+#endif /* HAVE_HQC */
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_HYBRID_KEXS_END
+#endif /* defined(WITH_OQS) && defined(WITH_HYBRID_KEX) */
 # ifdef OPENSSL_HAS_NISTP521
 	{ KEX_ECDH_SHA2_NISTP521, KEX_ECDH_SHA2, NID_secp521r1,
 	    SSH_DIGEST_SHA512 },
 # endif /* OPENSSL_HAS_NISTP521 */
 #endif /* OPENSSL_HAS_ECC */
 #endif /* WITH_OPENSSL */
+#if defined(WITH_OQS) && defined(WITH_PQ_KEX)
+	PQ_OQS_KEX(KEX_OQSDEFAULT_SHA384)
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_PQ_KEXS_START
+#ifdef HAVE_BIKE
+	PQ_OQS_KEX(KEX_BIKE1_L1_CPA_SHA384)
+	PQ_OQS_KEX(KEX_BIKE1_L3_CPA_SHA384)
+	PQ_OQS_KEX(KEX_BIKE1_L1_FO_SHA384)
+	PQ_OQS_KEX(KEX_BIKE1_L3_FO_SHA384)
+#endif /* HAVE_BIKE */
+#ifdef HAVE_CLASSIC_MCELIECE
+	PQ_OQS_KEX(KEX_CLASSIC_MCELIECE_348864_SHA384)
+	PQ_OQS_KEX(KEX_CLASSIC_MCELIECE_348864F_SHA384)
+	PQ_OQS_KEX(KEX_CLASSIC_MCELIECE_460896_SHA384)
+	PQ_OQS_KEX(KEX_CLASSIC_MCELIECE_460896F_SHA384)
+	PQ_OQS_KEX(KEX_CLASSIC_MCELIECE_6688128_SHA384)
+	PQ_OQS_KEX(KEX_CLASSIC_MCELIECE_6688128F_SHA384)
+	PQ_OQS_KEX(KEX_CLASSIC_MCELIECE_6960119_SHA384)
+	PQ_OQS_KEX(KEX_CLASSIC_MCELIECE_6960119F_SHA384)
+	PQ_OQS_KEX(KEX_CLASSIC_MCELIECE_8192128_SHA384)
+	PQ_OQS_KEX(KEX_CLASSIC_MCELIECE_8192128F_SHA384)
+#endif /* HAVE_CLASSIC_MCELIECE */
+#ifdef HAVE_FRODO
+	PQ_OQS_KEX(KEX_FRODO_640_AES_SHA384)
+	PQ_OQS_KEX(KEX_FRODO_640_SHAKE_SHA384)
+	PQ_OQS_KEX(KEX_FRODO_976_AES_SHA384)
+	PQ_OQS_KEX(KEX_FRODO_976_SHAKE_SHA384)
+	PQ_OQS_KEX(KEX_FRODO_1344_AES_SHA384)
+	PQ_OQS_KEX(KEX_FRODO_1344_SHAKE_SHA384)
+#endif /* HAVE_FRODO */
+#ifdef HAVE_KYBER
+	PQ_OQS_KEX(KEX_KYBER_512_SHA384)
+	PQ_OQS_KEX(KEX_KYBER_768_SHA384)
+	PQ_OQS_KEX(KEX_KYBER_1024_SHA384)
+	PQ_OQS_KEX(KEX_KYBER_512_90S_SHA384)
+	PQ_OQS_KEX(KEX_KYBER_768_90S_SHA384)
+	PQ_OQS_KEX(KEX_KYBER_1024_90S_SHA384)
+#endif /* HAVE_KYBER */
+#ifdef HAVE_NEWHOPE
+	PQ_OQS_KEX(KEX_NEWHOPE_512_SHA384)
+	PQ_OQS_KEX(KEX_NEWHOPE_1024_SHA384)
+#endif /* HAVE_NEWHOPE */
+#ifdef HAVE_NTRU
+	PQ_OQS_KEX(KEX_NTRU_HPS_2048_509_SHA384)
+	PQ_OQS_KEX(KEX_NTRU_HPS_2048_677_SHA384)
+	PQ_OQS_KEX(KEX_NTRU_HRSS_701_SHA384)
+	PQ_OQS_KEX(KEX_NTRU_HPS_4096_821_SHA384)
+#endif /* HAVE_NTRU */
+#ifdef HAVE_SABER
+	PQ_OQS_KEX(KEX_SABER_LIGHTSABER_SHA384)
+	PQ_OQS_KEX(KEX_SABER_SABER_SHA384)
+	PQ_OQS_KEX(KEX_SABER_FIRESABER_SHA384)
+#endif /* HAVE_SABER */
+#ifdef HAVE_SIDH
+	PQ_OQS_KEX(KEX_SIDH_p434_SHA384)
+	PQ_OQS_KEX(KEX_SIDH_p503_SHA384)
+	PQ_OQS_KEX(KEX_SIDH_p610_SHA384)
+	PQ_OQS_KEX(KEX_SIDH_p751_SHA384)
+	PQ_OQS_KEX(KEX_SIDH_P434_COMPRESSED_SHA384)
+	PQ_OQS_KEX(KEX_SIDH_P503_COMPRESSED_SHA384)
+	PQ_OQS_KEX(KEX_SIDH_P610_COMPRESSED_SHA384)
+	PQ_OQS_KEX(KEX_SIDH_P751_COMPRESSED_SHA384)
+#endif /* HAVE_SIDH */
+#ifdef HAVE_SIKE
+	PQ_OQS_KEX(KEX_SIKE_P434_SHA384)
+	PQ_OQS_KEX(KEX_SIKE_P503_SHA384)
+	PQ_OQS_KEX(KEX_SIKE_P610_SHA384)
+	PQ_OQS_KEX(KEX_SIKE_P751_SHA384)
+	PQ_OQS_KEX(KEX__SHA384)
+	PQ_OQS_KEX(KEX_SIKE_P503_COMPRESSED_SHA384)
+	PQ_OQS_KEX(KEX_SIKE_P610_COMPRESSED_SHA384)
+	PQ_OQS_KEX(KEX_SIKE_P751_COMPRESSED_SHA384)
+#endif /* HAVE_SIKE */
+#ifdef HAVE_THREEBEARS
+	PQ_OQS_KEX(KEX_BABYBEAR_SHA384)
+	PQ_OQS_KEX(KEX_BABYBEAR_EPHEM_SHA384)
+	PQ_OQS_KEX(KEX_MAMABEAR_SHA384)
+	PQ_OQS_KEX(KEX_MAMABEAR_EPHEM_SHA384)
+	PQ_OQS_KEX(KEX_PAPABEAR_SHA384)
+	PQ_OQS_KEX(KEX_PAPABEAR_EPHEM_SHA384)
+#endif /* HAVE_THREEBEARS */
+#ifdef HAVE_HQC
+	PQ_OQS_KEX(KEX_HQC_128_1_CCA2_SHA384)
+	PQ_OQS_KEX(KEX_HQC_192_1_CCA2_SHA384)
+	PQ_OQS_KEX(KEX_HQC_192_2_CCA2_SHA384)
+	PQ_OQS_KEX(KEX_HQC_256_1_CCA2_SHA384)
+	PQ_OQS_KEX(KEX_HQC_256_2_CCA2_SHA384)
+	PQ_OQS_KEX(KEX_HQC_256_3_CCA2_SHA384)
+#endif /* HAVE_HQC */
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_PQ_KEXS_END
+#endif /* defined(WITH_OQS) && defined(WITH_PQ_KEX) */
 #if defined(HAVE_EVP_SHA256) || !defined(WITH_OPENSSL)
 	{ KEX_CURVE25519_SHA256, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },
 	{ KEX_CURVE25519_SHA256_OLD, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },
@@ -118,6 +306,60 @@
 	{ NULL, -1, -1, -1 },
 };
 
+#ifdef WITH_HYBRID_KEX
+
+static int
+init_hybrid_kex(HYBRID_KEX_CTX **hybrid_kex_ctx, const struct kexalg *kexalg);
+
+/*
+ * @brief Initialise the hybrid key exchange method context if the negotiated
+ * kex is a hybrid type,
+ *
+ * @return result of intialising hybrid key exchange method
+ * 0 if negotiated kex is _not_ a hybrid type
+ */
+static int
+init_hybrid_kex(HYBRID_KEX_CTX **hybrid_kex_ctx, const struct kexalg *kexalg) {
+
+	switch (kexalg->type) {
+#if defined(OPENSSL_HAS_ECC) && defined(WITH_OQS)
+		case KEX_HY_ECDH_OQS:
+			return hybrid_ecdh_oqs_init(hybrid_kex_ctx, kexalg->name,
+				kexalg->ec_nid);
+#endif /* OPENSSL_HAS_ECC && WITH_OQS */
+		default:
+			return 0;
+	}
+}
+
+#endif /* WITH_HYBRID_KEX */
+#ifdef WITH_PQ_KEX
+
+static int
+init_pq_kex(PQ_KEX_CTX **pq_kex_ctx, const struct kexalg *kexalg);
+
+/*
+ * @brief Initialise the PQ-only key exchange method context if the negotiated
+ * kex is a PQ-only type,
+ *
+ * @return result of intialising PQ-only key exchange method
+ * 0 if negotiated kex is _not_ a PQ-only type
+ */
+static int
+init_pq_kex(PQ_KEX_CTX **pq_kex_ctx, const struct kexalg *kexalg) {
+
+	switch (kexalg->type) {
+#ifdef WITH_OQS
+		case KEX_PQ_OQS:
+			return pq_oqs_init(pq_kex_ctx, kexalg->name);
+#endif /* WITH_OQS */
+		default:
+			return 0;
+	}
+}
+
+#endif /* WITH_PQ_KEX */
+
 char *
 kex_alg_list(char sep)
 {
@@ -661,7 +903,20 @@
 #ifdef OPENSSL_HAS_ECC
 	EC_KEY_free(kex->ec_client_key);
 #endif /* OPENSSL_HAS_ECC */
+/*
+ * Members of the hybrid/pq-only kex structure is freed when the key exchange
+ * finishes (or if an error occurs during key exchange). Therefore,
+ * we do not need to free these here.
+ */
 #endif /* WITH_OPENSSL */
+#ifdef WITH_HYBRID_KEX
+	if (kex->hybrid_kex_ctx != NULL)
+		free(kex->hybrid_kex_ctx);
+#endif /* WITH_HYBRID_KEX */
+#ifdef WITH_PQ_KEX
+	if (kex->pq_kex_ctx != NULL)
+		free(kex->pq_kex_ctx);
+#endif /* WITH_PQ_KEX */
 	for (mode = 0; mode < MODE_MAX; mode++) {
 		kex_free_newkeys(kex->newkeys[mode]);
 		kex->newkeys[mode] = NULL;
@@ -777,6 +1032,7 @@
 choose_kex(struct kex *k, char *client, char *server)
 {
 	const struct kexalg *kexalg;
+	int r = 0;
 
 	k->name = match_list(client, server, NULL);
 
@@ -788,6 +1044,24 @@
 	k->kex_type = kexalg->type;
 	k->hash_alg = kexalg->hash_alg;
 	k->ec_nid = kexalg->ec_nid;
+
+	/*
+	 * Specifically handle the case where the negotiated
+	 * key exchange method is either a hybrid type or a PQ-only type.
+	 * If the negotiated key exchange algorithm is not a
+	 * hybrid kex or a PQ-only key, these functions does nothing.
+	 */
+#ifdef WITH_HYBRID_KEX
+	if ((r = init_hybrid_kex(&k->hybrid_kex_ctx ,kexalg)) != 0) {
+		return r;
+	}
+#endif /* WITH_HYBRID_KEX */
+#ifdef WITH_PQ_KEX
+	if ((r = init_pq_kex(&k->pq_kex_ctx, kexalg)) != 0) {
+			return r;
+	}
+#endif /* WITH_PQ_KEX */
+
 	return 0;
 }
 
--- a/kex.h
+++ b/kex.h
@@ -28,6 +28,10 @@
 
 #include "mac.h"
 
+#include "kexoqs.h"
+#include "kexhy.h"
+#include "kexpq.h"
+
 #ifdef WITH_LEAKMALLOC
 #include "leakmalloc.h"
 #endif
@@ -63,6 +67,148 @@
 #define	KEX_CURVE25519_SHA256		"curve25519-sha256"
 #define	KEX_CURVE25519_SHA256_OLD	"curve25519-sha256@libssh.org"
 
+#if defined(WITH_OQS) && defined(WITH_PQ_KEX)
+
+#define KEX_OQSDEFAULT_SHA384 PQ_OQS_KEX_SUFFIX("oqsdefault-sha384")
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_PQ_KEXS_START
+#define KEX_BIKE1_L1_CPA_SHA384 PQ_OQS_KEX_SUFFIX("bike1-l1-cpa-sha384")
+#define KEX_BIKE1_L3_CPA_SHA384 PQ_OQS_KEX_SUFFIX("bike1-l3-cpa-sha384")
+#define KEX_BIKE1_L1_FO_SHA384 PQ_OQS_KEX_SUFFIX("bike1-l1-fo-sha384")
+#define KEX_BIKE1_L3_FO_SHA384 PQ_OQS_KEX_SUFFIX("bike1-l3-fo-sha384")
+#define KEX_CLASSIC_MCELIECE_348864_SHA384 PQ_OQS_KEX_SUFFIX("classic-mceliece-348864-sha384")
+#define KEX_CLASSIC_MCELIECE_348864F_SHA384 PQ_OQS_KEX_SUFFIX("classic-mceliece-348864f-sha384")
+#define KEX_CLASSIC_MCELIECE_460896_SHA384 PQ_OQS_KEX_SUFFIX("classic-mceliece-460896-sha384")
+#define KEX_CLASSIC_MCELIECE_460896F_SHA384 PQ_OQS_KEX_SUFFIX("classic-mceliece-460896f-sha384")
+#define KEX_CLASSIC_MCELIECE_6688128_SHA384 PQ_OQS_KEX_SUFFIX("classic-mceliece-6688128-sha384")
+#define KEX_CLASSIC_MCELIECE_6688128F_SHA384 PQ_OQS_KEX_SUFFIX("classic-mceliece-6688128f-sha384")
+#define KEX_CLASSIC_MCELIECE_6960119_SHA384 PQ_OQS_KEX_SUFFIX("classic-mceliece-6960119-sha384")
+#define KEX_CLASSIC_MCELIECE_6960119F_SHA384 PQ_OQS_KEX_SUFFIX("classic-mceliece-6960119f-sha384")
+#define KEX_CLASSIC_MCELIECE_8192128_SHA384 PQ_OQS_KEX_SUFFIX("classic-mceliece-8192128-sha384")
+#define KEX_CLASSIC_MCELIECE_8192128F_SHA384 PQ_OQS_KEX_SUFFIX("classic-mceliece-8192128f-sha384")
+#define KEX_FRODO_640_AES_SHA384 PQ_OQS_KEX_SUFFIX("frodo-640-aes-sha384")
+#define KEX_FRODO_640_SHAKE_SHA384 PQ_OQS_KEX_SUFFIX("frodo-640-shake-sha384")
+#define KEX_FRODO_976_AES_SHA384 PQ_OQS_KEX_SUFFIX("frodo-976-aes-sha384")
+#define KEX_FRODO_976_SHAKE_SHA384 PQ_OQS_KEX_SUFFIX("frodo-976-shake-sha384")
+#define KEX_FRODO_1344_AES_SHA384 PQ_OQS_KEX_SUFFIX("frodo-1344-aes-sha384")
+#define KEX_FRODO_1344_SHAKE_SHA384 PQ_OQS_KEX_SUFFIX("frodo-1344-shake-sha384")
+#define KEX_KYBER_512_SHA384 PQ_OQS_KEX_SUFFIX("kyber-512-sha384")
+#define KEX_KYBER_768_SHA384 PQ_OQS_KEX_SUFFIX("kyber-768-sha384")
+#define KEX_KYBER_1024_SHA384 PQ_OQS_KEX_SUFFIX("kyber-1024-sha384")
+#define KEX_KYBER_512_90S_SHA384 PQ_OQS_KEX_SUFFIX("kyber-512-90s-sha384")
+#define KEX_KYBER_768_90S_SHA384 PQ_OQS_KEX_SUFFIX("kyber-768-90s-sha384")
+#define KEX_KYBER_1024_90S_SHA384 PQ_OQS_KEX_SUFFIX("kyber-1024-90s-sha384")
+#define KEX_NEWHOPE_512_SHA384 PQ_OQS_KEX_SUFFIX("newhope-512-sha384")
+#define KEX_NEWHOPE_1024_SHA384 PQ_OQS_KEX_SUFFIX("newhope-1024-sha384")
+#define KEX_NTRU_HPS_2048_509_SHA384 PQ_OQS_KEX_SUFFIX("ntru-hps-2048-509-sha384")
+#define KEX_NTRU_HPS_2048_677_SHA384 PQ_OQS_KEX_SUFFIX("ntru-hps-2048-677-sha384")
+#define KEX_NTRU_HRSS_701_SHA384 PQ_OQS_KEX_SUFFIX("ntru-hrss-701-sha384")
+#define KEX_NTRU_HPS_4096_821_SHA384 PQ_OQS_KEX_SUFFIX("ntru-hps-4096-821-sha384")
+#define KEX_SABER_LIGHTSABER_SHA384 PQ_OQS_KEX_SUFFIX("saber-lightsaber-sha384")
+#define KEX_SABER_SABER_SHA384 PQ_OQS_KEX_SUFFIX("saber-saber-sha384")
+#define KEX_SABER_FIRESABER_SHA384 PQ_OQS_KEX_SUFFIX("saber-firesaber-sha384")
+#define KEX_SIDH_p434_SHA384 PQ_OQS_KEX_SUFFIX("sidh-p434-sha384")
+#define KEX_SIDH_p503_SHA384 PQ_OQS_KEX_SUFFIX("sidh-p503-sha384")
+#define KEX_SIDH_p610_SHA384 PQ_OQS_KEX_SUFFIX("sidh-p610-sha384")
+#define KEX_SIDH_p751_SHA384 PQ_OQS_KEX_SUFFIX("sidh-p751-sha384")
+#define KEX_SIDH_P434_COMPRESSED_SHA384 PQ_OQS_KEX_SUFFIX("sidh-p434-compressed-sha384")
+#define KEX_SIDH_P503_COMPRESSED_SHA384 PQ_OQS_KEX_SUFFIX("sidh-p503-compressed-sha384")
+#define KEX_SIDH_P610_COMPRESSED_SHA384 PQ_OQS_KEX_SUFFIX("sidh-p610-compressed-sha384")
+#define KEX_SIDH_P751_COMPRESSED_SHA384 PQ_OQS_KEX_SUFFIX("sidh-p751-compressed-sha384")
+#define KEX_SIKE_P434_SHA384 PQ_OQS_KEX_SUFFIX("sike-p434-sha384")
+#define KEX_SIKE_P503_SHA384 PQ_OQS_KEX_SUFFIX("sike-p503-sha384")
+#define KEX_SIKE_P610_SHA384 PQ_OQS_KEX_SUFFIX("sike-p610-sha384")
+#define KEX_SIKE_P751_SHA384 PQ_OQS_KEX_SUFFIX("sike-p751-sha384")
+#define KEX__SHA384 PQ_OQS_KEX_SUFFIX("-sha384")
+#define KEX_SIKE_P503_COMPRESSED_SHA384 PQ_OQS_KEX_SUFFIX("sike-p503-compressed-sha384")
+#define KEX_SIKE_P610_COMPRESSED_SHA384 PQ_OQS_KEX_SUFFIX("sike-p610-compressed-sha384")
+#define KEX_SIKE_P751_COMPRESSED_SHA384 PQ_OQS_KEX_SUFFIX("sike-p751-compressed-sha384")
+#define KEX_BABYBEAR_SHA384 PQ_OQS_KEX_SUFFIX("babybear-sha384")
+#define KEX_BABYBEAR_EPHEM_SHA384 PQ_OQS_KEX_SUFFIX("babybear-ephem-sha384")
+#define KEX_MAMABEAR_SHA384 PQ_OQS_KEX_SUFFIX("mamabear-sha384")
+#define KEX_MAMABEAR_EPHEM_SHA384 PQ_OQS_KEX_SUFFIX("mamabear-ephem-sha384")
+#define KEX_PAPABEAR_SHA384 PQ_OQS_KEX_SUFFIX("papabear-sha384")
+#define KEX_PAPABEAR_EPHEM_SHA384 PQ_OQS_KEX_SUFFIX("papabear-ephem-sha384")
+#define KEX_HQC_128_1_CCA2_SHA384 PQ_OQS_KEX_SUFFIX("hqc-128-1-cca2-sha384")
+#define KEX_HQC_192_1_CCA2_SHA384 PQ_OQS_KEX_SUFFIX("hqc-192-1-cca2-sha384")
+#define KEX_HQC_192_2_CCA2_SHA384 PQ_OQS_KEX_SUFFIX("hqc-192-2-cca2-sha384")
+#define KEX_HQC_256_1_CCA2_SHA384 PQ_OQS_KEX_SUFFIX("hqc-256-1-cca2-sha384")
+#define KEX_HQC_256_2_CCA2_SHA384 PQ_OQS_KEX_SUFFIX("hqc-256-2-cca2-sha384")
+#define KEX_HQC_256_3_CCA2_SHA384 PQ_OQS_KEX_SUFFIX("hqc-256-3-cca2-sha384")
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_PQ_KEXS_END
+
+#endif /* defined(WITH_OQS) && defined(WITH_PQ_KEX) */
+
+#if defined(WITH_OQS) && defined(WITH_HYBRID_KEX)
+
+#define KEX_ECDH_NISTP384_OQSDEFAULT_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-oqsdefault-sha384")
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_HYBRID_KEXS_START
+#define KEX_ECDH_NISTP384_BIKE1_L1_CPA_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-bike1-l1-cpa-sha384")
+#define KEX_ECDH_NISTP384_BIKE1_L3_CPA_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-bike1-l3-cpa-sha384")
+#define KEX_ECDH_NISTP384_BIKE1_L1_FO_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-bike1-l1-fo-sha384")
+#define KEX_ECDH_NISTP384_BIKE1_L3_FO_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-bike1-l3-fo-sha384")
+#define KEX_ECDH_NISTP384_CLASSIC_MCELIECE_348864_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-348864-sha384")
+#define KEX_ECDH_NISTP384_CLASSIC_MCELIECE_348864F_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-348864f-sha384")
+#define KEX_ECDH_NISTP384_CLASSIC_MCELIECE_460896_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-460896-sha384")
+#define KEX_ECDH_NISTP384_CLASSIC_MCELIECE_460896F_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-460896f-sha384")
+#define KEX_ECDH_NISTP384_CLASSIC_MCELIECE_6688128_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-6688128-sha384")
+#define KEX_ECDH_NISTP384_CLASSIC_MCELIECE_6688128F_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-6688128f-sha384")
+#define KEX_ECDH_NISTP384_CLASSIC_MCELIECE_6960119_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-6960119-sha384")
+#define KEX_ECDH_NISTP384_CLASSIC_MCELIECE_6960119F_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-6960119f-sha384")
+#define KEX_ECDH_NISTP384_CLASSIC_MCELIECE_8192128_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-8192128-sha384")
+#define KEX_ECDH_NISTP384_CLASSIC_MCELIECE_8192128F_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-8192128f-sha384")
+#define KEX_ECDH_NISTP384_FRODO_640_AES_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-frodo-640-aes-sha384")
+#define KEX_ECDH_NISTP384_FRODO_640_SHAKE_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-frodo-640-shake-sha384")
+#define KEX_ECDH_NISTP384_FRODO_976_AES_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-frodo-976-aes-sha384")
+#define KEX_ECDH_NISTP384_FRODO_976_SHAKE_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-frodo-976-shake-sha384")
+#define KEX_ECDH_NISTP384_FRODO_1344_AES_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-frodo-1344-aes-sha384")
+#define KEX_ECDH_NISTP384_FRODO_1344_SHAKE_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-frodo-1344-shake-sha384")
+#define KEX_ECDH_NISTP384_KYBER_512_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-kyber-512-sha384")
+#define KEX_ECDH_NISTP384_KYBER_768_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-kyber-768-sha384")
+#define KEX_ECDH_NISTP384_KYBER_1024_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-kyber-1024-sha384")
+#define KEX_ECDH_NISTP384_KYBER_512_90S_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-kyber-512-90s-sha384")
+#define KEX_ECDH_NISTP384_KYBER_768_90S_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-kyber-768-90s-sha384")
+#define KEX_ECDH_NISTP384_KYBER_1024_90S_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-kyber-1024-90s-sha384")
+#define KEX_ECDH_NISTP384_NEWHOPE_512_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-newhope-512-sha384")
+#define KEX_ECDH_NISTP384_NEWHOPE_1024_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-newhope-1024-sha384")
+#define KEX_ECDH_NISTP384_NTRU_HPS_2048_509_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-ntru-hps-2048-509-sha384")
+#define KEX_ECDH_NISTP384_NTRU_HPS_2048_677_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-ntru-hps-2048-677-sha384")
+#define KEX_ECDH_NISTP384_NTRU_HRSS_701_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-ntru-hrss-701-sha384")
+#define KEX_ECDH_NISTP384_NTRU_HPS_4096_821_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-ntru-hps-4096-821-sha384")
+#define KEX_ECDH_NISTP384_SABER_LIGHTSABER_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-saber-lightsaber-sha384")
+#define KEX_ECDH_NISTP384_SABER_SABER_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-saber-saber-sha384")
+#define KEX_ECDH_NISTP384_SABER_FIRESABER_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-saber-firesaber-sha384")
+#define KEX_ECDH_NISTP384_SIDH_p434_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p434-sha384")
+#define KEX_ECDH_NISTP384_SIDH_p503_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p503-sha384")
+#define KEX_ECDH_NISTP384_SIDH_p610_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p610-sha384")
+#define KEX_ECDH_NISTP384_SIDH_p751_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p751-sha384")
+#define KEX_ECDH_NISTP384_SIDH_P434_COMPRESSED_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p434-compressed-sha384")
+#define KEX_ECDH_NISTP384_SIDH_P503_COMPRESSED_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p503-compressed-sha384")
+#define KEX_ECDH_NISTP384_SIDH_P610_COMPRESSED_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p610-compressed-sha384")
+#define KEX_ECDH_NISTP384_SIDH_P751_COMPRESSED_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p751-compressed-sha384")
+#define KEX_ECDH_NISTP384_SIKE_P434_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sike-p434-sha384")
+#define KEX_ECDH_NISTP384_SIKE_P503_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sike-p503-sha384")
+#define KEX_ECDH_NISTP384_SIKE_P610_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sike-p610-sha384")
+#define KEX_ECDH_NISTP384_SIKE_P751_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sike-p751-sha384")
+#define KEX_ECDH_NISTP384__SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384--sha384")
+#define KEX_ECDH_NISTP384_SIKE_P503_COMPRESSED_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sike-p503-compressed-sha384")
+#define KEX_ECDH_NISTP384_SIKE_P610_COMPRESSED_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sike-p610-compressed-sha384")
+#define KEX_ECDH_NISTP384_SIKE_P751_COMPRESSED_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sike-p751-compressed-sha384")
+#define KEX_ECDH_NISTP384_BABYBEAR_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-babybear-sha384")
+#define KEX_ECDH_NISTP384_BABYBEAR_EPHEM_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-babybear-ephem-sha384")
+#define KEX_ECDH_NISTP384_MAMABEAR_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-mamabear-sha384")
+#define KEX_ECDH_NISTP384_MAMABEAR_EPHEM_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-mamabear-ephem-sha384")
+#define KEX_ECDH_NISTP384_PAPABEAR_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-papabear-sha384")
+#define KEX_ECDH_NISTP384_PAPABEAR_EPHEM_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-papabear-ephem-sha384")
+#define KEX_ECDH_NISTP384_HQC_128_1_CCA2_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-hqc-128-1-cca2-sha384")
+#define KEX_ECDH_NISTP384_HQC_192_1_CCA2_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-hqc-192-1-cca2-sha384")
+#define KEX_ECDH_NISTP384_HQC_192_2_CCA2_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-hqc-192-2-cca2-sha384")
+#define KEX_ECDH_NISTP384_HQC_256_1_CCA2_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-hqc-256-1-cca2-sha384")
+#define KEX_ECDH_NISTP384_HQC_256_2_CCA2_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-hqc-256-2-cca2-sha384")
+#define KEX_ECDH_NISTP384_HQC_256_3_CCA2_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-hqc-256-3-cca2-sha384")
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_HYBRID_KEXS_END
+
+#endif /* defined(WITH_OQS) && defined(WITH_HYBRID_KEX) */
+
 #define COMP_NONE	0
 /* pre-auth compression (COMP_ZLIB) is only supported in the client */
 #define COMP_ZLIB	1
@@ -100,6 +246,8 @@
 	KEX_DH_GEX_SHA256,
 	KEX_ECDH_SHA2,
 	KEX_C25519_SHA256,
+	KEX_HY_ECDH_OQS,
+	KEX_PQ_OQS,
 	KEX_GSS_GRP1_SHA1,
 	KEX_GSS_GRP14_SHA1,
 	KEX_GSS_GEX_SHA1,
@@ -174,6 +322,12 @@
 	const EC_GROUP *ec_group;	/* ECDH */
 	u_char c25519_client_key[CURVE25519_SIZE]; /* 25519 */
 	u_char c25519_client_pubkey[CURVE25519_SIZE]; /* 25519 */
+#ifdef WITH_HYBRID_KEX
+	HYBRID_KEX_CTX *hybrid_kex_ctx; /* Hybrid key exchange context */
+#endif /* WITH_HYBRID_KEX */
+#ifdef WITH_PQ_KEX
+	PQ_KEX_CTX *pq_kex_ctx;; /* PQ-only key exchange context */
+#endif /* WITH_PQ_KEX */
 };
 
 int	 kex_names_valid(const char *);
--- /dev/null
+++ b/kexhy.h
@@ -0,0 +1,134 @@
+/*
+* Copyright 2018 Amazon.com, Inc. or its affiliates. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef KEX_HYBRID_H
+#define KEX_HYBRID_H
+
+#include "includes.h"
+
+#ifdef WITH_HYBRID_KEX
+
+#include "packet.h"
+#include "kexoqs.h"
+
+/* Hybrid key exchange context */
+typedef struct hybrid_kex_ctx {
+
+	const char *hybrid_kex_name;	/* Named SSH hybrid key exchange method */
+
+#ifdef OPENSSL_HAS_ECC
+	/* ECDH specifics */
+	int ec_nid;	/* Elliptic curve reference */
+	EC_KEY *ecdh_local_key;	/* Local ecdh key */
+	const EC_GROUP *ecdh_group;	/* Elliptic curve group used */
+	const EC_POINT *ecdh_local_public; /* Public ecdh part from local */
+	const EC_POINT *ecdh_remote_public; /* Public ecdh part from remote */
+#endif /* OPENSSL_HAS_ECC */
+
+#ifdef WITH_OQS
+	/* libOQS specifics */
+	OQS_KEX_CTX *oqs_kex_ctx;	/* Liboqs context */
+#endif /* WITH_OQS */
+
+} HYBRID_KEX_CTX;
+
+/*
+ * Header: Special ECDH version needed for hybrid key exchange
+ */
+
+#ifdef OPENSSL_HAS_ECC
+
+/* Public functions */
+void hybrid_ecdh_init(HYBRID_KEX_CTX *hybrid_kex_ctx, int ec_nid);
+void hybrid_ecdh_free(HYBRID_KEX_CTX *hybrid_kex_ctx);
+int hybrid_ecdh_gen(HYBRID_KEX_CTX *hybrid_kex_ctx);
+int hybrid_ecdh_deserialise(struct ssh *ssh, HYBRID_KEX_CTX *hybrid_kex_ctx);
+int hybrid_ecdh_serialise(struct ssh *ssh, HYBRID_KEX_CTX *hybrid_kex_ctx);
+int hybrid_ecdh_shared_secret(HYBRID_KEX_CTX *hybrid_kex_ctx,
+	u_char **ecdh_shared_secret, size_t *ecdh_shared_secret_len);
+
+#endif /* OPENSSL_HAS_ECC */
+
+/*
+ * Headers: Named hybrid key exchange methods
+ */
+
+#if defined(OPENSSL_HAS_ECC) && defined(WITH_OQS)
+
+/* ECDH+liboqs */
+/* Exchange hash */
+int hybrid_ecdh_oqs_hash (
+	int hash_alg,
+	const char *client_version_string,
+	const char *server_version_string,
+	const struct sshbuf *ckexinit,
+	const struct sshbuf *skexinit,
+	const u_char *serverhostkeyblob, size_t serverhostkeyblob_len,
+	const EC_GROUP *ecdh_group,
+	const EC_POINT *ecdh_client_public,
+	const EC_POINT *ecdh_server_public,
+	const uint8_t *oqs_client_public, size_t oqs_client_public_len,
+	const uint8_t *oqs_server_public, size_t oqs_server_public_len,
+	const u_char *shared_secret, size_t shared_secret_len,
+	u_char *hash, size_t *hash_len);
+/* Shared functions */
+int hybrid_ecdh_oqs_init(HYBRID_KEX_CTX **hybrid_kex_ctx,
+	char *hybrid_kex_name, int ec_nid);
+void hybrid_ecdh_oqs_free(HYBRID_KEX_CTX *hybrid_kex_ctx);
+int hybrid_ecdh_oqs_combine_shared_secrets(u_char *ecdh_shared_secret,
+	size_t ecdh_shared_secret_len, u_char *oqs_shared_secret,
+	size_t oqs_shared_secret_len, u_char **combined_shared_secret,
+	size_t *combined_shared_secret_len);
+/* Client specific function */
+int hybrid_ecdh_oqs_client(struct ssh *ssh);
+/* Server specific function */
+int hybrid_ecdh_oqs_server(struct ssh *ssh);
+
+#endif /* defined(OPENSSL_HAS_ECC) && defined(WITH_OQS) */
+#endif /* WITH_HYBRID_KEX */
+
+/* Helper functions to register hybrid key exchange call-backs */
+typedef int (*hybrid_func_cb)(struct ssh *);
+
+static inline hybrid_func_cb
+get_hybrid_ecdh_oqs_client_cb() {
+
+#if defined(OPENSSL_HAS_ECC) && defined(WITH_OQS) && defined(WITH_HYBRID_KEX)
+    return hybrid_ecdh_oqs_client;
+#else
+    return NULL;
+#endif
+}
+
+static inline hybrid_func_cb
+get_hybrid_ecdh_oqs_server_cb() {
+
+#if defined(OPENSSL_HAS_ECC) && defined(WITH_OQS) && defined(WITH_HYBRID_KEX)
+    return hybrid_ecdh_oqs_server;
+#else
+    return NULL;
+#endif
+}
+
+#endif /* KEX_HYBRID_H */
--- /dev/null
+++ b/kexhyecdh.c
@@ -0,0 +1,199 @@
+/*
+* Copyright 2018 Amazon.com, Inc. or its affiliates. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "includes.h"
+
+#if defined(OPENSSL_HAS_ECC) && defined(WITH_HYBRID_KEX)
+
+#include <openssl/ecdh.h>
+#include <signal.h>
+
+#include "sshkey.h"
+#include "ssherr.h"
+#include "packet.h"
+#include "kexhy.h"
+
+/*
+ * @brief Initialise hybrid key exchange ecdh specific context
+ */
+void
+hybrid_ecdh_init(HYBRID_KEX_CTX *hybrid_kex_ctx, int ec_nid) {
+
+	hybrid_kex_ctx->ec_nid = ec_nid;
+	hybrid_kex_ctx->ecdh_local_key = NULL;
+	hybrid_kex_ctx->ecdh_group = NULL;
+	hybrid_kex_ctx->ecdh_local_public = NULL;
+	hybrid_kex_ctx->ecdh_remote_public = NULL;
+}
+
+/*
+ * @brief Free memory allocated for ecdh part of hybrid key exchange
+ */
+void
+hybrid_ecdh_free(HYBRID_KEX_CTX *hybrid_kex_ctx) {
+
+	/*
+	 * EC_KEY_free() makes sure to also free the public part of the key.
+	 * We don't have the private key for the remote, so we must explicitly
+	 * free it.
+	 */
+	if (hybrid_kex_ctx->ecdh_local_key != NULL) {
+		EC_KEY_free(hybrid_kex_ctx->ecdh_local_key);
+		hybrid_kex_ctx->ecdh_local_key = NULL;
+	}
+	if (hybrid_kex_ctx->ecdh_local_public != NULL) {
+		EC_POINT_clear_free((EC_POINT *) hybrid_kex_ctx->ecdh_remote_public);
+		hybrid_kex_ctx->ecdh_remote_public = NULL;
+	}
+}
+
+/*
+ * @brief Computes the ECDH public and private key.
+ */
+int
+hybrid_ecdh_gen(HYBRID_KEX_CTX *hybrid_kex_ctx) {
+
+	EC_KEY *key = NULL;
+	int r = 0;
+
+	if ((key = EC_KEY_new_by_curve_name(hybrid_kex_ctx->ec_nid)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+
+	if (EC_KEY_generate_key(key) != 1) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+
+	hybrid_kex_ctx->ecdh_group = EC_KEY_get0_group(key);
+	hybrid_kex_ctx->ecdh_local_public = EC_KEY_get0_public_key(key);
+	hybrid_kex_ctx->ecdh_local_key = key;
+
+	key = NULL;
+
+out:
+	if (key != NULL) {
+		EC_KEY_free(key);
+	}
+
+	return r;
+}
+
+/*
+ * @brief Deserialise the ECDH part of a hybrid key exchange packet from server
+ */
+int
+hybrid_ecdh_deserialise(struct ssh *ssh, HYBRID_KEX_CTX *hybrid_kex_ctx) {
+
+	EC_POINT *public_point = NULL;
+	int r = 0;
+
+	if ((public_point = EC_POINT_new(hybrid_kex_ctx->ecdh_group)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+
+	if ((r = sshpkt_get_ec(ssh, public_point, hybrid_kex_ctx->ecdh_group)) != 0)
+		goto out;
+
+	/* Very important to verify public key! */
+	if (sshkey_ec_validate_public(hybrid_kex_ctx->ecdh_group, (const EC_POINT *) public_point) != 0) {
+		sshpkt_disconnect(ssh, "Invalid server ECDH public key");
+		r = SSH_ERR_MESSAGE_INCOMPLETE;
+		goto out;
+	}
+
+	hybrid_kex_ctx->ecdh_remote_public = (const EC_POINT *) public_point;
+
+	public_point = NULL;
+
+out:
+	if (public_point != NULL) {
+		EC_POINT_clear_free(public_point);
+	}
+
+	return r;
+}
+
+/*
+ * @brief Serialise the ECDH part of a hybrid key exchange packet from server
+ */
+int
+hybrid_ecdh_serialise(struct ssh *ssh, HYBRID_KEX_CTX *hybrid_kex_ctx) {
+
+	return sshpkt_put_ec(ssh, hybrid_kex_ctx->ecdh_local_public,
+		hybrid_kex_ctx->ecdh_group);
+}
+
+/*
+ * @brief Computes the ECDH shared secret
+ */
+int
+hybrid_ecdh_shared_secret(HYBRID_KEX_CTX *hybrid_kex_ctx, u_char **ecdh_shared_secret,
+	size_t *ecdh_shared_secret_len) {
+
+	EC_KEY *key = NULL;
+	const EC_POINT *public_point = NULL;
+	u_char *buf_ecdh_shared_secret = NULL;
+	size_t buf_ecdh_shared_secret_len = 0;
+	int r = 0;
+
+	/* Round up to nearest multiple of 8 */
+	buf_ecdh_shared_secret_len = (EC_GROUP_get_degree(hybrid_kex_ctx->ecdh_group) + 7) / 8;
+	if ((buf_ecdh_shared_secret = calloc(sizeof(*buf_ecdh_shared_secret),
+		buf_ecdh_shared_secret_len)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+
+	public_point = hybrid_kex_ctx->ecdh_remote_public;
+	key = hybrid_kex_ctx->ecdh_local_key;
+
+	if (ECDH_compute_key(buf_ecdh_shared_secret, buf_ecdh_shared_secret_len, public_point,
+		key, NULL) != (int) buf_ecdh_shared_secret_len) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+
+	*ecdh_shared_secret = buf_ecdh_shared_secret;
+	*ecdh_shared_secret_len = buf_ecdh_shared_secret_len;
+
+	buf_ecdh_shared_secret = NULL;
+
+out:
+	/* Memory free'd by caller in case of fail */
+	key = NULL;
+	/* Memory free'd by caller in case of fail */
+	public_point = NULL;
+
+	if (buf_ecdh_shared_secret != NULL) {
+		explicit_bzero(buf_ecdh_shared_secret, buf_ecdh_shared_secret_len);
+		free(buf_ecdh_shared_secret);
+	}
+
+	return r;
+}
+
+#endif /* defined(OPENSSL_HAS_ECC) && defined(WITH_HYBRID_KEX) */
--- /dev/null
+++ b/kexhyecdhoqs.c
@@ -0,0 +1,228 @@
+/*
+* Copyright 2018 Amazon.com, Inc. or its affiliates. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "includes.h"
+
+#if defined(OPENSSL_HAS_ECC) && defined(WITH_OQS) && defined(WITH_HYBRID_KEX)
+
+#include <string.h>
+
+#include "ssherr.h"
+#include "digest.h"
+#include "ssh2.h"
+#include "kexhy.h"
+#include "sshbuf.h"
+
+/*
+ * @brief Initialise values of hybrid key exchange context
+ *
+ */
+int
+hybrid_ecdh_oqs_init(HYBRID_KEX_CTX **hybrid_kex_ctx, char *hybrid_kex_name,
+	int ec_nid) {
+
+	HYBRID_KEX_CTX *buf_hybrid_kex_ctx = NULL;
+	OQS_KEX_CTX *buf_oqs_kex_ctx = NULL;
+	int alloc_hybrid_kex_ctx = 1; /* (0) reuse hybrid struct (1) allocated hybrid struct */
+	int r = 0;
+
+	/*
+	 * If rekeying is performed we don't want to allocate again.
+	 * Memory pointed to by *hybrid_kex_ctx is not free'ed before
+	 * the program terminates.
+	 */
+	if (*hybrid_kex_ctx != NULL) {
+		alloc_hybrid_kex_ctx = 0;
+		buf_hybrid_kex_ctx = *hybrid_kex_ctx;
+	}
+
+	if (alloc_hybrid_kex_ctx == 1) {
+		if ((buf_hybrid_kex_ctx = calloc(sizeof(*(buf_hybrid_kex_ctx)), 1)) == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+	}
+
+	buf_hybrid_kex_ctx->hybrid_kex_name = hybrid_kex_name;
+	buf_hybrid_kex_ctx->oqs_kex_ctx = NULL;
+
+	hybrid_ecdh_init(buf_hybrid_kex_ctx, ec_nid);
+	if ((r = oqs_init(&buf_oqs_kex_ctx, hybrid_kex_name)) != 0)
+		goto out;
+
+	buf_hybrid_kex_ctx->oqs_kex_ctx = buf_oqs_kex_ctx;
+	buf_oqs_kex_ctx = NULL;
+	*hybrid_kex_ctx = buf_hybrid_kex_ctx;
+	buf_hybrid_kex_ctx = NULL;
+
+out:
+	if (buf_hybrid_kex_ctx != NULL) {
+		hybrid_ecdh_free(buf_hybrid_kex_ctx);
+		if (buf_hybrid_kex_ctx->oqs_kex_ctx != NULL)
+			oqs_free(buf_hybrid_kex_ctx->oqs_kex_ctx);
+		/*
+		 * If reusing, buf_pq_kex_ctx will point to the
+		 * reused memory and this wil eventually be freed
+		 * by kex_free()
+		 */
+		if (alloc_hybrid_kex_ctx == 1)
+			free(buf_hybrid_kex_ctx);
+	}
+	if (buf_oqs_kex_ctx != NULL)
+		oqs_free(buf_oqs_kex_ctx);
+
+	return r;
+}
+
+
+/*
+ * @brief Free memory allocated hybrid key exchange ecdh+liboqs
+ */
+void
+hybrid_ecdh_oqs_free(HYBRID_KEX_CTX *hybrid_kex_ctx) {
+
+	if (hybrid_kex_ctx != NULL) {
+		hybrid_ecdh_free(hybrid_kex_ctx);
+	}
+	if (hybrid_kex_ctx->oqs_kex_ctx != NULL) {
+		oqs_free(hybrid_kex_ctx->oqs_kex_ctx);
+		free(hybrid_kex_ctx->oqs_kex_ctx);
+		hybrid_kex_ctx->oqs_kex_ctx = NULL;
+	}
+}
+
+/*
+ * @brief Combines the shared secret from ecdh and oqs key exchanges into
+ * one shared secret
+ */
+int
+hybrid_ecdh_oqs_combine_shared_secrets(u_char *ecdh_shared_secret,
+	size_t ecdh_shared_secret_len, u_char *oqs_shared_secret,
+	size_t oqs_shared_secret_len, u_char **combined_shared_secret,
+	size_t *combined_shared_secret_len) {
+
+	u_char *buf_combined_shared_secret = NULL;
+	size_t buf_combined_shared_secret_len = 0;
+
+	int r = 0;
+
+	buf_combined_shared_secret_len = ecdh_shared_secret_len + oqs_shared_secret_len;
+
+	/* Verify that we did not overflow */
+	if (buf_combined_shared_secret_len < ecdh_shared_secret_len) {
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	if ((buf_combined_shared_secret = calloc(sizeof(*buf_combined_shared_secret),
+		buf_combined_shared_secret_len)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	memcpy(buf_combined_shared_secret, ecdh_shared_secret, ecdh_shared_secret_len);
+	memcpy(buf_combined_shared_secret + ecdh_shared_secret_len, oqs_shared_secret,
+		oqs_shared_secret_len);
+
+	*combined_shared_secret = buf_combined_shared_secret;
+	*combined_shared_secret_len = buf_combined_shared_secret_len;
+
+	buf_combined_shared_secret = NULL;
+
+out:
+	if (buf_combined_shared_secret != NULL) {
+		explicit_bzero(buf_combined_shared_secret,
+			buf_combined_shared_secret_len);
+		free(buf_combined_shared_secret);
+		buf_combined_shared_secret = NULL;
+	}
+
+	return r;
+}
+
+/*
+ * @brief Computes the exchange hash for ecdh+liboqs key exchange methods
+ */
+int
+hybrid_ecdh_oqs_hash (
+	int hash_alg,
+	const char *client_version_string,
+	const char *server_version_string,
+	const struct sshbuf *ckexinit,
+	const struct sshbuf *skexinit,
+	const u_char *serverhostkeyblob, size_t serverhostkeyblob_len,
+	const EC_GROUP *ecdh_group,
+	const EC_POINT *ecdh_client_public,
+	const EC_POINT *ecdh_server_public,
+	const uint8_t *oqs_client_public, size_t oqs_client_public_len,
+	const uint8_t *oqs_server_public, size_t oqs_server_public_len,
+	const u_char *shared_secret, size_t shared_secret_len,
+	u_char *hash, size_t *hash_len) {
+
+	struct sshbuf *hash_buf = NULL;
+	int r = 0;
+
+	if (*hash_len < ssh_digest_bytes(hash_alg)) {
+		r = SSH_ERR_INVALID_ARGUMENT;
+		goto out;
+	}
+	if ((hash_buf = sshbuf_new()) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	/* We assume that sshbuf_put_*() correctly handles NULL parameters */
+	if ((r = sshbuf_put_cstring(hash_buf, client_version_string)) != 0 ||
+	    (r = sshbuf_put_cstring(hash_buf, server_version_string)) != 0 ||
+	    /* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */
+	    (r = sshbuf_put_u32(hash_buf, sshbuf_len(ckexinit)+1)) != 0 ||
+	    (r = sshbuf_put_u8(hash_buf, SSH2_MSG_KEXINIT)) != 0 ||
+	    (r = sshbuf_putb(hash_buf, ckexinit)) != 0 ||
+	    (r = sshbuf_put_u32(hash_buf, sshbuf_len(skexinit)+1)) != 0 ||
+	    (r = sshbuf_put_u8(hash_buf, SSH2_MSG_KEXINIT)) != 0 ||
+	    (r = sshbuf_putb(hash_buf, skexinit)) != 0 ||
+	    (r = sshbuf_put_string(hash_buf, serverhostkeyblob, serverhostkeyblob_len)) != 0 ||
+	    (r = sshbuf_put_ec(hash_buf, ecdh_client_public, ecdh_group)) != 0)
+		goto out;
+	if ((r = sshbuf_put_string(hash_buf, oqs_client_public,
+		oqs_client_public_len)) != 0 ||
+	    (r = sshbuf_put_ec(hash_buf, ecdh_server_public, ecdh_group)) != 0 ||
+	    (r = sshbuf_put_string(hash_buf, oqs_server_public,
+	    oqs_server_public_len)) != 0 ||
+	    (r = sshbuf_put_string(hash_buf, shared_secret, shared_secret_len)) != 0)
+		goto out;
+
+	if (ssh_digest_buffer(hash_alg, hash_buf, hash, *hash_len) != 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+
+	*hash_len = ssh_digest_bytes(hash_alg);
+
+out:
+	if (hash_buf != NULL)
+		sshbuf_free(hash_buf);
+
+	return r;
+}
+
+#endif /* defined(OPENSSL_HAS_ECC) && defined(WITH_OQS) && defined(WITH_HYBRID_KEX) */
--- /dev/null
+++ b/kexhyecdhoqsc.c
@@ -0,0 +1,372 @@
+/*
+* Copyright 2018 Amazon.com, Inc. or its affiliates. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "includes.h"
+
+#if defined(OPENSSL_HAS_ECC) && defined(WITH_OQS) && defined(WITH_HYBRID_KEX)
+
+#include <openssl/ecdh.h>
+#include <signal.h>
+#include <string.h>
+
+#include "sshkey.h"
+#include "digest.h"
+#include "ssherr.h"
+#include "kex.h"
+#include "ssh2.h"
+#include "dispatch.h"
+#include "packet.h"
+#include "sshbuf.h"
+#include "log.h"
+
+/* Client private */
+static int
+input_hybrid_ecdh_oqs_reply(int type, u_int32_t seq, struct ssh *ssh);
+static int
+hybrid_ecdh_oqs_s2c_deserialise(struct ssh *ssh, HYBRID_KEX_CTX *hybrid_kex_ctx,
+	struct sshkey **server_host_key, u_char **server_host_key_blob,
+	size_t *server_host_key_blob_len, u_char **signature, size_t *signature_len);
+static int
+hybrid_ecdh_oqs_c2s_serialise(struct ssh *ssh, HYBRID_KEX_CTX *hybrid_kex_ctx);
+static int
+hybrid_ecdh_oqs_verify_hostkey(struct ssh *ssh,
+	struct sshkey *server_host_key);
+static int
+hybrid_ecdh_oqs_deserialise_hostkey(struct ssh *ssh, struct sshkey **server_host_key,
+	u_char **server_host_key_blob, size_t *server_host_key_blob_len);
+
+/*
+ * @brief Logic that handles packet deserialisation of the kex packet from server
+ * to client when using a ecdh+liboqs key exchange method
+ */
+static int
+hybrid_ecdh_oqs_s2c_deserialise(struct ssh *ssh, HYBRID_KEX_CTX *hybrid_kex_ctx,
+	struct sshkey **server_host_key, u_char **server_host_key_blob,
+	size_t *server_host_key_blob_len, u_char **signature, size_t *signature_len) {
+
+	int r = 0;
+
+	/*
+	 * hybrid_ecdh_oqs_server_hostkey() immediately verify
+	 * the host key after extracting it
+	 */
+	if ((r = hybrid_ecdh_oqs_deserialise_hostkey(ssh, server_host_key,
+		server_host_key_blob, server_host_key_blob_len)) != 0 ||
+		(r = hybrid_ecdh_deserialise(ssh, hybrid_kex_ctx) != 0) ||
+		(r = oqs_deserialise(ssh, hybrid_kex_ctx->oqs_kex_ctx, OQS_IS_CLIENT) != 0) ||
+		(r = sshpkt_get_string(ssh, signature, signature_len)) != 0)
+		goto out;
+
+	r = sshpkt_get_end(ssh);
+
+	out:
+		return r;
+}
+
+/*
+ * @brief Logic that handles packet serialisation of the kex packet to client
+ * from server when using a ecdh+liboqs key exchange method
+ */
+static int
+hybrid_ecdh_oqs_c2s_serialise(struct ssh *ssh, HYBRID_KEX_CTX *hybrid_kex_ctx) {
+
+	int r = 0;
+
+	if ((r = hybrid_ecdh_serialise(ssh, hybrid_kex_ctx)) == 0)
+		r = oqs_serialise(ssh, hybrid_kex_ctx->oqs_kex_ctx, OQS_IS_CLIENT);
+
+	return r;
+}
+
+/*
+ * @brief Verifies host key
+ */
+static int
+hybrid_ecdh_oqs_verify_hostkey(struct ssh *ssh,
+	struct sshkey *server_host_key) {
+
+	struct kex *kex = NULL;
+	int r = 0;
+
+	kex = ssh->kex;
+
+	/* If we can't verify the host key then abort */
+	if (kex->verify_host_key == NULL) {
+		r = SSH_ERR_INVALID_ARGUMENT;
+		goto out;
+	}
+
+	if (server_host_key->type != kex->hostkey_type ||
+	    (kex->hostkey_type == KEY_ECDSA &&
+	    server_host_key->ecdsa_nid != kex->hostkey_nid)) {
+		r = SSH_ERR_KEY_TYPE_MISMATCH;
+		goto out;
+	}
+
+	/* Verify host key */
+	if (kex->verify_host_key(server_host_key, ssh) == -1) {
+		r = SSH_ERR_SIGNATURE_INVALID;
+		goto out;
+	}
+
+out:
+	return r;
+}
+
+/*
+ * @brief Extracts host key from incoming packet and
+ * verifies it
+ */
+static int
+hybrid_ecdh_oqs_deserialise_hostkey(struct ssh *ssh,
+	struct sshkey **server_host_key, u_char **server_host_key_blob,
+	size_t *server_host_key_blob_len) {
+
+	struct sshkey *tmp_server_host_key = NULL;
+	u_char *tmp_server_host_key_blob = NULL;
+	size_t tmp_server_host_key_blob_len = 0;
+	int r = 0;
+
+	/* Extract host key from packet */
+	if ((r = sshpkt_get_string(ssh, &tmp_server_host_key_blob,
+		&tmp_server_host_key_blob_len)) != 0 ||
+		(r = sshkey_from_blob(tmp_server_host_key_blob,
+		tmp_server_host_key_blob_len, &tmp_server_host_key)) != 0)
+		goto out;
+
+	/* Immediately verify host key */
+	if ((r = hybrid_ecdh_oqs_verify_hostkey(ssh,
+		tmp_server_host_key)) != 0)
+		goto out;
+
+	*server_host_key = tmp_server_host_key;
+	*server_host_key_blob = tmp_server_host_key_blob;
+	*server_host_key_blob_len = tmp_server_host_key_blob_len;
+
+	tmp_server_host_key = NULL;
+	tmp_server_host_key_blob = NULL;
+
+out:
+	if (tmp_server_host_key_blob != NULL)
+		free(tmp_server_host_key_blob);
+	if (tmp_server_host_key != NULL)
+		sshkey_free(tmp_server_host_key);
+
+	return r;
+}
+
+/*
+ * @brief Handles the first client ecdh+liboqs key exchange message
+ */
+int
+hybrid_ecdh_oqs_client(struct ssh *ssh) {
+
+	HYBRID_KEX_CTX *hybrid_kex_ctx = NULL;
+	OQS_KEX_CTX *oqs_kex_ctx = NULL;
+	const OQS_ALG *oqs_alg = NULL;
+	int r = 0;
+
+	/* Test whether we are prepared to handle this packet */
+	if (ssh == NULL ||
+		ssh->kex == NULL ||
+		(hybrid_kex_ctx = ssh->kex->hybrid_kex_ctx) == NULL ||
+		(oqs_kex_ctx = hybrid_kex_ctx->oqs_kex_ctx) == NULL) {
+
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	if ((oqs_alg = oqs_mapping(hybrid_kex_ctx->hybrid_kex_name)) == NULL) {
+		error("Unsupported libOQS algorithm \"%.100s\"", hybrid_kex_ctx->hybrid_kex_name);
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	/* Generate ecdh public key */
+	if ((r = hybrid_ecdh_gen(hybrid_kex_ctx)) != 0)
+		goto out;
+
+	/* Generate oqs public key */
+	if ((r = oqs_client_gen(oqs_kex_ctx)) != 0)
+		goto out;
+
+	/* Send client hybrid ecdh+liboqs packet to server */
+	if ((r = sshpkt_start(ssh, oqs_ssh2_init_msg(oqs_alg))) != 0 ||
+		(r = hybrid_ecdh_oqs_c2s_serialise(ssh, hybrid_kex_ctx)) != 0 ||
+	    (r = sshpkt_send(ssh)) != 0)
+		goto out;
+
+	/* Set handler for recieving server reply */
+	debug("expecting %i msg", oqs_ssh2_reply_msg(oqs_alg));
+	ssh_dispatch_set(ssh, oqs_ssh2_reply_msg(oqs_alg),
+		&input_hybrid_ecdh_oqs_reply);
+
+out:
+	if (r != 0) {
+		hybrid_ecdh_free(hybrid_kex_ctx);
+		oqs_free(oqs_kex_ctx);
+	}
+
+	return r;
+}
+
+/*
+ * @brief Handles the ecdh+liboqs key exchange reply from server
+ */
+static int
+input_hybrid_ecdh_oqs_reply(int type, u_int32_t seq, struct ssh *ssh) {
+
+	HYBRID_KEX_CTX *hybrid_kex_ctx = NULL;
+	OQS_KEX_CTX *oqs_kex_ctx = NULL;
+	struct sshkey *server_host_key = NULL;
+	struct sshbuf *shared_secret_ssh_buf = NULL;
+	struct kex *kex = NULL;
+	u_char *server_host_key_blob = NULL;
+	u_char *signature = NULL;
+	u_char hash[SSH_DIGEST_MAX_LENGTH];
+	u_char *ecdh_shared_secret = NULL;
+	u_char *oqs_shared_secret = NULL;
+	u_char *shared_secret = NULL;
+	size_t ecdh_shared_secret_len = 0;
+	size_t oqs_shared_secret_len = 0;
+	size_t shared_secret_len = 0;
+	size_t signature_len = 0;
+	size_t server_host_key_blob_len = 0;
+	size_t hash_len = 0;
+	int r = 0;
+
+	/* Test whether we are prepared to handle this packet */
+	if (ssh == NULL ||
+		(kex = ssh->kex) == NULL ||
+		(hybrid_kex_ctx = kex->hybrid_kex_ctx) == NULL ||
+		(oqs_kex_ctx = hybrid_kex_ctx->oqs_kex_ctx) == NULL) {
+
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	/* Extract from server to client packet */
+	if ((r = hybrid_ecdh_oqs_s2c_deserialise(ssh, hybrid_kex_ctx,
+		&server_host_key, &server_host_key_blob,
+		&server_host_key_blob_len, &signature, &signature_len)) != 0)
+		goto out;
+
+	/*
+	 * Compute shared secret for each key exchange scheme part of the
+	 * hybrid key exchange method
+	 */
+	if ((r = hybrid_ecdh_shared_secret(hybrid_kex_ctx, &ecdh_shared_secret,
+		&ecdh_shared_secret_len)) != 0)
+		goto out;
+	if ((r = oqs_client_shared_secret(oqs_kex_ctx, &oqs_shared_secret,
+		&oqs_shared_secret_len)) != 0)
+		goto out;
+
+	if ((r = hybrid_ecdh_oqs_combine_shared_secrets(ecdh_shared_secret,
+		ecdh_shared_secret_len, oqs_shared_secret, oqs_shared_secret_len,
+		&shared_secret, &shared_secret_len)) != 0)
+		goto out;
+
+	/*
+	 * Compute exchange hash
+	 * kex->my is client
+	 * kex->peer is server
+	 */
+	hash_len = sizeof(hash);
+	if ((r = hybrid_ecdh_oqs_hash(
+		kex->hash_alg,
+		kex->client_version_string,
+		kex->server_version_string,
+		kex->my,
+		kex->peer,
+		server_host_key_blob, server_host_key_blob_len,
+		hybrid_kex_ctx->ecdh_group,
+		hybrid_kex_ctx->ecdh_local_public,
+		hybrid_kex_ctx->ecdh_remote_public,
+		oqs_kex_ctx->oqs_local_msg, oqs_kex_ctx->oqs_local_msg_len,
+		oqs_kex_ctx->oqs_remote_msg, oqs_kex_ctx->oqs_remote_msg_len,
+		shared_secret, shared_secret_len,
+		hash, &hash_len)) != 0)
+		goto out;
+
+	/* Verify signature over exchange hash */
+	if ((r = sshkey_verify(server_host_key, signature, signature_len, hash,
+		hash_len, kex->hostkey_alg, ssh->compat))!= 0)
+		goto out;
+
+	/* Save session id */
+	if (kex->session_id == NULL) {
+		kex->session_id_len = hash_len;
+		kex->session_id = malloc(kex->session_id_len);
+		if (kex->session_id == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		memcpy(kex->session_id, hash, kex->session_id_len);
+	}
+
+	/*
+	 * sshbuf_put_string() will encode the shared secret as a mpint
+	 * as required by SSH spec (RFC4253)
+	 */
+	if ((shared_secret_ssh_buf = sshbuf_new()) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if ((r = sshbuf_put_string(shared_secret_ssh_buf, (const u_char *) shared_secret,
+		shared_secret_len)) != 0)
+		goto out;
+
+	if ((r = kex_derive_keys(ssh, hash, hash_len, shared_secret_ssh_buf)) == 0)
+		r = kex_send_newkeys(ssh);
+
+out:
+	explicit_bzero(hash, sizeof(hash));
+	hybrid_ecdh_oqs_free(hybrid_kex_ctx);
+	/* sshbuf_free zeroises memory */
+	if (shared_secret_ssh_buf != NULL)
+		sshbuf_free(shared_secret_ssh_buf);
+	if (server_host_key != NULL)
+		sshkey_free(server_host_key);
+	if (shared_secret != NULL) {
+		explicit_bzero(shared_secret, shared_secret_len);
+		free(shared_secret);
+	}
+	if (ecdh_shared_secret != NULL) {
+		explicit_bzero(ecdh_shared_secret, ecdh_shared_secret_len);
+		free(ecdh_shared_secret);
+	}
+	if (oqs_shared_secret != NULL) {
+		explicit_bzero(oqs_shared_secret, oqs_shared_secret_len);
+		free(oqs_shared_secret);
+	}
+	if (server_host_key_blob != NULL)
+		free(server_host_key_blob);
+	if (signature != NULL)
+		free(signature);
+
+	return r;
+}
+
+#endif /* defined(OPENSSL_HAS_ECC) && defined(WITH_OQS) && defined(WITH_HYBRID_KEX) */
--- /dev/null
+++ b/kexhyecdhoqss.c
@@ -0,0 +1,353 @@
+/*
+* Copyright 2018 Amazon.com, Inc. or its affiliates. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "includes.h"
+
+#if defined(OPENSSL_HAS_ECC) && defined(WITH_OQS) && defined(WITH_HYBRID_KEX)
+
+#include <openssl/ecdh.h>
+#include <signal.h>
+#include <string.h>
+
+#include "sshkey.h"
+#include "digest.h"
+#include "ssherr.h"
+#include "kex.h"
+#include "ssh2.h"
+#include "dispatch.h"
+#include "packet.h"
+#include "sshbuf.h"
+#include "log.h"
+
+/* Server private */
+static int
+hybrid_ecdh_oqs_c2s_deserialise(struct ssh *ssh, HYBRID_KEX_CTX *hybrid_kex_ctx);
+static int
+hybrid_ecdh_oqs_s2c_serialise(struct ssh *ssh, HYBRID_KEX_CTX *hybrid_kex_ctx,
+	u_char *server_host_key_blob, size_t server_host_key_blob_len,
+	u_char *signature, size_t signature_len);
+static int
+hybrid_ecdh_oqs_server_hostkey(struct ssh *ssh, struct sshkey **server_host_public,
+	struct sshkey **server_host_private, u_char **server_host_key_blob,
+	size_t *server_host_key_blob_len);
+static int
+input_hybrid_ecdh_oqs_init(int type, u_int32_t seq, struct ssh *ssh);
+
+/*
+ * @brief Logic that handles packet deserialisation of the client kex message
+ * when using a ecdh+liboqs kex
+ */
+static int
+hybrid_ecdh_oqs_c2s_deserialise(struct ssh *ssh,
+	HYBRID_KEX_CTX *hybrid_kex_ctx) {
+
+	int r = 0;
+
+	if ((r = hybrid_ecdh_deserialise(ssh, hybrid_kex_ctx) != 0) ||
+		(r = oqs_deserialise(ssh, hybrid_kex_ctx->oqs_kex_ctx, OQS_IS_SERVER) != 0))
+		goto out;
+
+	r = sshpkt_get_end(ssh);
+
+out:
+	return r;
+}
+
+/*
+ * @brief Logic that handles packet serialisation of the client kex message
+ * when using a ecdh+liboqs kex
+ */
+static int
+hybrid_ecdh_oqs_s2c_serialise(struct ssh *ssh,
+	HYBRID_KEX_CTX *hybrid_kex_ctx, u_char *server_host_key_blob,
+	size_t server_host_key_blob_len, u_char *signature,
+	size_t signature_len) {
+
+	int r = 0;
+
+	if ((r = sshpkt_put_string(ssh, server_host_key_blob,
+			server_host_key_blob_len)) != 0 ||
+		(r = hybrid_ecdh_serialise(ssh, hybrid_kex_ctx)) != 0 ||
+		(r = oqs_serialise(ssh, hybrid_kex_ctx->oqs_kex_ctx, OQS_IS_SERVER)) != 0)
+		goto out;
+
+	r = sshpkt_put_string(ssh, signature, signature_len);
+
+out:
+	return r;
+}
+
+/*
+ * @brief Retrieves host key
+ */
+static int
+hybrid_ecdh_oqs_server_hostkey(struct ssh *ssh, struct sshkey **server_host_public,
+	struct sshkey **server_host_private, u_char **server_host_key_blob,
+	size_t *server_host_key_blob_len) {
+
+	struct kex *kex = NULL;
+	struct sshkey *tmp_server_host_public = NULL;
+	struct sshkey *tmp_server_host_private = NULL;
+	u_char *tmp_server_host_key_blob = NULL;
+	size_t tmp_server_host_key_blob_len = 0;
+	int r = 0;
+
+	kex = ssh->kex;
+
+	/* Retrieve host public and private key */
+	if (kex->load_host_public_key == NULL ||
+	    kex->load_host_private_key == NULL) {
+		r = SSH_ERR_INVALID_ARGUMENT;
+		goto out;
+	}
+	if (((tmp_server_host_public = kex->load_host_public_key(kex->hostkey_type,
+	    kex->hostkey_nid, ssh)) == NULL) ||
+	    (tmp_server_host_private = kex->load_host_private_key(kex->hostkey_type,
+	    kex->hostkey_nid, ssh)) == NULL) {
+		r = SSH_ERR_NO_HOSTKEY_LOADED;
+		goto out;
+	}
+
+	/* Write to blob to prepare transfer over the wire */
+	if ((r = sshkey_to_blob(tmp_server_host_public, &tmp_server_host_key_blob,
+	    &tmp_server_host_key_blob_len)) != 0)
+		goto out;
+
+	*server_host_public = tmp_server_host_public;
+	*server_host_private = tmp_server_host_private;
+	*server_host_key_blob = tmp_server_host_key_blob;
+	*server_host_key_blob_len = tmp_server_host_key_blob_len;
+
+	tmp_server_host_public = NULL;
+	tmp_server_host_private = NULL;
+	tmp_server_host_key_blob = NULL;
+
+out:
+	return r;
+}
+
+/*
+ * @brief Initialise server to retrieve ecdh+liboqs kex client side message
+ */
+int
+hybrid_ecdh_oqs_server(struct ssh *ssh) {
+
+	HYBRID_KEX_CTX *hybrid_kex_ctx = NULL;
+	const OQS_ALG *oqs_alg = NULL;
+	int r = 0;
+
+	/* Test whether we are prepared to handle this packet */
+	if (ssh == NULL ||
+		ssh->kex == NULL ||
+		(hybrid_kex_ctx = ssh->kex->hybrid_kex_ctx) == NULL) {
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	if ((oqs_alg = oqs_mapping(hybrid_kex_ctx->hybrid_kex_name)) == NULL) {
+		error("Unsupported libOQS algorithm \"%.100s\"", hybrid_kex_ctx->hybrid_kex_name);
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	debug("expecting %i msg", oqs_ssh2_init_msg(oqs_alg));
+	ssh_dispatch_set(ssh, oqs_ssh2_init_msg(oqs_alg),
+		&input_hybrid_ecdh_oqs_init);
+
+out:
+	return r;
+}
+
+/*
+ * @brief Handles the client key exchange message when using a ecdh+liboqs kex
+ */
+static int
+input_hybrid_ecdh_oqs_init(int type, u_int32_t seq,
+	struct ssh *ssh) {
+
+	HYBRID_KEX_CTX *hybrid_kex_ctx = NULL;
+	OQS_KEX_CTX *oqs_kex_ctx = NULL;
+	const OQS_ALG *oqs_alg = NULL;
+	struct kex *kex = NULL;
+	struct sshkey *server_host_public = NULL;
+	struct sshkey *server_host_private = NULL;
+	struct sshbuf *shared_secret_ssh_buf = NULL;
+	u_char *ecdh_shared_secret = NULL;
+	u_char *oqs_shared_secret = NULL;
+	u_char *shared_secret = NULL;
+	u_char *server_host_key_blob = NULL;
+	u_char *signature = NULL;
+	u_char hash[SSH_DIGEST_MAX_LENGTH];
+	size_t server_host_key_blob_len = 0;
+	size_t signature_len = 0;
+	size_t hash_len = 0;
+	size_t ecdh_shared_secret_len = 0;
+	size_t oqs_shared_secret_len = 0;
+	size_t shared_secret_len = 0;
+	int r = 0;
+
+	/* Test whether we are prepared to handle this packet */
+	if (ssh == NULL ||
+		(kex = ssh->kex) == NULL ||
+		(hybrid_kex_ctx = kex->hybrid_kex_ctx) == NULL ||
+		(oqs_kex_ctx = hybrid_kex_ctx->oqs_kex_ctx) == NULL) {
+
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	/* Load public and private host key */
+	if ((r = hybrid_ecdh_oqs_server_hostkey(ssh, &server_host_public,
+		&server_host_private, &server_host_key_blob,
+		&server_host_key_blob_len)) != 0)
+		goto out;
+
+	/*
+	 * Calling hybrid_ecdh_gen() before deserialising the packet
+	 * populates the hybrid_kex_ctx structure with
+	 * the ellipctic curve group. This is needed to properly extract
+	 * the public key from the packet.
+	 * This call also generates the local public ecdh key on the server.
+	 */
+	if ((r = hybrid_ecdh_gen(hybrid_kex_ctx)) != 0)
+		goto out;
+
+	/*
+	 * We can then deserialise the content of the incoming packet
+	 * from the client
+	 */
+	if ((r = hybrid_ecdh_oqs_c2s_deserialise(ssh, hybrid_kex_ctx)) != 0)
+		goto out;
+
+	if ((r = hybrid_ecdh_shared_secret(hybrid_kex_ctx, &ecdh_shared_secret,
+		&ecdh_shared_secret_len)) != 0)
+		goto out;
+
+	/*
+	 * libOQS API only supports generating the liboqs public key
+	 * msg and shared secret simultaneously.
+	 */
+	if ((r = oqs_server_gen_msg_and_ss(oqs_kex_ctx,
+		&oqs_shared_secret, &oqs_shared_secret_len)) != 0)
+		goto out;
+
+	if ((r = hybrid_ecdh_oqs_combine_shared_secrets(ecdh_shared_secret,
+		ecdh_shared_secret_len, oqs_shared_secret, oqs_shared_secret_len,
+		&shared_secret, &shared_secret_len)) != 0)
+		goto out;
+
+	/*
+	 * Compute exchange hash
+	 * kex->peer is client
+	 * kex->my is server
+	 */
+	hash_len = sizeof(hash);
+	if ((r = hybrid_ecdh_oqs_hash(
+		kex->hash_alg,
+		kex->client_version_string,
+		kex->server_version_string,
+		kex->peer,
+		kex->my,
+		server_host_key_blob, server_host_key_blob_len,
+		hybrid_kex_ctx->ecdh_group,
+		hybrid_kex_ctx->ecdh_remote_public,
+		hybrid_kex_ctx->ecdh_local_public,
+		oqs_kex_ctx->oqs_remote_msg, oqs_kex_ctx->oqs_remote_msg_len,
+		oqs_kex_ctx->oqs_local_msg, oqs_kex_ctx->oqs_local_msg_len,
+		shared_secret, shared_secret_len,
+		hash, &hash_len)) !=0)
+		goto out;
+
+	/* Save session id */
+	if (kex->session_id == NULL) {
+		kex->session_id_len = hash_len;
+		kex->session_id = malloc(kex->session_id_len);
+		if (kex->session_id == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		memcpy(kex->session_id, hash, kex->session_id_len);
+	}
+
+	/* Sign exchange hash */
+	if ((r = kex->sign(server_host_private, server_host_public,
+		&signature, &signature_len, hash, hash_len, kex->hostkey_alg,
+		ssh->compat)) < 0)
+		goto out;
+
+	if ((oqs_alg = oqs_mapping(hybrid_kex_ctx->hybrid_kex_name)) == NULL) {
+		error("Unsupported libOQS algorithm \"%.100s\"", hybrid_kex_ctx->hybrid_kex_name);
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	/* Send hybrid ecdh+liboqs server to client packet */
+	if ((r = sshpkt_start(ssh, oqs_ssh2_reply_msg(oqs_alg))) != 0 ||
+		(r = hybrid_ecdh_oqs_s2c_serialise(ssh, hybrid_kex_ctx, server_host_key_blob,
+			server_host_key_blob_len, signature, signature_len)) != 0 ||
+		(r = sshpkt_send(ssh)) != 0)
+		goto out;
+
+	/*
+	 * sshbuf_put_string() will encode the shared secret as a mpint
+	 * as required by SSH spec (RFC4253)
+	 */
+	if ((shared_secret_ssh_buf = sshbuf_new()) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if ((r = sshbuf_put_string(shared_secret_ssh_buf, (const u_char *) shared_secret,
+		shared_secret_len)) != 0)
+		goto out;
+
+	if ((r = kex_derive_keys(ssh, hash, hash_len, shared_secret_ssh_buf)) == 0)
+		r = kex_send_newkeys(ssh);
+
+out:
+	explicit_bzero(hash, sizeof(hash));
+	hybrid_ecdh_oqs_free(hybrid_kex_ctx);
+	/* sshbuf_free zeroises memory */
+	if (shared_secret_ssh_buf != NULL)
+		sshbuf_free(shared_secret_ssh_buf);
+	if (shared_secret != NULL) {
+		explicit_bzero(shared_secret, shared_secret_len);
+		free(shared_secret);
+	}
+	if (ecdh_shared_secret != NULL) {
+		explicit_bzero(ecdh_shared_secret, ecdh_shared_secret_len);
+		free(ecdh_shared_secret);
+	}
+	if (oqs_shared_secret != NULL) {
+		explicit_bzero(oqs_shared_secret, oqs_shared_secret_len);
+		free(oqs_shared_secret);
+	}
+	if (server_host_key_blob != NULL)
+		free(server_host_key_blob);
+	if (signature != NULL)
+		free(signature);
+
+	return r;
+}
+
+#endif /* defined(OPENSSL_HAS_ECC) && defined(WITH_OQS) && defined(WITH_HYBRID_KEX) */
--- /dev/null
+++ b/kexoqs.c
@@ -0,0 +1,628 @@
+/*
+* Copyright 2018 Amazon.com, Inc. or its affiliates. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "includes.h"
+
+#ifdef WITH_OQS
+
+#include <string.h>
+
+#include "ssherr.h"
+#include "packet.h"
+#include "ssh2.h"
+#include "kexoqs.h"
+
+/*
+ * Mapping that maps relevant named SSH key exchange methods to the needed
+ * corresponding liboqs key exchange scheme
+ */
+static const OQS_ALG oqs_alg_mapping[] = {
+/* Hybrid key exchange methods */
+#if defined(OPENSSL_HAS_ECC) && defined(WITH_HYBRID_KEX)
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-oqsdefault-sha384"), OQS_KEM_alg_default,
+	SSH2_MSG_HY_ECDH_OQSDEFAULT_INIT, SSH2_MSG_HY_ECDH_OQSDEFAULT_REPLY},
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_HYBRID_KEXS_START
+#ifdef HAVE_BIKE
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-bike1-l1-cpa-sha384"), OQS_KEM_alg_bike1_l1_cpa,
+	SSH2_MSG_HY_ECDH_BIKE_INIT, SSH2_MSG_HY_ECDH_BIKE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-bike1-l3-cpa-sha384"), OQS_KEM_alg_bike1_l3_cpa,
+	SSH2_MSG_HY_ECDH_BIKE_INIT, SSH2_MSG_HY_ECDH_BIKE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-bike1-l1-fo-sha384"), OQS_KEM_alg_bike1_l1_fo,
+	SSH2_MSG_HY_ECDH_BIKE_INIT, SSH2_MSG_HY_ECDH_BIKE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-bike1-l3-fo-sha384"), OQS_KEM_alg_bike1_l3_fo,
+	SSH2_MSG_HY_ECDH_BIKE_INIT, SSH2_MSG_HY_ECDH_BIKE_REPLY},
+#endif /* HAVE_BIKE */
+#ifdef HAVE_CLASSIC_MCELIECE
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-348864-sha384"), OQS_KEM_alg_classic_mceliece_348864,
+	SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_INIT, SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-348864f-sha384"), OQS_KEM_alg_classic_mceliece_348864f,
+	SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_INIT, SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-460896-sha384"), OQS_KEM_alg_classic_mceliece_460896,
+	SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_INIT, SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-460896f-sha384"), OQS_KEM_alg_classic_mceliece_460896f,
+	SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_INIT, SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-6688128-sha384"), OQS_KEM_alg_classic_mceliece_6688128,
+	SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_INIT, SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-6688128f-sha384"), OQS_KEM_alg_classic_mceliece_6688128f,
+	SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_INIT, SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-6960119-sha384"), OQS_KEM_alg_classic_mceliece_6960119,
+	SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_INIT, SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-6960119f-sha384"), OQS_KEM_alg_classic_mceliece_6960119f,
+	SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_INIT, SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-8192128-sha384"), OQS_KEM_alg_classic_mceliece_8192128,
+	SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_INIT, SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-classic-mceliece-8192128f-sha384"), OQS_KEM_alg_classic_mceliece_8192128f,
+	SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_INIT, SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_REPLY},
+#endif /* HAVE_CLASSIC_MCELIECE */
+#ifdef HAVE_FRODO
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-frodo-640-aes-sha384"), OQS_KEM_alg_frodokem_640_aes,
+	SSH2_MSG_HY_ECDH_FRODO_INIT, SSH2_MSG_HY_ECDH_FRODO_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-frodo-640-shake-sha384"), OQS_KEM_alg_frodokem_640_shake,
+	SSH2_MSG_HY_ECDH_FRODO_INIT, SSH2_MSG_HY_ECDH_FRODO_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-frodo-976-aes-sha384"), OQS_KEM_alg_frodokem_976_aes,
+	SSH2_MSG_HY_ECDH_FRODO_INIT, SSH2_MSG_HY_ECDH_FRODO_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-frodo-976-shake-sha384"), OQS_KEM_alg_frodokem_976_shake,
+	SSH2_MSG_HY_ECDH_FRODO_INIT, SSH2_MSG_HY_ECDH_FRODO_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-frodo-1344-aes-sha384"), OQS_KEM_alg_frodokem_1344_aes,
+	SSH2_MSG_HY_ECDH_FRODO_INIT, SSH2_MSG_HY_ECDH_FRODO_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-frodo-1344-shake-sha384"), OQS_KEM_alg_frodokem_1344_shake,
+	SSH2_MSG_HY_ECDH_FRODO_INIT, SSH2_MSG_HY_ECDH_FRODO_REPLY},
+#endif /* HAVE_FRODO */
+#ifdef HAVE_KYBER
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-kyber-512-sha384"), OQS_KEM_alg_kyber_512,
+	SSH2_MSG_HY_ECDH_KYBER_INIT, SSH2_MSG_HY_ECDH_KYBER_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-kyber-768-sha384"), OQS_KEM_alg_kyber_768,
+	SSH2_MSG_HY_ECDH_KYBER_INIT, SSH2_MSG_HY_ECDH_KYBER_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-kyber-1024-sha384"), OQS_KEM_alg_kyber_1024,
+	SSH2_MSG_HY_ECDH_KYBER_INIT, SSH2_MSG_HY_ECDH_KYBER_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-kyber-512-90s-sha384"), OQS_KEM_alg_kyber_512_90s,
+	SSH2_MSG_HY_ECDH_KYBER_INIT, SSH2_MSG_HY_ECDH_KYBER_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-kyber-768-90s-sha384"), OQS_KEM_alg_kyber_768_90s,
+	SSH2_MSG_HY_ECDH_KYBER_INIT, SSH2_MSG_HY_ECDH_KYBER_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-kyber-1024-90s-sha384"), OQS_KEM_alg_kyber_1024_90s,
+	SSH2_MSG_HY_ECDH_KYBER_INIT, SSH2_MSG_HY_ECDH_KYBER_REPLY},
+#endif /* HAVE_KYBER */
+#ifdef HAVE_NEWHOPE
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-newhope-512-sha384"), OQS_KEM_alg_newhope_512cca,
+	SSH2_MSG_HY_ECDH_NEWHOPE_INIT, SSH2_MSG_HY_ECDH_NEWHOPE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-newhope-1024-sha384"), OQS_KEM_alg_newhope_1024cca,
+	SSH2_MSG_HY_ECDH_NEWHOPE_INIT, SSH2_MSG_HY_ECDH_NEWHOPE_REPLY},
+#endif /* HAVE_NEWHOPE */
+#ifdef HAVE_NTRU
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-ntru-hps-2048-509-sha384"), OQS_KEM_alg_ntru_hps2048509,
+	SSH2_MSG_HY_ECDH_NTRU_INIT, SSH2_MSG_HY_ECDH_NTRU_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-ntru-hps-2048-677-sha384"), OQS_KEM_alg_ntru_hps2048677,
+	SSH2_MSG_HY_ECDH_NTRU_INIT, SSH2_MSG_HY_ECDH_NTRU_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-ntru-hrss-701-sha384"), OQS_KEM_alg_ntru_hrss701,
+	SSH2_MSG_HY_ECDH_NTRU_INIT, SSH2_MSG_HY_ECDH_NTRU_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-ntru-hps-4096-821-sha384"), OQS_KEM_alg_ntru_hps4096821,
+	SSH2_MSG_HY_ECDH_NTRU_INIT, SSH2_MSG_HY_ECDH_NTRU_REPLY},
+#endif /* HAVE_NTRU */
+#ifdef HAVE_SABER
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-saber-lightsaber-sha384"), OQS_KEM_alg_saber_lightsaber,
+	SSH2_MSG_HY_ECDH_SABER_INIT, SSH2_MSG_HY_ECDH_SABER_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-saber-saber-sha384"), OQS_KEM_alg_saber_saber,
+	SSH2_MSG_HY_ECDH_SABER_INIT, SSH2_MSG_HY_ECDH_SABER_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-saber-firesaber-sha384"), OQS_KEM_alg_saber_firesaber,
+	SSH2_MSG_HY_ECDH_SABER_INIT, SSH2_MSG_HY_ECDH_SABER_REPLY},
+#endif /* HAVE_SABER */
+#ifdef HAVE_SIDH
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p434-sha384"), OQS_KEM_alg_sidh_p434,
+	SSH2_MSG_HY_ECDH_SIDH_INIT, SSH2_MSG_HY_ECDH_SIDH_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p503-sha384"), OQS_KEM_alg_sidh_p503,
+	SSH2_MSG_HY_ECDH_SIDH_INIT, SSH2_MSG_HY_ECDH_SIDH_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p610-sha384"), OQS_KEM_alg_sidh_p610,
+	SSH2_MSG_HY_ECDH_SIDH_INIT, SSH2_MSG_HY_ECDH_SIDH_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p751-sha384"), OQS_KEM_alg_sidh_p751,
+	SSH2_MSG_HY_ECDH_SIDH_INIT, SSH2_MSG_HY_ECDH_SIDH_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p434-compressed-sha384"), OQS_KEM_alg_sidh_p434_compressed,
+	SSH2_MSG_HY_ECDH_SIDH_INIT, SSH2_MSG_HY_ECDH_SIDH_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p503-compressed-sha384"), OQS_KEM_alg_sidh_p503_compressed,
+	SSH2_MSG_HY_ECDH_SIDH_INIT, SSH2_MSG_HY_ECDH_SIDH_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p610-compressed-sha384"), OQS_KEM_alg_sidh_p610_compressed,
+	SSH2_MSG_HY_ECDH_SIDH_INIT, SSH2_MSG_HY_ECDH_SIDH_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sidh-p751-compressed-sha384"), OQS_KEM_alg_sidh_p751_compressed,
+	SSH2_MSG_HY_ECDH_SIDH_INIT, SSH2_MSG_HY_ECDH_SIDH_REPLY},
+#endif /* HAVE_SIDH */
+#ifdef HAVE_SIKE
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sike-p434-sha384"), OQS_KEM_alg_sike_p434,
+	SSH2_MSG_HY_ECDH_SIKE_INIT, SSH2_MSG_HY_ECDH_SIKE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sike-p503-sha384"), OQS_KEM_alg_sike_p503,
+	SSH2_MSG_HY_ECDH_SIKE_INIT, SSH2_MSG_HY_ECDH_SIKE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sike-p610-sha384"), OQS_KEM_alg_sike_p610,
+	SSH2_MSG_HY_ECDH_SIKE_INIT, SSH2_MSG_HY_ECDH_SIKE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sike-p751-sha384"), OQS_KEM_alg_sike_p751,
+	SSH2_MSG_HY_ECDH_SIKE_INIT, SSH2_MSG_HY_ECDH_SIKE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384--sha384"), OQS_KEM_alg_sike_p434_compressed,
+	SSH2_MSG_HY_ECDH_SIKE_INIT, SSH2_MSG_HY_ECDH_SIKE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sike-p503-compressed-sha384"), OQS_KEM_alg_sike_p503_compressed,
+	SSH2_MSG_HY_ECDH_SIKE_INIT, SSH2_MSG_HY_ECDH_SIKE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sike-p610-compressed-sha384"), OQS_KEM_alg_sike_p610_compressed,
+	SSH2_MSG_HY_ECDH_SIKE_INIT, SSH2_MSG_HY_ECDH_SIKE_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-sike-p751-compressed-sha384"), OQS_KEM_alg_sike_p751_compressed,
+	SSH2_MSG_HY_ECDH_SIKE_INIT, SSH2_MSG_HY_ECDH_SIKE_REPLY},
+#endif /* HAVE_SIKE */
+#ifdef HAVE_THREEBEARS
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-babybear-sha384"), OQS_KEM_alg_threebears_babybear,
+	SSH2_MSG_HY_ECDH_THREEBEARS_INIT, SSH2_MSG_HY_ECDH_THREEBEARS_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-babybear-ephem-sha384"), OQS_KEM_alg_threebears_babybear_ephem,
+	SSH2_MSG_HY_ECDH_THREEBEARS_INIT, SSH2_MSG_HY_ECDH_THREEBEARS_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-mamabear-sha384"), OQS_KEM_alg_threebears_mamabear,
+	SSH2_MSG_HY_ECDH_THREEBEARS_INIT, SSH2_MSG_HY_ECDH_THREEBEARS_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-mamabear-ephem-sha384"), OQS_KEM_alg_threebears_mamabear_ephem,
+	SSH2_MSG_HY_ECDH_THREEBEARS_INIT, SSH2_MSG_HY_ECDH_THREEBEARS_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-papabear-sha384"), OQS_KEM_alg_threebears_papabear,
+	SSH2_MSG_HY_ECDH_THREEBEARS_INIT, SSH2_MSG_HY_ECDH_THREEBEARS_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-papabear-ephem-sha384"), OQS_KEM_alg_threebears_papabear_ephem,
+	SSH2_MSG_HY_ECDH_THREEBEARS_INIT, SSH2_MSG_HY_ECDH_THREEBEARS_REPLY},
+#endif /* HAVE_THREEBEARS */
+#ifdef HAVE_HQC
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-hqc-128-1-cca2-sha384"), OQS_KEM_alg_hqc_128_1_cca2,
+	SSH2_MSG_HY_ECDH_HQC_INIT, SSH2_MSG_HY_ECDH_HQC_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-hqc-192-1-cca2-sha384"), OQS_KEM_alg_hqc_192_1_cca2,
+	SSH2_MSG_HY_ECDH_HQC_INIT, SSH2_MSG_HY_ECDH_HQC_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-hqc-192-2-cca2-sha384"), OQS_KEM_alg_hqc_192_2_cca2,
+	SSH2_MSG_HY_ECDH_HQC_INIT, SSH2_MSG_HY_ECDH_HQC_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-hqc-256-1-cca2-sha384"), OQS_KEM_alg_hqc_256_1_cca2,
+	SSH2_MSG_HY_ECDH_HQC_INIT, SSH2_MSG_HY_ECDH_HQC_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-hqc-256-2-cca2-sha384"), OQS_KEM_alg_hqc_256_2_cca2,
+	SSH2_MSG_HY_ECDH_HQC_INIT, SSH2_MSG_HY_ECDH_HQC_REPLY},
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-hqc-256-3-cca2-sha384"), OQS_KEM_alg_hqc_256_3_cca2,
+	SSH2_MSG_HY_ECDH_HQC_INIT, SSH2_MSG_HY_ECDH_HQC_REPLY},
+#endif /* HAVE_HQC */
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_HYBRID_KEXS_END
+#endif /* defined(OPENSSL_HAS_ECC) && defined(WITH_HYBRID_KEX) */
+/* PQ-only key exchange methods */
+#ifdef WITH_PQ_KEX
+	{PQ_OQS_KEX_SUFFIX("oqsdefault-sha384"), OQS_KEM_alg_default,
+	SSH2_MSG_PQ_OQSDEFAULT_INIT, SSH2_MSG_PQ_OQSDEFAULT_REPLY},
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_PQ_KEXS_START
+#ifdef HAVE_BIKE
+	{PQ_OQS_KEX_SUFFIX("bike1-l1-cpa-sha384"), OQS_KEM_alg_bike1_l1_cpa,
+	SSH2_MSG_PQ_BIKE_INIT, SSH2_MSG_PQ_BIKE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("bike1-l3-cpa-sha384"), OQS_KEM_alg_bike1_l3_cpa,
+	SSH2_MSG_PQ_BIKE_INIT, SSH2_MSG_PQ_BIKE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("bike1-l1-fo-sha384"), OQS_KEM_alg_bike1_l1_fo,
+	SSH2_MSG_PQ_BIKE_INIT, SSH2_MSG_PQ_BIKE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("bike1-l3-fo-sha384"), OQS_KEM_alg_bike1_l3_fo,
+	SSH2_MSG_PQ_BIKE_INIT, SSH2_MSG_PQ_BIKE_REPLY},
+#endif /* HAVE_BIKE */
+#ifdef HAVE_CLASSIC_MCELIECE
+	{PQ_OQS_KEX_SUFFIX("classic-mceliece-348864-sha384"), OQS_KEM_alg_classic_mceliece_348864,
+	SSH2_MSG_PQ_CLASSIC_MCELIECE_INIT, SSH2_MSG_PQ_CLASSIC_MCELIECE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("classic-mceliece-348864f-sha384"), OQS_KEM_alg_classic_mceliece_348864f,
+	SSH2_MSG_PQ_CLASSIC_MCELIECE_INIT, SSH2_MSG_PQ_CLASSIC_MCELIECE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("classic-mceliece-460896-sha384"), OQS_KEM_alg_classic_mceliece_460896,
+	SSH2_MSG_PQ_CLASSIC_MCELIECE_INIT, SSH2_MSG_PQ_CLASSIC_MCELIECE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("classic-mceliece-460896f-sha384"), OQS_KEM_alg_classic_mceliece_460896f,
+	SSH2_MSG_PQ_CLASSIC_MCELIECE_INIT, SSH2_MSG_PQ_CLASSIC_MCELIECE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("classic-mceliece-6688128-sha384"), OQS_KEM_alg_classic_mceliece_6688128,
+	SSH2_MSG_PQ_CLASSIC_MCELIECE_INIT, SSH2_MSG_PQ_CLASSIC_MCELIECE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("classic-mceliece-6688128f-sha384"), OQS_KEM_alg_classic_mceliece_6688128f,
+	SSH2_MSG_PQ_CLASSIC_MCELIECE_INIT, SSH2_MSG_PQ_CLASSIC_MCELIECE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("classic-mceliece-6960119-sha384"), OQS_KEM_alg_classic_mceliece_6960119,
+	SSH2_MSG_PQ_CLASSIC_MCELIECE_INIT, SSH2_MSG_PQ_CLASSIC_MCELIECE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("classic-mceliece-6960119f-sha384"), OQS_KEM_alg_classic_mceliece_6960119f,
+	SSH2_MSG_PQ_CLASSIC_MCELIECE_INIT, SSH2_MSG_PQ_CLASSIC_MCELIECE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("classic-mceliece-8192128-sha384"), OQS_KEM_alg_classic_mceliece_8192128,
+	SSH2_MSG_PQ_CLASSIC_MCELIECE_INIT, SSH2_MSG_PQ_CLASSIC_MCELIECE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("classic-mceliece-8192128f-sha384"), OQS_KEM_alg_classic_mceliece_8192128f,
+	SSH2_MSG_PQ_CLASSIC_MCELIECE_INIT, SSH2_MSG_PQ_CLASSIC_MCELIECE_REPLY},
+#endif /* HAVE_CLASSIC_MCELIECE */
+#ifdef HAVE_FRODO
+	{PQ_OQS_KEX_SUFFIX("frodo-640-aes-sha384"), OQS_KEM_alg_frodokem_640_aes,
+	SSH2_MSG_PQ_FRODO_INIT, SSH2_MSG_PQ_FRODO_REPLY},
+	{PQ_OQS_KEX_SUFFIX("frodo-640-shake-sha384"), OQS_KEM_alg_frodokem_640_shake,
+	SSH2_MSG_PQ_FRODO_INIT, SSH2_MSG_PQ_FRODO_REPLY},
+	{PQ_OQS_KEX_SUFFIX("frodo-976-aes-sha384"), OQS_KEM_alg_frodokem_976_aes,
+	SSH2_MSG_PQ_FRODO_INIT, SSH2_MSG_PQ_FRODO_REPLY},
+	{PQ_OQS_KEX_SUFFIX("frodo-976-shake-sha384"), OQS_KEM_alg_frodokem_976_shake,
+	SSH2_MSG_PQ_FRODO_INIT, SSH2_MSG_PQ_FRODO_REPLY},
+	{PQ_OQS_KEX_SUFFIX("frodo-1344-aes-sha384"), OQS_KEM_alg_frodokem_1344_aes,
+	SSH2_MSG_PQ_FRODO_INIT, SSH2_MSG_PQ_FRODO_REPLY},
+	{PQ_OQS_KEX_SUFFIX("frodo-1344-shake-sha384"), OQS_KEM_alg_frodokem_1344_shake,
+	SSH2_MSG_PQ_FRODO_INIT, SSH2_MSG_PQ_FRODO_REPLY},
+#endif /* HAVE_FRODO */
+#ifdef HAVE_KYBER
+	{PQ_OQS_KEX_SUFFIX("kyber-512-sha384"), OQS_KEM_alg_kyber_512,
+	SSH2_MSG_PQ_KYBER_INIT, SSH2_MSG_PQ_KYBER_REPLY},
+	{PQ_OQS_KEX_SUFFIX("kyber-768-sha384"), OQS_KEM_alg_kyber_768,
+	SSH2_MSG_PQ_KYBER_INIT, SSH2_MSG_PQ_KYBER_REPLY},
+	{PQ_OQS_KEX_SUFFIX("kyber-1024-sha384"), OQS_KEM_alg_kyber_1024,
+	SSH2_MSG_PQ_KYBER_INIT, SSH2_MSG_PQ_KYBER_REPLY},
+	{PQ_OQS_KEX_SUFFIX("kyber-512-90s-sha384"), OQS_KEM_alg_kyber_512_90s,
+	SSH2_MSG_PQ_KYBER_INIT, SSH2_MSG_PQ_KYBER_REPLY},
+	{PQ_OQS_KEX_SUFFIX("kyber-768-90s-sha384"), OQS_KEM_alg_kyber_768_90s,
+	SSH2_MSG_PQ_KYBER_INIT, SSH2_MSG_PQ_KYBER_REPLY},
+	{PQ_OQS_KEX_SUFFIX("kyber-1024-90s-sha384"), OQS_KEM_alg_kyber_1024_90s,
+	SSH2_MSG_PQ_KYBER_INIT, SSH2_MSG_PQ_KYBER_REPLY},
+#endif /* HAVE_KYBER */
+#ifdef HAVE_NEWHOPE
+	{PQ_OQS_KEX_SUFFIX("newhope-512-sha384"), OQS_KEM_alg_newhope_512cca,
+	SSH2_MSG_PQ_NEWHOPE_INIT, SSH2_MSG_PQ_NEWHOPE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("newhope-1024-sha384"), OQS_KEM_alg_newhope_1024cca,
+	SSH2_MSG_PQ_NEWHOPE_INIT, SSH2_MSG_PQ_NEWHOPE_REPLY},
+#endif /* HAVE_NEWHOPE */
+#ifdef HAVE_NTRU
+	{PQ_OQS_KEX_SUFFIX("ntru-hps-2048-509-sha384"), OQS_KEM_alg_ntru_hps2048509,
+	SSH2_MSG_PQ_NTRU_INIT, SSH2_MSG_PQ_NTRU_REPLY},
+	{PQ_OQS_KEX_SUFFIX("ntru-hps-2048-677-sha384"), OQS_KEM_alg_ntru_hps2048677,
+	SSH2_MSG_PQ_NTRU_INIT, SSH2_MSG_PQ_NTRU_REPLY},
+	{PQ_OQS_KEX_SUFFIX("ntru-hrss-701-sha384"), OQS_KEM_alg_ntru_hrss701,
+	SSH2_MSG_PQ_NTRU_INIT, SSH2_MSG_PQ_NTRU_REPLY},
+	{PQ_OQS_KEX_SUFFIX("ntru-hps-4096-821-sha384"), OQS_KEM_alg_ntru_hps4096821,
+	SSH2_MSG_PQ_NTRU_INIT, SSH2_MSG_PQ_NTRU_REPLY},
+#endif /* HAVE_NTRU */
+#ifdef HAVE_SABER
+	{PQ_OQS_KEX_SUFFIX("saber-lightsaber-sha384"), OQS_KEM_alg_saber_lightsaber,
+	SSH2_MSG_PQ_SABER_INIT, SSH2_MSG_PQ_SABER_REPLY},
+	{PQ_OQS_KEX_SUFFIX("saber-saber-sha384"), OQS_KEM_alg_saber_saber,
+	SSH2_MSG_PQ_SABER_INIT, SSH2_MSG_PQ_SABER_REPLY},
+	{PQ_OQS_KEX_SUFFIX("saber-firesaber-sha384"), OQS_KEM_alg_saber_firesaber,
+	SSH2_MSG_PQ_SABER_INIT, SSH2_MSG_PQ_SABER_REPLY},
+#endif /* HAVE_SABER */
+#ifdef HAVE_SIDH
+	{PQ_OQS_KEX_SUFFIX("sidh-p434-sha384"), OQS_KEM_alg_sidh_p434,
+	SSH2_MSG_PQ_SIDH_INIT, SSH2_MSG_PQ_SIDH_REPLY},
+	{PQ_OQS_KEX_SUFFIX("sidh-p503-sha384"), OQS_KEM_alg_sidh_p503,
+	SSH2_MSG_PQ_SIDH_INIT, SSH2_MSG_PQ_SIDH_REPLY},
+	{PQ_OQS_KEX_SUFFIX("sidh-p610-sha384"), OQS_KEM_alg_sidh_p610,
+	SSH2_MSG_PQ_SIDH_INIT, SSH2_MSG_PQ_SIDH_REPLY},
+	{PQ_OQS_KEX_SUFFIX("sidh-p751-sha384"), OQS_KEM_alg_sidh_p751,
+	SSH2_MSG_PQ_SIDH_INIT, SSH2_MSG_PQ_SIDH_REPLY},
+	{PQ_OQS_KEX_SUFFIX("sidh-p434-compressed-sha384"), OQS_KEM_alg_sidh_p434_compressed,
+	SSH2_MSG_PQ_SIDH_INIT, SSH2_MSG_PQ_SIDH_REPLY},
+	{PQ_OQS_KEX_SUFFIX("sidh-p503-compressed-sha384"), OQS_KEM_alg_sidh_p503_compressed,
+	SSH2_MSG_PQ_SIDH_INIT, SSH2_MSG_PQ_SIDH_REPLY},
+	{PQ_OQS_KEX_SUFFIX("sidh-p610-compressed-sha384"), OQS_KEM_alg_sidh_p610_compressed,
+	SSH2_MSG_PQ_SIDH_INIT, SSH2_MSG_PQ_SIDH_REPLY},
+	{PQ_OQS_KEX_SUFFIX("sidh-p751-compressed-sha384"), OQS_KEM_alg_sidh_p751_compressed,
+	SSH2_MSG_PQ_SIDH_INIT, SSH2_MSG_PQ_SIDH_REPLY},
+#endif /* HAVE_SIDH */
+#ifdef HAVE_SIKE
+	{PQ_OQS_KEX_SUFFIX("sike-p434-sha384"), OQS_KEM_alg_sike_p434,
+	SSH2_MSG_PQ_SIKE_INIT, SSH2_MSG_PQ_SIKE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("sike-p503-sha384"), OQS_KEM_alg_sike_p503,
+	SSH2_MSG_PQ_SIKE_INIT, SSH2_MSG_PQ_SIKE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("sike-p610-sha384"), OQS_KEM_alg_sike_p610,
+	SSH2_MSG_PQ_SIKE_INIT, SSH2_MSG_PQ_SIKE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("sike-p751-sha384"), OQS_KEM_alg_sike_p751,
+	SSH2_MSG_PQ_SIKE_INIT, SSH2_MSG_PQ_SIKE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("-sha384"), OQS_KEM_alg_sike_p434_compressed,
+	SSH2_MSG_PQ_SIKE_INIT, SSH2_MSG_PQ_SIKE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("sike-p503-compressed-sha384"), OQS_KEM_alg_sike_p503_compressed,
+	SSH2_MSG_PQ_SIKE_INIT, SSH2_MSG_PQ_SIKE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("sike-p610-compressed-sha384"), OQS_KEM_alg_sike_p610_compressed,
+	SSH2_MSG_PQ_SIKE_INIT, SSH2_MSG_PQ_SIKE_REPLY},
+	{PQ_OQS_KEX_SUFFIX("sike-p751-compressed-sha384"), OQS_KEM_alg_sike_p751_compressed,
+	SSH2_MSG_PQ_SIKE_INIT, SSH2_MSG_PQ_SIKE_REPLY},
+#endif /* HAVE_SIKE */
+#ifdef HAVE_THREEBEARS
+	{PQ_OQS_KEX_SUFFIX("babybear-sha384"), OQS_KEM_alg_threebears_babybear,
+	SSH2_MSG_PQ_THREEBEARS_INIT, SSH2_MSG_PQ_THREEBEARS_REPLY},
+	{PQ_OQS_KEX_SUFFIX("babybear-ephem-sha384"), OQS_KEM_alg_threebears_babybear_ephem,
+	SSH2_MSG_PQ_THREEBEARS_INIT, SSH2_MSG_PQ_THREEBEARS_REPLY},
+	{PQ_OQS_KEX_SUFFIX("mamabear-sha384"), OQS_KEM_alg_threebears_mamabear,
+	SSH2_MSG_PQ_THREEBEARS_INIT, SSH2_MSG_PQ_THREEBEARS_REPLY},
+	{PQ_OQS_KEX_SUFFIX("mamabear-ephem-sha384"), OQS_KEM_alg_threebears_mamabear_ephem,
+	SSH2_MSG_PQ_THREEBEARS_INIT, SSH2_MSG_PQ_THREEBEARS_REPLY},
+	{PQ_OQS_KEX_SUFFIX("papabear-sha384"), OQS_KEM_alg_threebears_papabear,
+	SSH2_MSG_PQ_THREEBEARS_INIT, SSH2_MSG_PQ_THREEBEARS_REPLY},
+	{PQ_OQS_KEX_SUFFIX("papabear-ephem-sha384"), OQS_KEM_alg_threebears_papabear_ephem,
+	SSH2_MSG_PQ_THREEBEARS_INIT, SSH2_MSG_PQ_THREEBEARS_REPLY},
+#endif /* HAVE_THREEBEARS */
+#ifdef HAVE_HQC
+	{PQ_OQS_KEX_SUFFIX("hqc-128-1-cca2-sha384"), OQS_KEM_alg_hqc_128_1_cca2,
+	SSH2_MSG_PQ_HQC_INIT, SSH2_MSG_PQ_HQC_REPLY},
+	{PQ_OQS_KEX_SUFFIX("hqc-192-1-cca2-sha384"), OQS_KEM_alg_hqc_192_1_cca2,
+	SSH2_MSG_PQ_HQC_INIT, SSH2_MSG_PQ_HQC_REPLY},
+	{PQ_OQS_KEX_SUFFIX("hqc-192-2-cca2-sha384"), OQS_KEM_alg_hqc_192_2_cca2,
+	SSH2_MSG_PQ_HQC_INIT, SSH2_MSG_PQ_HQC_REPLY},
+	{PQ_OQS_KEX_SUFFIX("hqc-256-1-cca2-sha384"), OQS_KEM_alg_hqc_256_1_cca2,
+	SSH2_MSG_PQ_HQC_INIT, SSH2_MSG_PQ_HQC_REPLY},
+	{PQ_OQS_KEX_SUFFIX("hqc-256-2-cca2-sha384"), OQS_KEM_alg_hqc_256_2_cca2,
+	SSH2_MSG_PQ_HQC_INIT, SSH2_MSG_PQ_HQC_REPLY},
+	{PQ_OQS_KEX_SUFFIX("hqc-256-3-cca2-sha384"), OQS_KEM_alg_hqc_256_3_cca2,
+	SSH2_MSG_PQ_HQC_INIT, SSH2_MSG_PQ_HQC_REPLY},
+#endif /* HAVE_HQC */
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_PQ_KEXS_END
+#endif /* WITH_PQ_KEX */
+	{NULL,NULL,0,0} /* End of list */
+};
+
+/*
+ * @brief Maps the named SSH key exchange method's PQ kex algorithm
+ * to liboqs key exchange algorithm
+ */
+const OQS_ALG *
+oqs_mapping(const char *ssh_kex_name) {
+
+	const OQS_ALG *alg = NULL;
+
+	for (alg = oqs_alg_mapping; alg->kex_alg != NULL; alg++) {
+		if (strcmp(alg->kex_alg, ssh_kex_name) == 0) {
+			return alg;
+		}
+	}
+
+	return NULL;
+}
+
+/*
+ * @brief Initialise key exchange liboqs specific context
+ */
+int
+oqs_init(OQS_KEX_CTX **oqs_kex_ctx, char *ssh_kex_name) {
+
+	OQS_KEX_CTX *tmp_oqs_kex_ctx = NULL;
+	const OQS_ALG *oqs_alg = NULL;
+	int r = 0;
+
+	if ((tmp_oqs_kex_ctx = calloc(sizeof(*(tmp_oqs_kex_ctx)), 1)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+
+	if ((oqs_alg = oqs_mapping(ssh_kex_name)) == NULL) {
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	tmp_oqs_kex_ctx->oqs_kem = NULL;
+	tmp_oqs_kex_ctx->oqs_method = strdup(oqs_alg->alg_name);
+	tmp_oqs_kex_ctx->oqs_local_priv = NULL;
+	tmp_oqs_kex_ctx->oqs_local_priv_len = 0;
+	tmp_oqs_kex_ctx->oqs_local_msg = NULL;
+	tmp_oqs_kex_ctx->oqs_local_msg_len = 0;
+	tmp_oqs_kex_ctx->oqs_remote_msg = NULL;
+	tmp_oqs_kex_ctx->oqs_remote_msg_len = 0;
+
+	/* Use PRNG provided by OpenSSH instad of liboqs's PRNG */
+	OQS_randombytes_custom_algorithm((void (*)(uint8_t *, size_t)) &arc4random_buf);
+
+	*oqs_kex_ctx = tmp_oqs_kex_ctx;
+	tmp_oqs_kex_ctx = NULL;
+
+out:
+	if (tmp_oqs_kex_ctx != NULL)
+		free(tmp_oqs_kex_ctx);
+
+	return r;
+}
+
+/*
+ * @brief Free memory allocated for oqs part of key exchange
+ */
+void
+oqs_free(OQS_KEX_CTX *oqs_kex_ctx) {
+
+	if (oqs_kex_ctx->oqs_local_msg != NULL) {
+		free(oqs_kex_ctx->oqs_local_msg);
+		oqs_kex_ctx->oqs_local_msg = NULL;
+	}
+	if (oqs_kex_ctx->oqs_remote_msg != NULL) {
+		free(oqs_kex_ctx->oqs_remote_msg);
+		oqs_kex_ctx->oqs_remote_msg = NULL;
+	}
+	if (oqs_kex_ctx->oqs_local_priv != NULL) {
+		explicit_bzero(oqs_kex_ctx->oqs_local_priv, oqs_kex_ctx->oqs_local_priv_len);
+		free(oqs_kex_ctx->oqs_local_priv);
+		oqs_kex_ctx->oqs_local_priv = NULL;
+	}
+	if (oqs_kex_ctx->oqs_method != NULL) {
+		free(oqs_kex_ctx->oqs_method);
+		oqs_kex_ctx->oqs_method = NULL;
+	}
+	if (oqs_kex_ctx->oqs_kem != NULL) {
+		OQS_KEM_free(oqs_kex_ctx->oqs_kem);
+		oqs_kex_ctx->oqs_kem = NULL;
+	}
+}
+
+/*
+ * @brief SSH hybrid key exchange init message name
+ */
+int
+oqs_ssh2_init_msg(const OQS_ALG *oqs_alg) {
+	return oqs_alg->ssh2_init_msg;
+}
+
+/*
+ * @brief SSH hybrid key exchange reply message name
+ */
+int
+oqs_ssh2_reply_msg(const OQS_ALG *oqs_alg) {
+	return oqs_alg->ssh2_reply_msg;
+}
+
+/*
+ * @brief Generates the client side part of the liboqs kex
+ */
+int
+oqs_client_gen(OQS_KEX_CTX *oqs_kex_ctx) {
+
+	OQS_KEM *oqs_kem = NULL;
+	int r = 0;
+
+	if ((oqs_kem = OQS_KEM_new(oqs_kex_ctx->oqs_method)) == NULL) {
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	oqs_kex_ctx->oqs_local_priv = NULL;
+	oqs_kex_ctx->oqs_local_msg = NULL;
+
+	oqs_kex_ctx->oqs_local_priv_len = oqs_kem->length_secret_key;
+	if ((oqs_kex_ctx->oqs_local_priv = malloc(oqs_kem->length_secret_key)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+
+	oqs_kex_ctx->oqs_local_msg_len = oqs_kem->length_public_key;
+	if ((oqs_kex_ctx->oqs_local_msg = malloc(oqs_kem->length_public_key)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+
+	/* Generate client side part of kex */
+	if (OQS_KEM_keypair(oqs_kem, oqs_kex_ctx->oqs_local_msg,
+		oqs_kex_ctx->oqs_local_priv) != OQS_SUCCESS) {
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	oqs_kex_ctx->oqs_kem = oqs_kem;
+	oqs_kem = NULL;
+
+out:
+	if (oqs_kem != NULL) {
+		OQS_KEM_free(oqs_kem);
+		free(oqs_kex_ctx->oqs_local_priv);
+		free(oqs_kex_ctx->oqs_local_msg);
+	}
+
+	return r;
+}
+
+/*
+ * @brief Deserialise liboqs specific parts of incoming packet
+ */
+int
+oqs_deserialise(struct ssh *ssh, OQS_KEX_CTX *oqs_kex_ctx,
+	enum oqs_client_or_server client_or_server) {
+
+	return sshpkt_get_string(ssh, &(oqs_kex_ctx->oqs_remote_msg),
+		&(oqs_kex_ctx->oqs_remote_msg_len));
+}
+
+/*
+ * @brief Serialise liboqs specific parts of outgoing packet
+ */
+int
+oqs_serialise(struct ssh *ssh, OQS_KEX_CTX *oqs_kex_ctx,
+	enum oqs_client_or_server client_or_server) {
+
+	return sshpkt_put_string(ssh, oqs_kex_ctx->oqs_local_msg,
+		oqs_kex_ctx->oqs_local_msg_len);
+}
+
+/*
+ * @brief Generates liboqs kex shared secret
+ */
+int
+oqs_client_shared_secret(OQS_KEX_CTX *oqs_kex_ctx,
+	u_char **oqs_shared_secret, size_t *oqs_shared_secret_len) {
+
+	uint8_t *tmp_oqs_shared_secret = NULL;
+	int r = 0;
+
+	if (oqs_kex_ctx->oqs_remote_msg_len != oqs_kex_ctx->oqs_kem->length_ciphertext) {
+		r = SSH_ERR_INVALID_FORMAT;
+		goto out;
+	}
+
+	if ((tmp_oqs_shared_secret = malloc(oqs_kex_ctx->oqs_kem->length_shared_secret)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+
+	/* Generate shared secret from client private key and server public key */
+	if (OQS_KEM_decaps(oqs_kex_ctx->oqs_kem, tmp_oqs_shared_secret,
+		oqs_kex_ctx->oqs_remote_msg, oqs_kex_ctx->oqs_local_priv) != OQS_SUCCESS) {
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	*oqs_shared_secret = (u_char *) tmp_oqs_shared_secret;
+	*oqs_shared_secret_len = oqs_kex_ctx->oqs_kem->length_shared_secret;
+
+	tmp_oqs_shared_secret = NULL;
+
+out:
+	if (tmp_oqs_shared_secret != NULL) {
+		explicit_bzero(tmp_oqs_shared_secret, oqs_kex_ctx->oqs_kem->length_shared_secret);
+		free(tmp_oqs_shared_secret);
+	}
+
+	return r;
+}
+
+/*
+ * @brief Generates server message and, simultanously generates
+ * the shared secret from server private key and client public key
+ */
+int
+oqs_server_gen_msg_and_ss(OQS_KEX_CTX *oqs_kex_ctx,
+	u_char **oqs_shared_secret, size_t *oqs_shared_secret_len) {
+
+	OQS_KEM *oqs_kem = NULL;
+	uint8_t *tmp_oqs_shared_secret = NULL, *tmp_oqs_local_msg = NULL;
+	int r = 0;
+
+	if ((oqs_kem = OQS_KEM_new(oqs_kex_ctx->oqs_method)) == NULL) {
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	if (oqs_kex_ctx->oqs_remote_msg_len != oqs_kem->length_public_key) {
+		r = SSH_ERR_INVALID_FORMAT;
+		goto out;
+	}
+
+	if ((tmp_oqs_local_msg = malloc(oqs_kem->length_ciphertext)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if ((tmp_oqs_shared_secret = malloc(oqs_kem->length_shared_secret)) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+
+	if (OQS_KEM_encaps(oqs_kem, tmp_oqs_local_msg, tmp_oqs_shared_secret,
+		oqs_kex_ctx->oqs_remote_msg) != OQS_SUCCESS) {
+				r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	*oqs_shared_secret = (u_char *) tmp_oqs_shared_secret;
+	*oqs_shared_secret_len = oqs_kem->length_shared_secret;
+	oqs_kex_ctx->oqs_local_msg = tmp_oqs_local_msg;
+	oqs_kex_ctx->oqs_local_msg_len = oqs_kem->length_ciphertext;
+
+	tmp_oqs_shared_secret = NULL;
+
+out:
+	if (oqs_kem != NULL) {
+		OQS_KEM_free(oqs_kem);
+	}
+	if (tmp_oqs_shared_secret != NULL) {
+		explicit_bzero(tmp_oqs_shared_secret, oqs_kem->length_shared_secret);
+		free(tmp_oqs_shared_secret);
+		free(tmp_oqs_local_msg);
+	}
+
+	return r;
+}
+
+#endif /* WITH_OQS */
--- /dev/null
+++ b/kexoqs.h
@@ -0,0 +1,96 @@
+/*
+* Copyright 2018 Amazon.com, Inc. or its affiliates. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef KEX_OQS_H
+#define KEX_OQS_H
+
+#include "includes.h"
+
+#ifdef WITH_OQS
+
+#include "packet.h"
+#include "oqs/oqs.h"
+
+#define HYBRID_ECDH_OQS_NAMESPACE_SUFFIX "@openquantumsafe.org"
+#define HYBRID_ECDH_OQS_KEX_SUFFIX(X) X HYBRID_ECDH_OQS_NAMESPACE_SUFFIX
+
+#define PQ_OQS_NAMESPACE_SUFFIX "@openquantumsafe.org"
+#define PQ_OQS_KEX_SUFFIX(X) X PQ_OQS_NAMESPACE_SUFFIX
+
+typedef enum oqs_client_or_server {
+	OQS_IS_CLIENT,
+	OQS_IS_SERVER
+} oqs_client_or_server_t;
+
+/*
+ * State information needed for the liboqs part
+ * of the hybrid key exchange
+ */
+typedef struct oqs_kex_ctx {
+
+	OQS_KEM *oqs_kem;	/* liboqs KEM algorithm context */
+	char *oqs_method;	/* liboqs algorithm name */
+	uint8_t *oqs_local_priv;	/* Local private key */
+	size_t oqs_local_priv_len;	/* Local private key length */
+	uint8_t *oqs_local_msg;		/* Local message */
+	size_t oqs_local_msg_len;	/* Local message length */
+	uint8_t *oqs_remote_msg;	/* Remote message. */
+	size_t oqs_remote_msg_len;	/* Remote message length */
+
+} OQS_KEX_CTX;
+
+/*
+ * liboqs algorithm information and stores message names used
+ * during the hybrid key exchange
+ */
+typedef struct oqs_alg {
+
+	char *kex_alg; 					/* SSH kex exchange name */
+	char *alg_name; 				/* liboqs algorithm name */
+	int ssh2_init_msg; 				/* Msg number/name mapping */
+	int ssh2_reply_msg; 			/* Msg number/name mapping */
+
+} OQS_ALG;
+
+/* Public client functions */
+int oqs_client_gen(OQS_KEX_CTX *oqs_kex_ctx);
+int oqs_client_extract(struct ssh *ssh, OQS_KEX_CTX *oqs_kex_ctx);
+int oqs_client_shared_secret(OQS_KEX_CTX *oqs_kex_ctx,
+	u_char **oqs_shared_secret, size_t *oqs_shared_secret_len);
+/* Public server  fucntions */
+int oqs_server_gen_msg_and_ss(OQS_KEX_CTX *oqs_kex_ctx,
+	u_char **oqs_shared_secret, size_t *oqs_shared_secret_len);
+/* Public shared functions */
+int oqs_init(OQS_KEX_CTX **oqs_kex_ctx, char *ssh_kex_name);
+void oqs_free(OQS_KEX_CTX *oqs_kex_ctx);
+const OQS_ALG * oqs_mapping(const char *ssh_kex_name);
+int oqs_ssh2_init_msg(const OQS_ALG *oqs_alg);
+int oqs_ssh2_reply_msg(const OQS_ALG *oqs_alg);
+int oqs_deserialise(struct ssh *ssh, OQS_KEX_CTX *oqs_kex_ctx,
+	oqs_client_or_server_t client_or_server);
+int oqs_serialise(struct ssh *ssh, OQS_KEX_CTX *oqs_kex_ctx,
+	oqs_client_or_server_t client_or_server);
+
+#endif /* WITH_OQS */
+#endif /* KEX_OQS_H */
--- /dev/null
+++ b/kexpq.h
@@ -0,0 +1,99 @@
+/*
+* Copyright 2018 Amazon.com, Inc. or its affiliates. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef KEX_PQ_H
+#define KEX_PQ_H
+
+#include "includes.h"
+
+#ifdef WITH_PQ_KEX
+
+#include "packet.h"
+#include "kexoqs.h"
+
+/* Hybrid key exchange context */
+typedef struct pq_kex_ctx {
+
+	const char *pq_kex_name;	/* Named SSH hybrid key exchange method */
+
+#ifdef WITH_OQS
+	/* libOQS specifics */
+	OQS_KEX_CTX *oqs_kex_ctx;	/* Liboqs context */
+#endif /* WITH_OQS */
+
+} PQ_KEX_CTX;
+
+/*
+ * Headers: Named PQ-only key exchange methods
+ */
+
+#ifdef WITH_OQS
+
+/* PQ-only liboqs */
+/* Exchange hash */
+int pq_oqs_hash (
+	int hash_alg,
+	const char *client_version_string,
+	const char *server_version_string,
+	const struct sshbuf *ckexinit,
+	const struct sshbuf *skexinit,
+	const u_char *serverhostkeyblob, size_t serverhostkeyblob_len,
+	const uint8_t *oqs_client_public, size_t oqs_client_public_len,
+	const uint8_t *oqs_server_public, size_t oqs_server_public_len,
+	const u_char *oqs_shared_secret, size_t oqs_shared_secret_len,
+	u_char *hash, size_t *hash_len);
+/* Shared functions */
+int pq_oqs_init(PQ_KEX_CTX **pq_kex_ctx, char *pq_kex_name);
+void pq_oqs_free(PQ_KEX_CTX *pq_kex_ctx);
+/* Client specific function */
+int  pq_oqs_client(struct ssh *);
+/* Server specific function */
+int  pq_oqs_server(struct ssh *);
+#endif /* WITH_OQS */
+#endif /* WITH_PQ_KEX */
+
+/* Helper functions to register PQ-only key exchange call-backs */
+typedef int (*pq_func_cb)(struct ssh *);
+
+static inline pq_func_cb
+get_pq_oqs_client_cb() {
+
+#if defined(WITH_OQS) && defined(WITH_PQ_KEX)
+    return pq_oqs_client;
+#else
+    return NULL;
+#endif
+}
+
+static inline pq_func_cb
+get_pq_oqs_server_cb() {
+
+#if defined(WITH_OQS) && defined(WITH_PQ_KEX)
+    return pq_oqs_server;
+#else
+    return NULL;
+#endif
+}
+
+#endif /* KEX_PQ_H */
--- /dev/null
+++ b/kexpqoqs.c
@@ -0,0 +1,167 @@
+/*
+* Copyright 2018 Amazon.com, Inc. or its affiliates. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "includes.h"
+
+#if defined(WITH_OQS) && defined(WITH_PQ_KEX)
+
+#include "compat.h"
+#include "ssherr.h"
+#include "digest.h"
+#include "ssh2.h"
+#include "kexpq.h"
+#include "sshbuf.h"
+
+/*
+ * @brief Initialise values of PQ-only key exchange context
+ *
+ */
+int
+pq_oqs_init(PQ_KEX_CTX **pq_kex_ctx, char *pq_kex_name) {
+
+	PQ_KEX_CTX *buf_pq_kex_ctx = NULL;
+	OQS_KEX_CTX *buf_oqs_kex_ctx = NULL;
+	int alloc_pq_kex_ctx = 1; /* (0) reuse PQ-only struct (1) allocated PQ-only struct */
+	int r = 0;
+
+	/*
+	 * If rekeying is performed we don't want to allocate again.
+	 * Memory pointed to by *pq_kex_ctx is not free'ed before
+	 * the program terminates.
+	 */
+	if (*pq_kex_ctx != NULL) {
+		alloc_pq_kex_ctx = 0;
+		buf_pq_kex_ctx = *pq_kex_ctx;
+	}
+
+	if (alloc_pq_kex_ctx == 1) {
+		if ((buf_pq_kex_ctx = calloc(sizeof(*(buf_pq_kex_ctx)), 1)) == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+	}
+
+	buf_pq_kex_ctx->pq_kex_name = pq_kex_name;
+	buf_pq_kex_ctx->oqs_kex_ctx = NULL;
+
+	if ((r = oqs_init(&buf_oqs_kex_ctx, pq_kex_name)) != 0)
+		goto out;
+
+	buf_pq_kex_ctx->oqs_kex_ctx = buf_oqs_kex_ctx;
+	buf_oqs_kex_ctx = NULL;
+	*pq_kex_ctx = buf_pq_kex_ctx;
+	buf_pq_kex_ctx = NULL;
+
+out:
+	if (buf_pq_kex_ctx != NULL) {
+		if (buf_pq_kex_ctx->oqs_kex_ctx != NULL)
+			oqs_free(buf_pq_kex_ctx->oqs_kex_ctx);
+		/*
+		 * If reusing, buf_pq_kex_ctx will point to the
+		 * reused memory and this wil eventually be freed
+		 * by kex_free()
+		 */
+		if (alloc_pq_kex_ctx == 1)
+			free(buf_pq_kex_ctx);
+	}
+	if (buf_oqs_kex_ctx != NULL)
+		oqs_free(buf_oqs_kex_ctx);
+
+	return r;
+}
+
+/*
+ * @brief Free memory allocated PQ-only key exchange liboqs
+ */
+void
+pq_oqs_free(PQ_KEX_CTX *pq_kex_ctx) {
+
+	if (pq_kex_ctx->oqs_kex_ctx != NULL) {
+		oqs_free(pq_kex_ctx->oqs_kex_ctx);
+		free(pq_kex_ctx->oqs_kex_ctx);
+		pq_kex_ctx->oqs_kex_ctx = NULL;
+	}
+}
+
+/*
+ * @brief Computes the exchange hash for liboqs PQ-only key exchange methods
+ */
+int
+pq_oqs_hash (
+	int hash_alg,
+	const char *client_version_string,
+	const char *server_version_string,
+	const struct sshbuf *ckexinit,
+	const struct sshbuf *skexinit,
+	const u_char *serverhostkeyblob, size_t serverhostkeyblob_len,
+	const uint8_t *oqs_client_public, size_t oqs_client_public_len,
+	const uint8_t *oqs_server_public, size_t oqs_server_public_len,
+	const u_char *oqs_shared_secret, size_t oqs_shared_secret_len,
+	u_char *hash, size_t *hash_len) {
+
+	struct sshbuf *hash_buf = NULL;
+	int r = 0;
+
+	if (*hash_len < ssh_digest_bytes(hash_alg)) {
+		r = SSH_ERR_INVALID_ARGUMENT;
+		goto out;
+	}
+	if ((hash_buf = sshbuf_new()) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	/* We assume that sshbuf_put_*() correctly handles NULL parameters */
+	if ((r = sshbuf_put_cstring(hash_buf, client_version_string)) != 0 ||
+	    (r = sshbuf_put_cstring(hash_buf, server_version_string)) != 0 ||
+	    /* kexinit messages: fake header: len+SSH2_MSG_KEXINIT */
+	    (r = sshbuf_put_u32(hash_buf, sshbuf_len(ckexinit)+1)) != 0 ||
+	    (r = sshbuf_put_u8(hash_buf, SSH2_MSG_KEXINIT)) != 0 ||
+	    (r = sshbuf_putb(hash_buf, ckexinit)) != 0 ||
+	    (r = sshbuf_put_u32(hash_buf, sshbuf_len(skexinit)+1)) != 0 ||
+	    (r = sshbuf_put_u8(hash_buf, SSH2_MSG_KEXINIT)) != 0 ||
+	    (r = sshbuf_putb(hash_buf, skexinit)) != 0 ||
+	    (r = sshbuf_put_string(hash_buf, serverhostkeyblob, serverhostkeyblob_len)) != 0)
+		goto out;
+	if ((r = sshbuf_put_string(hash_buf, oqs_client_public,
+		oqs_client_public_len)) != 0 ||
+	    (r = sshbuf_put_string(hash_buf, oqs_server_public,
+	    oqs_server_public_len)) != 0 ||
+	    (r = sshbuf_put_string(hash_buf, oqs_shared_secret, oqs_shared_secret_len)) != 0)
+		goto out;
+
+	if (ssh_digest_buffer(hash_alg, hash_buf, hash, *hash_len) != 0) {
+		r = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+
+	*hash_len = ssh_digest_bytes(hash_alg);
+
+out:
+	if (hash_buf != NULL)
+		sshbuf_free(hash_buf);
+
+	return r;
+}
+
+#endif /* defined(WITH_OQS) && defined(WITH_PQ_KEX) */
--- /dev/null
+++ b/kexpqoqsc.c
@@ -0,0 +1,332 @@
+/*
+* Copyright 2018 Amazon.com, Inc. or its affiliates. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "includes.h"
+
+#if defined(WITH_OQS) && defined(WITH_PQ_KEX)
+
+#include <signal.h>
+#include <string.h>
+
+#include "sshkey.h"
+#include "digest.h"
+#include "ssherr.h"
+#include "kex.h"
+#include "ssh2.h"
+#include "dispatch.h"
+#include "packet.h"
+#include "sshbuf.h"
+#include "log.h"
+
+/* Client private */
+static int
+input_pq_oqs_reply(int type, u_int32_t seq, struct ssh *ssh);
+static int
+pq_oqs_s2c_deserialise(struct ssh *ssh, PQ_KEX_CTX *pq_kex_ctx,
+	struct sshkey **server_host_key, u_char **server_host_key_blob,
+	size_t *server_host_key_blob_len, u_char **signature, size_t *signature_len);
+static int
+pq_oqs_c2s_serialise(struct ssh *ssh, PQ_KEX_CTX *pq_kex_ctx);
+static int
+pq_oqs_verify_hostkey(struct ssh *ssh,
+	struct sshkey *server_host_key);
+static int
+pq_oqs_deserialise_hostkey(struct ssh *ssh, struct sshkey **server_host_key,
+	u_char **server_host_key_blob, size_t *server_host_key_blob_len);
+
+/*
+ * @brief Logic that handles packet deserialisation of the kex packet from server
+ * to client when using a liboqs key exchange method
+ */
+static int
+pq_oqs_s2c_deserialise(struct ssh *ssh, PQ_KEX_CTX *pq_kex_ctx,
+	struct sshkey **server_host_key, u_char **server_host_key_blob,
+	size_t *server_host_key_blob_len, u_char **signature, size_t *signature_len) {
+
+	int r = 0;
+
+	/*
+	 * pq_oqs_server_hostkey() immediately verify
+	 * the host key after extracting it
+	 */
+	if ((r = pq_oqs_deserialise_hostkey(ssh, server_host_key,
+		server_host_key_blob, server_host_key_blob_len)) != 0 ||
+		(r = oqs_deserialise(ssh, pq_kex_ctx->oqs_kex_ctx, OQS_IS_CLIENT) != 0) ||
+		(r = sshpkt_get_string(ssh, signature, signature_len)) != 0)
+		goto out;
+
+	r = sshpkt_get_end(ssh);
+
+	out:
+		return r;
+}
+
+/*
+ * @brief Logic that handles packet serialisation of the kex packet to client
+ * from server when using a pq-only liboqs key exchange method
+ */
+static int
+pq_oqs_c2s_serialise(struct ssh *ssh, PQ_KEX_CTX *pq_kex_ctx) {
+
+	return oqs_serialise(ssh, pq_kex_ctx->oqs_kex_ctx, OQS_IS_CLIENT);
+}
+
+/*
+ * @brief Verifies host key
+ */
+static int
+pq_oqs_verify_hostkey(struct ssh *ssh,
+	struct sshkey *server_host_key) {
+
+	struct kex *kex = NULL;
+	int r = 0;
+
+	kex = ssh->kex;
+
+	/* If we can't verify the host key then abort */
+	if (kex->verify_host_key == NULL) {
+		r = SSH_ERR_INVALID_ARGUMENT;
+		goto out;
+	}
+
+	if (server_host_key->type != kex->hostkey_type ||
+	    (kex->hostkey_type == KEY_ECDSA &&
+	    server_host_key->ecdsa_nid != kex->hostkey_nid)) {
+		r = SSH_ERR_KEY_TYPE_MISMATCH;
+		goto out;
+	}
+
+	/* Verify host key */
+	if (kex->verify_host_key(server_host_key, ssh) == -1) {
+		r = SSH_ERR_SIGNATURE_INVALID;
+		goto out;
+	}
+
+out:
+	return r;
+}
+
+/*
+ * @brief Extracts host key from incoming packet and
+ * verifies it
+ */
+static int
+pq_oqs_deserialise_hostkey(struct ssh *ssh,
+	struct sshkey **server_host_key, u_char **server_host_key_blob,
+	size_t *server_host_key_blob_len) {
+
+	struct sshkey *tmp_server_host_key = NULL;
+	u_char *tmp_server_host_key_blob = NULL;
+	size_t tmp_server_host_key_blob_len = 0;
+	int r = 0;
+
+	/* Extract host key from packet */
+	if ((r = sshpkt_get_string(ssh, &tmp_server_host_key_blob,
+		&tmp_server_host_key_blob_len)) != 0 ||
+		(r = sshkey_from_blob(tmp_server_host_key_blob,
+		tmp_server_host_key_blob_len, &tmp_server_host_key)) != 0)
+		goto out;
+
+	/* Immediately verify host key */
+	if ((r = pq_oqs_verify_hostkey(ssh,
+		tmp_server_host_key)) != 0)
+		goto out;
+
+	*server_host_key = tmp_server_host_key;
+	*server_host_key_blob = tmp_server_host_key_blob;
+	*server_host_key_blob_len = tmp_server_host_key_blob_len;
+
+	tmp_server_host_key = NULL;
+	tmp_server_host_key_blob = NULL;
+
+out:
+	if (tmp_server_host_key_blob != NULL)
+		free(tmp_server_host_key_blob);
+	if (tmp_server_host_key != NULL)
+		sshkey_free(tmp_server_host_key);
+
+	return r;
+}
+
+/*
+ * @brief Handles the first client liboqs PQ-only key exchange message
+ */
+int
+pq_oqs_client(struct ssh *ssh) {
+
+	PQ_KEX_CTX *pq_kex_ctx = NULL;
+	OQS_KEX_CTX *oqs_kex_ctx = NULL;
+	const OQS_ALG *oqs_alg = NULL;
+	int r = 0;
+
+	/* Test whether we are prepared to handle this packet */
+	if (ssh == NULL ||
+		ssh->kex == NULL ||
+		(pq_kex_ctx = ssh->kex->pq_kex_ctx) == NULL ||
+		(oqs_kex_ctx = pq_kex_ctx->oqs_kex_ctx) == NULL) {
+
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	if ((oqs_alg = oqs_mapping(pq_kex_ctx->pq_kex_name)) == NULL) {
+		error("Unsupported libOQS algorithm \"%.100s\"", pq_kex_ctx->pq_kex_name);
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	/* Generate oqs public key */
+	if ((r = oqs_client_gen(oqs_kex_ctx)) != 0)
+		goto out;
+
+	/* Send client PQ-only liboqs packet to server */
+	if ((r = sshpkt_start(ssh, oqs_ssh2_init_msg(oqs_alg))) != 0 ||
+		(r = pq_oqs_c2s_serialise(ssh, pq_kex_ctx)) != 0 ||
+	    (r = sshpkt_send(ssh)) != 0)
+		goto out;
+
+	/* Set handler for recieving server reply */
+	debug("expecting %i msg", oqs_ssh2_reply_msg(oqs_alg));
+	ssh_dispatch_set(ssh, oqs_ssh2_reply_msg(oqs_alg),
+		&input_pq_oqs_reply);
+
+out:
+	if (r != 0)
+		pq_oqs_free(pq_kex_ctx);
+
+	return r;
+}
+
+/*
+ * @brief Handles the liboqs PQ-only key exchange reply from server
+ */
+static int
+input_pq_oqs_reply(int type, u_int32_t seq, struct ssh *ssh) {
+
+	PQ_KEX_CTX *pq_kex_ctx = NULL;
+	OQS_KEX_CTX *oqs_kex_ctx = NULL;
+	struct sshkey *server_host_key = NULL;
+	struct sshbuf *shared_secret_ssh_buf = NULL;
+	struct kex *kex = NULL;
+	u_char *server_host_key_blob = NULL;
+	u_char *signature = NULL;
+	u_char hash[SSH_DIGEST_MAX_LENGTH];
+	u_char *oqs_shared_secret = NULL;
+	size_t oqs_shared_secret_len = 0;
+	size_t signature_len = 0;
+	size_t server_host_key_blob_len = 0;
+	size_t hash_len = 0;
+	int r = 0;
+
+	/* Test whether we are prepared to handle this packet */
+	if (ssh == NULL ||
+		(kex = ssh->kex) == NULL ||
+		(pq_kex_ctx = kex->pq_kex_ctx) == NULL ||
+		(oqs_kex_ctx = pq_kex_ctx->oqs_kex_ctx) == NULL) {
+
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	/* Extract from server to client packet */
+	if ((r = pq_oqs_s2c_deserialise(ssh, pq_kex_ctx,
+		&server_host_key, &server_host_key_blob,
+		&server_host_key_blob_len, &signature, &signature_len)) != 0)
+		goto out;
+
+	if ((r = oqs_client_shared_secret(oqs_kex_ctx, &oqs_shared_secret,
+		&oqs_shared_secret_len)) != 0)
+		goto out;
+
+	/*
+	 * Compute exchange hash
+	 * kex->my is client
+	 * kex->peer is server
+	 */
+	hash_len = sizeof(hash);
+	if ((r = pq_oqs_hash(
+		kex->hash_alg,
+		kex->client_version_string,
+		kex->server_version_string,
+		kex->my,
+		kex->peer,
+		server_host_key_blob, server_host_key_blob_len,
+		oqs_kex_ctx->oqs_local_msg, oqs_kex_ctx->oqs_local_msg_len,
+		oqs_kex_ctx->oqs_remote_msg, oqs_kex_ctx->oqs_remote_msg_len,
+		oqs_shared_secret, oqs_shared_secret_len,
+		hash, &hash_len)) != 0)
+		goto out;
+
+	/* Verify signature over exchange hash */
+	if ((r = sshkey_verify(server_host_key, signature, signature_len, hash,
+		hash_len, kex->hostkey_alg, ssh->compat))!= 0)
+		goto out;
+
+	/* Save session id */
+	if (kex->session_id == NULL) {
+		kex->session_id_len = hash_len;
+		kex->session_id = malloc(kex->session_id_len);
+		if (kex->session_id == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		memcpy(kex->session_id, hash, kex->session_id_len);
+	}
+
+	/*
+	 * sshbuf_put_string() will encode the shared secret as a mpint
+	 * as required by SSH spec (RFC4253)
+	 */
+	if ((shared_secret_ssh_buf = sshbuf_new()) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if ((r = sshbuf_put_string(shared_secret_ssh_buf, (const u_char *) oqs_shared_secret,
+		oqs_shared_secret_len)) != 0)
+		goto out;
+
+	if ((r = kex_derive_keys(ssh, hash, hash_len, shared_secret_ssh_buf)) == 0)
+		r = kex_send_newkeys(ssh);
+
+out:
+	explicit_bzero(hash, sizeof(hash));
+	pq_oqs_free(pq_kex_ctx);
+	/* sshbuf_free zeroises memory */
+	if (shared_secret_ssh_buf != NULL)
+		sshbuf_free(shared_secret_ssh_buf);
+	if (server_host_key != NULL)
+		sshkey_free(server_host_key);
+	if (oqs_shared_secret != NULL) {
+		explicit_bzero(oqs_shared_secret, oqs_shared_secret_len);
+		free(oqs_shared_secret);
+	}
+	if (server_host_key_blob != NULL)
+		free(server_host_key_blob);
+	if (signature != NULL)
+		free(signature);
+
+	return r;
+}
+
+#endif /* defined(WITH_OQS) && defined(WITH_PQ_KEX) */
--- /dev/null
+++ b/kexpqoqss.c
@@ -0,0 +1,315 @@
+/*
+* Copyright 2018 Amazon.com, Inc. or its affiliates. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "includes.h"
+
+#if defined(WITH_OQS) && defined(WITH_PQ_KEX)
+
+#include <signal.h>
+#include <string.h>
+
+#include "sshkey.h"
+#include "digest.h"
+#include "ssherr.h"
+#include "kex.h"
+#include "ssh2.h"
+#include "dispatch.h"
+#include "packet.h"
+#include "sshbuf.h"
+#include "log.h"
+
+/* Server private */
+static int
+pq_oqs_c2s_deserialise(struct ssh *ssh, PQ_KEX_CTX *pq_kex_ctx);
+static int
+pq_oqs_s2c_serialise(struct ssh *ssh, PQ_KEX_CTX *pq_kex_ctx,
+	u_char *server_host_key_blob, size_t server_host_key_blob_len,
+	u_char *signature, size_t signature_len);
+static int
+pq_oqs_server_hostkey(struct ssh *ssh, struct sshkey **server_host_public,
+	struct sshkey **server_host_private, u_char **server_host_key_blob,
+	size_t *server_host_key_blob_len);
+static int
+input_pq_oqs_init(int type, u_int32_t seq, struct ssh *ssh);
+
+/*
+ * @brief Logic that handles packet deserialisation of the client kex message
+ * when using a liboqs kex
+ */
+static int
+pq_oqs_c2s_deserialise(struct ssh *ssh,
+	PQ_KEX_CTX *pq_kex_ctx) {
+
+	int r = 0;
+
+	if ((r = oqs_deserialise(ssh, pq_kex_ctx->oqs_kex_ctx, OQS_IS_SERVER) != 0))
+		goto out;
+
+	r = sshpkt_get_end(ssh);
+
+out:
+	return r;
+}
+
+/*
+ * @brief Logic that handles packet serialisation of the client kex message
+ * when using a liboqs kex
+ */
+static int
+pq_oqs_s2c_serialise(struct ssh *ssh,
+	PQ_KEX_CTX *pq_kex_ctx, u_char *server_host_key_blob,
+	size_t server_host_key_blob_len, u_char *signature,
+	size_t signature_len) {
+
+	int r = 0;
+
+	if ((r = sshpkt_put_string(ssh, server_host_key_blob,
+			server_host_key_blob_len)) != 0 ||
+		(r = oqs_serialise(ssh, pq_kex_ctx->oqs_kex_ctx, OQS_IS_SERVER)) != 0)
+		goto out;
+
+	r = sshpkt_put_string(ssh, signature, signature_len);
+
+out:
+	return r;
+}
+
+/*
+ * @brief Retrieves host key
+ */
+static int
+pq_oqs_server_hostkey(struct ssh *ssh, struct sshkey **server_host_public,
+	struct sshkey **server_host_private, u_char **server_host_key_blob,
+	size_t *server_host_key_blob_len) {
+
+	struct kex *kex = NULL;
+	struct sshkey *tmp_server_host_public = NULL;
+	struct sshkey *tmp_server_host_private = NULL;
+	u_char *tmp_server_host_key_blob = NULL;
+	size_t tmp_server_host_key_blob_len = 0;
+	int r = 0;
+
+	kex = ssh->kex;
+
+	/* Retrieve host public and private key */
+	if (kex->load_host_public_key == NULL ||
+	    kex->load_host_private_key == NULL) {
+		r = SSH_ERR_INVALID_ARGUMENT;
+		goto out;
+	}
+	if (((tmp_server_host_public = kex->load_host_public_key(kex->hostkey_type,
+	    kex->hostkey_nid, ssh)) == NULL) ||
+	    (tmp_server_host_private = kex->load_host_private_key(kex->hostkey_type,
+	    kex->hostkey_nid, ssh)) == NULL) {
+		r = SSH_ERR_NO_HOSTKEY_LOADED;
+		goto out;
+	}
+
+	/* Write to blob to prepare transfer over the wire */
+	if ((r = sshkey_to_blob(tmp_server_host_public, &tmp_server_host_key_blob,
+	    &tmp_server_host_key_blob_len)) != 0)
+		goto out;
+
+	*server_host_public = tmp_server_host_public;
+	*server_host_private = tmp_server_host_private;
+	*server_host_key_blob = tmp_server_host_key_blob;
+	*server_host_key_blob_len = tmp_server_host_key_blob_len;
+
+	tmp_server_host_public = NULL;
+	tmp_server_host_private = NULL;
+	tmp_server_host_key_blob = NULL;
+
+out:
+	return r;
+}
+
+/*
+ * @brief Initialise server to receive liboqs PQ-only key exchange
+ * method client-side message
+ */
+int
+pq_oqs_server(struct ssh *ssh) {
+
+	PQ_KEX_CTX *pq_kex_ctx = NULL;
+	const OQS_ALG *oqs_alg = NULL;
+	int r = 0;
+
+	/* Test whether we are prepared to handle this packet */
+	if (ssh == NULL ||
+		ssh->kex == NULL ||
+		(pq_kex_ctx = ssh->kex->pq_kex_ctx) == NULL) {
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	if ((oqs_alg = oqs_mapping(pq_kex_ctx->pq_kex_name)) == NULL) {
+		error("Unsupported libOQS algorithm \"%.100s\"", pq_kex_ctx->pq_kex_name);
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	debug("expecting %i msg", oqs_ssh2_init_msg(oqs_alg));
+	ssh_dispatch_set(ssh, oqs_ssh2_init_msg(oqs_alg),
+		&input_pq_oqs_init);
+
+out:
+	return r;
+}
+
+/*
+ * @brief Handles the client key exchange message when using a liboqs
+ * PQ-only key exchange method
+ */
+static int
+input_pq_oqs_init(int type, u_int32_t seq,
+	struct ssh *ssh) {
+
+	PQ_KEX_CTX *pq_kex_ctx = NULL;
+	OQS_KEX_CTX *oqs_kex_ctx = NULL;
+	const OQS_ALG *oqs_alg = NULL;
+	struct kex *kex = NULL;
+	struct sshkey *server_host_public = NULL;
+	struct sshkey *server_host_private = NULL;
+	struct sshbuf *shared_secret_ssh_buf = NULL;
+	u_char *oqs_shared_secret = NULL;
+	u_char *server_host_key_blob = NULL;
+	u_char *signature = NULL;
+	u_char hash[SSH_DIGEST_MAX_LENGTH];
+	size_t server_host_key_blob_len = 0;
+	size_t signature_len = 0;
+	size_t hash_len = 0;
+	size_t oqs_shared_secret_len = 0;
+	int r = 0;
+
+	/* Test whether we are prepared to handle this packet */
+	if (ssh == NULL ||
+		(kex = ssh->kex) == NULL ||
+		(pq_kex_ctx = kex->pq_kex_ctx) == NULL ||
+		(oqs_kex_ctx = pq_kex_ctx->oqs_kex_ctx) == NULL) {
+
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	/* Load public and private host key */
+	if ((r = pq_oqs_server_hostkey(ssh, &server_host_public,
+		&server_host_private, &server_host_key_blob,
+		&server_host_key_blob_len)) != 0)
+		goto out;
+
+	/* Deserialise client to server packet */
+	if ((r = pq_oqs_c2s_deserialise(ssh, pq_kex_ctx)) != 0)
+		goto out;
+
+	/*
+	 * libOQS API only supports generating the liboqs public key
+	 * msg and shared secret simultaneously.
+	 */
+	if ((r = oqs_server_gen_msg_and_ss(oqs_kex_ctx,
+		&oqs_shared_secret, &oqs_shared_secret_len)) != 0)
+		goto out;
+
+	/*
+	 * Compute exchange hash
+	 * kex->peer is client
+	 * kex->my is server
+	 */
+	hash_len = sizeof(hash);
+	if ((r = pq_oqs_hash(
+		kex->hash_alg,
+		kex->client_version_string,
+		kex->server_version_string,
+		kex->peer,
+		kex->my,
+		server_host_key_blob, server_host_key_blob_len,
+		oqs_kex_ctx->oqs_remote_msg, oqs_kex_ctx->oqs_remote_msg_len,
+		oqs_kex_ctx->oqs_local_msg, oqs_kex_ctx->oqs_local_msg_len,
+		oqs_shared_secret, oqs_shared_secret_len,
+		hash, &hash_len)) !=0)
+		goto out;
+
+	/* Save session id */
+	if (kex->session_id == NULL) {
+		kex->session_id_len = hash_len;
+		kex->session_id = malloc(kex->session_id_len);
+		if (kex->session_id == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		memcpy(kex->session_id, hash, kex->session_id_len);
+	}
+
+	/* Sign exchange hash */
+	if ((r = kex->sign(server_host_private, server_host_public,
+		&signature, &signature_len, hash, hash_len, kex->hostkey_alg,
+		ssh->compat)) < 0)
+		goto out;
+
+	if ((oqs_alg = oqs_mapping(pq_kex_ctx->pq_kex_name)) == NULL) {
+		error("Unsupported libOQS algorithm \"%.100s\"", pq_kex_ctx->pq_kex_name);
+		r = SSH_ERR_INTERNAL_ERROR;
+		goto out;
+	}
+
+	/* Send pq-only liboqs server to client packet */
+	if ((r = sshpkt_start(ssh, oqs_ssh2_reply_msg(oqs_alg))) != 0 ||
+		(r = pq_oqs_s2c_serialise(ssh, pq_kex_ctx, server_host_key_blob,
+			server_host_key_blob_len, signature, signature_len)) != 0 ||
+		(r = sshpkt_send(ssh)) != 0)
+		goto out;
+
+	/*
+	 * sshbuf_put_string() will encode the shared secret as a mpint
+	 * as required by SSH spec (RFC4253)
+	 */
+	if ((shared_secret_ssh_buf = sshbuf_new()) == NULL) {
+		r = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	if ((r = sshbuf_put_string(shared_secret_ssh_buf, (const u_char *) oqs_shared_secret,
+		oqs_shared_secret_len)) != 0)
+		goto out;
+
+	if ((r = kex_derive_keys(ssh, hash, hash_len, shared_secret_ssh_buf)) == 0)
+		r = kex_send_newkeys(ssh);
+
+out:
+	explicit_bzero(hash, sizeof(hash));
+	pq_oqs_free(pq_kex_ctx);
+	/* sshbuf_free zeroises memory */
+	if (shared_secret_ssh_buf != NULL)
+		sshbuf_free(shared_secret_ssh_buf);
+	if (oqs_shared_secret != NULL) {
+		explicit_bzero(oqs_shared_secret, oqs_shared_secret_len);
+		free(oqs_shared_secret);
+	}
+	if (server_host_key_blob != NULL)
+		free(server_host_key_blob);
+	if (signature != NULL)
+		free(signature);
+
+	return r;
+}
+
+#endif /* defined(WITH_OQS) && defined(WITH_PQ_KEX) */
--- a/monitor.c
+++ b/monitor.c
@@ -1738,8 +1738,10 @@
 		kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;
 # ifdef OPENSSL_HAS_ECC
 		kex->kex[KEX_ECDH_SHA2] = kexecdh_server;
+		kex->kex[KEX_HY_ECDH_OQS] = get_hybrid_ecdh_oqs_server_cb();
 # endif
 #endif /* WITH_OPENSSL */
+		kex->kex[KEX_PQ_OQS] = get_pq_oqs_server_cb();
 		kex->kex[KEX_C25519_SHA256] = kexc25519_server;
 #ifdef GSSAPI
 		if (options.gss_keyex) {
--- a/monitor_wrap.c
+++ b/monitor_wrap.c
@@ -151,7 +151,10 @@
 		fatal("%s: read: %s", __func__, strerror(errno));
 	}
 	msg_len = PEEK_U32(buf);
-	if (msg_len > 256 * 1024)
+	/* OQS note: We have increased the limit below
+	 * from (256 * 1024) to (65536 * 1024), so as to
+	 * support algorithms such as Rainbow and McEliece */
+	if (msg_len > 65536 * 1024)
 		fatal("%s: read: bad msg_len %d", __func__, msg_len);
 	sshbuf_reset(m);
 	if ((r = sshbuf_reserve(m, msg_len, &p)) != 0)
--- a/msg.c
+++ b/msg.c
@@ -77,7 +77,10 @@
 		return (-1);
 	}
 	msg_len = get_u32(buf);
-	if (msg_len > 256 * 1024) {
+	/* OQS note: We have increased the limit below
+	 * from (256 * 1024) to (65536 * 1024), so as to
+	 * support algorithms such as Rainbow and McEliece */
+	if (msg_len > 65536 * 1024) {
 		error("ssh_msg_recv: read: bad msg_len %u", msg_len);
 		return (-1);
 	}
--- a/myproposal.h
+++ b/myproposal.h
@@ -28,7 +28,315 @@
 
 /* conditional algorithm support */
 
+#if defined(WITH_OQS) && defined(WITH_PQ_KEX)
+#define PQ_OQS_KEX_METHOD(X) PQ_OQS_KEX_SUFFIX(X) ","
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_PQ_KEXS_START
+#ifdef HAVE_BIKE
+#define KEX_PQ_METHOD_BIKE \
+    PQ_OQS_KEX_METHOD("bike1-l1-cpa-sha384") \
+    PQ_OQS_KEX_METHOD("bike1-l3-cpa-sha384") \
+    PQ_OQS_KEX_METHOD("bike1-l1-fo-sha384") \
+    PQ_OQS_KEX_METHOD("bike1-l3-fo-sha384")
+#else
+#define KEX_PQ_METHOD_BIKE ""
+#endif /* HAVE_BIKE */
+#ifdef HAVE_CLASSIC_MCELIECE
+#define KEX_PQ_METHOD_CLASSIC_MCELIECE \
+    PQ_OQS_KEX_METHOD("classic-mceliece-348864-sha384") \
+    PQ_OQS_KEX_METHOD("classic-mceliece-348864f-sha384") \
+    PQ_OQS_KEX_METHOD("classic-mceliece-460896-sha384") \
+    PQ_OQS_KEX_METHOD("classic-mceliece-460896f-sha384") \
+    PQ_OQS_KEX_METHOD("classic-mceliece-6688128-sha384") \
+    PQ_OQS_KEX_METHOD("classic-mceliece-6688128f-sha384") \
+    PQ_OQS_KEX_METHOD("classic-mceliece-6960119-sha384") \
+    PQ_OQS_KEX_METHOD("classic-mceliece-6960119f-sha384") \
+    PQ_OQS_KEX_METHOD("classic-mceliece-8192128-sha384") \
+    PQ_OQS_KEX_METHOD("classic-mceliece-8192128f-sha384")
+#else
+#define KEX_PQ_METHOD_CLASSIC_MCELIECE ""
+#endif /* HAVE_CLASSIC_MCELIECE */
+#ifdef HAVE_FRODO
+#define KEX_PQ_METHOD_FRODO \
+    PQ_OQS_KEX_METHOD("frodo-640-aes-sha384") \
+    PQ_OQS_KEX_METHOD("frodo-640-shake-sha384") \
+    PQ_OQS_KEX_METHOD("frodo-976-aes-sha384") \
+    PQ_OQS_KEX_METHOD("frodo-976-shake-sha384") \
+    PQ_OQS_KEX_METHOD("frodo-1344-aes-sha384") \
+    PQ_OQS_KEX_METHOD("frodo-1344-shake-sha384")
+#else
+#define KEX_PQ_METHOD_FRODO ""
+#endif /* HAVE_FRODO */
+#ifdef HAVE_KYBER
+#define KEX_PQ_METHOD_KYBER \
+    PQ_OQS_KEX_METHOD("kyber-512-sha384") \
+    PQ_OQS_KEX_METHOD("kyber-768-sha384") \
+    PQ_OQS_KEX_METHOD("kyber-1024-sha384") \
+    PQ_OQS_KEX_METHOD("kyber-512-90s-sha384") \
+    PQ_OQS_KEX_METHOD("kyber-768-90s-sha384") \
+    PQ_OQS_KEX_METHOD("kyber-1024-90s-sha384")
+#else
+#define KEX_PQ_METHOD_KYBER ""
+#endif /* HAVE_KYBER */
+#ifdef HAVE_NEWHOPE
+#define KEX_PQ_METHOD_NEWHOPE \
+    PQ_OQS_KEX_METHOD("newhope-512-sha384") \
+    PQ_OQS_KEX_METHOD("newhope-1024-sha384")
+#else
+#define KEX_PQ_METHOD_NEWHOPE ""
+#endif /* HAVE_NEWHOPE */
+#ifdef HAVE_NTRU
+#define KEX_PQ_METHOD_NTRU \
+    PQ_OQS_KEX_METHOD("ntru-hps-2048-509-sha384") \
+    PQ_OQS_KEX_METHOD("ntru-hps-2048-677-sha384") \
+    PQ_OQS_KEX_METHOD("ntru-hrss-701-sha384") \
+    PQ_OQS_KEX_METHOD("ntru-hps-4096-821-sha384")
+#else
+#define KEX_PQ_METHOD_NTRU ""
+#endif /* HAVE_NTRU */
+#ifdef HAVE_SABER
+#define KEX_PQ_METHOD_SABER \
+    PQ_OQS_KEX_METHOD("saber-lightsaber-sha384") \
+    PQ_OQS_KEX_METHOD("saber-saber-sha384") \
+    PQ_OQS_KEX_METHOD("saber-firesaber-sha384")
+#else
+#define KEX_PQ_METHOD_SABER ""
+#endif /* HAVE_SABER */
+#ifdef HAVE_SIDH
+#define KEX_PQ_METHOD_SIDH \
+    PQ_OQS_KEX_METHOD("sidh-p434-sha384") \
+    PQ_OQS_KEX_METHOD("sidh-p503-sha384") \
+    PQ_OQS_KEX_METHOD("sidh-p610-sha384") \
+    PQ_OQS_KEX_METHOD("sidh-p751-sha384") \
+    PQ_OQS_KEX_METHOD("sidh-p434-compressed-sha384") \
+    PQ_OQS_KEX_METHOD("sidh-p503-compressed-sha384") \
+    PQ_OQS_KEX_METHOD("sidh-p610-compressed-sha384") \
+    PQ_OQS_KEX_METHOD("sidh-p751-compressed-sha384")
+#else
+#define KEX_PQ_METHOD_SIDH ""
+#endif /* HAVE_SIDH */
+#ifdef HAVE_SIKE
+#define KEX_PQ_METHOD_SIKE \
+    PQ_OQS_KEX_METHOD("sike-p434-sha384") \
+    PQ_OQS_KEX_METHOD("sike-p503-sha384") \
+    PQ_OQS_KEX_METHOD("sike-p610-sha384") \
+    PQ_OQS_KEX_METHOD("sike-p751-sha384") \
+    PQ_OQS_KEX_METHOD("-sha384") \
+    PQ_OQS_KEX_METHOD("sike-p503-compressed-sha384") \
+    PQ_OQS_KEX_METHOD("sike-p610-compressed-sha384") \
+    PQ_OQS_KEX_METHOD("sike-p751-compressed-sha384")
+#else
+#define KEX_PQ_METHOD_SIKE ""
+#endif /* HAVE_SIKE */
+#ifdef HAVE_THREEBEARS
+#define KEX_PQ_METHOD_THREEBEARS \
+    PQ_OQS_KEX_METHOD("babybear-sha384") \
+    PQ_OQS_KEX_METHOD("babybear-ephem-sha384") \
+    PQ_OQS_KEX_METHOD("mamabear-sha384") \
+    PQ_OQS_KEX_METHOD("mamabear-ephem-sha384") \
+    PQ_OQS_KEX_METHOD("papabear-sha384") \
+    PQ_OQS_KEX_METHOD("papabear-ephem-sha384")
+#else
+#define KEX_PQ_METHOD_THREEBEARS ""
+#endif /* HAVE_THREEBEARS */
+#ifdef HAVE_HQC
+#define KEX_PQ_METHOD_HQC \
+    PQ_OQS_KEX_METHOD("hqc-128-1-cca2-sha384") \
+    PQ_OQS_KEX_METHOD("hqc-192-1-cca2-sha384") \
+    PQ_OQS_KEX_METHOD("hqc-192-2-cca2-sha384") \
+    PQ_OQS_KEX_METHOD("hqc-256-1-cca2-sha384") \
+    PQ_OQS_KEX_METHOD("hqc-256-2-cca2-sha384") \
+    PQ_OQS_KEX_METHOD("hqc-256-3-cca2-sha384")
+#else
+#define KEX_PQ_METHOD_HQC ""
+#endif /* HAVE_HQC */
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_PQ_KEXS_END
+#else /* defined(WITH_OQS) && defined(WITH_PQ_KEX) */
+///// OQS_TEMPLATE_FRAGMENT_UNDEFINE_PQ_KEXS_START
+#define KEX_PQ_METHOD_BIKE ""
+#define KEX_PQ_METHOD_CLASSIC_MCELIECE ""
+#define KEX_PQ_METHOD_FRODO ""
+#define KEX_PQ_METHOD_KYBER ""
+#define KEX_PQ_METHOD_NEWHOPE ""
+#define KEX_PQ_METHOD_NTRU ""
+#define KEX_PQ_METHOD_SABER ""
+#define KEX_PQ_METHOD_SIDH ""
+#define KEX_PQ_METHOD_SIKE ""
+#define KEX_PQ_METHOD_THREEBEARS ""
+#define KEX_PQ_METHOD_HQC ""
+///// OQS_TEMPLATE_FRAGMENT_UNDEFINE_PQ_KEXS_END
+#endif /* defined(WITH_OQS) && defined(WITH_PQ_KEX) */
+
+///// OQS_TEMPLATE_FRAGMENT_LIST_PQ_KEXS_START
+#define KEX_PQ_METHODS \
+    PQ_OQS_KEX_METHOD("oqsdefault-sha384") \
+    KEX_PQ_METHOD_BIKE \
+    KEX_PQ_METHOD_CLASSIC_MCELIECE \
+    KEX_PQ_METHOD_FRODO \
+    KEX_PQ_METHOD_KYBER \
+    KEX_PQ_METHOD_NEWHOPE \
+    KEX_PQ_METHOD_NTRU \
+    KEX_PQ_METHOD_SABER \
+    KEX_PQ_METHOD_SIDH \
+    KEX_PQ_METHOD_SIKE \
+    KEX_PQ_METHOD_THREEBEARS \
+    KEX_PQ_METHOD_HQC
+///// OQS_TEMPLATE_FRAGMENT_LIST_PQ_KEXS_END
+
 #ifdef OPENSSL_HAS_ECC
+#if defined(WITH_OQS) && defined(WITH_HYBRID_KEX)
+#define HYBRID_ECDH_OQS_METHOD(X) HYBRID_ECDH_OQS_KEX_SUFFIX(X) ","
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_HYBRID_KEXS_START
+#ifdef HAVE_BIKE
+#define KEX_HYBRID_METHOD_BIKE \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-bike1-l1-cpa-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-bike1-l3-cpa-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-bike1-l1-fo-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-bike1-l3-fo-sha384")
+#else
+#define KEX_HYBRID_METHOD_BIKE ""
+#endif /* HAVE_BIKE */
+#ifdef HAVE_CLASSIC_MCELIECE
+#define KEX_HYBRID_METHOD_CLASSIC_MCELIECE \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-classic-mceliece-348864-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-classic-mceliece-348864f-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-classic-mceliece-460896-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-classic-mceliece-460896f-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-classic-mceliece-6688128-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-classic-mceliece-6688128f-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-classic-mceliece-6960119-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-classic-mceliece-6960119f-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-classic-mceliece-8192128-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-classic-mceliece-8192128f-sha384")
+#else
+#define KEX_HYBRID_METHOD_CLASSIC_MCELIECE ""
+#endif /* HAVE_CLASSIC_MCELIECE */
+#ifdef HAVE_FRODO
+#define KEX_HYBRID_METHOD_FRODO \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-frodo-640-aes-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-frodo-640-shake-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-frodo-976-aes-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-frodo-976-shake-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-frodo-1344-aes-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-frodo-1344-shake-sha384")
+#else
+#define KEX_HYBRID_METHOD_FRODO ""
+#endif /* HAVE_FRODO */
+#ifdef HAVE_KYBER
+#define KEX_HYBRID_METHOD_KYBER \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-kyber-512-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-kyber-768-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-kyber-1024-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-kyber-512-90s-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-kyber-768-90s-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-kyber-1024-90s-sha384")
+#else
+#define KEX_HYBRID_METHOD_KYBER ""
+#endif /* HAVE_KYBER */
+#ifdef HAVE_NEWHOPE
+#define KEX_HYBRID_METHOD_NEWHOPE \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-newhope-512-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-newhope-1024-sha384")
+#else
+#define KEX_HYBRID_METHOD_NEWHOPE ""
+#endif /* HAVE_NEWHOPE */
+#ifdef HAVE_NTRU
+#define KEX_HYBRID_METHOD_NTRU \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-ntru-hps-2048-509-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-ntru-hps-2048-677-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-ntru-hrss-701-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-ntru-hps-4096-821-sha384")
+#else
+#define KEX_HYBRID_METHOD_NTRU ""
+#endif /* HAVE_NTRU */
+#ifdef HAVE_SABER
+#define KEX_HYBRID_METHOD_SABER \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-saber-lightsaber-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-saber-saber-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-saber-firesaber-sha384")
+#else
+#define KEX_HYBRID_METHOD_SABER ""
+#endif /* HAVE_SABER */
+#ifdef HAVE_SIDH
+#define KEX_HYBRID_METHOD_SIDH \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-sidh-p434-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-sidh-p503-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-sidh-p610-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-sidh-p751-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-sidh-p434-compressed-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-sidh-p503-compressed-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-sidh-p610-compressed-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-sidh-p751-compressed-sha384")
+#else
+#define KEX_HYBRID_METHOD_SIDH ""
+#endif /* HAVE_SIDH */
+#ifdef HAVE_SIKE
+#define KEX_HYBRID_METHOD_SIKE \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-sike-p434-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-sike-p503-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-sike-p610-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-sike-p751-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384--sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-sike-p503-compressed-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-sike-p610-compressed-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-sike-p751-compressed-sha384")
+#else
+#define KEX_HYBRID_METHOD_SIKE ""
+#endif /* HAVE_SIKE */
+#ifdef HAVE_THREEBEARS
+#define KEX_HYBRID_METHOD_THREEBEARS \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-babybear-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-babybear-ephem-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-mamabear-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-mamabear-ephem-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-papabear-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-papabear-ephem-sha384")
+#else
+#define KEX_HYBRID_METHOD_THREEBEARS ""
+#endif /* HAVE_THREEBEARS */
+#ifdef HAVE_HQC
+#define KEX_HYBRID_METHOD_HQC \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-hqc-128-1-cca2-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-hqc-192-1-cca2-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-hqc-192-2-cca2-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-hqc-256-1-cca2-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-hqc-256-2-cca2-sha384") \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-hqc-256-3-cca2-sha384")
+#else
+#define KEX_HYBRID_METHOD_HQC ""
+#endif /* HAVE_HQC */
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_HYBRID_KEXS_END
+#else /* defined(WITH_OQS) && defined(WITH_HYBRID_KEX) */
+///// OQS_TEMPLATE_FRAGMENT_UNDEFINE_HYBRID_KEXS_START
+#define KEX_HYBRID_METHOD_BIKE ""
+#define KEX_HYBRID_METHOD_CLASSIC_MCELIECE ""
+#define KEX_HYBRID_METHOD_FRODO ""
+#define KEX_HYBRID_METHOD_KYBER ""
+#define KEX_HYBRID_METHOD_NEWHOPE ""
+#define KEX_HYBRID_METHOD_NTRU ""
+#define KEX_HYBRID_METHOD_SABER ""
+#define KEX_HYBRID_METHOD_SIDH ""
+#define KEX_HYBRID_METHOD_SIKE ""
+#define KEX_HYBRID_METHOD_THREEBEARS ""
+#define KEX_HYBRID_METHOD_HQC ""
+///// OQS_TEMPLATE_FRAGMENT_UNDEFINE_HYBRID_KEXS_END
+#endif /* defined(WITH_OQS) && defined(WITH_HYBRID_KEX) */
+
+///// OQS_TEMPLATE_FRAGMENT_LIST_HYBRID_KEXS_START
+#define KEX_HYBRID_METHODS \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-oqsdefault-sha384") \
+    KEX_HYBRID_METHOD_BIKE \
+    KEX_HYBRID_METHOD_CLASSIC_MCELIECE \
+    KEX_HYBRID_METHOD_FRODO \
+    KEX_HYBRID_METHOD_KYBER \
+    KEX_HYBRID_METHOD_NEWHOPE \
+    KEX_HYBRID_METHOD_NTRU \
+    KEX_HYBRID_METHOD_SABER \
+    KEX_HYBRID_METHOD_SIDH \
+    KEX_HYBRID_METHOD_SIKE \
+    KEX_HYBRID_METHOD_THREEBEARS \
+    KEX_HYBRID_METHOD_HQC
+///// OQS_TEMPLATE_FRAGMENT_LIST_HYBRID_KEXS_END
+
 #ifdef OPENSSL_HAS_NISTP521
 # define KEX_ECDH_METHODS \
 	"ecdh-sha2-nistp256," \
@@ -93,7 +401,9 @@
 #define KEX_COMMON_KEX \
 	KEX_CURVE25519_METHODS \
 	KEX_ECDH_METHODS \
-	KEX_SHA2_METHODS
+	KEX_SHA2_METHODS \
+	KEX_HYBRID_METHODS \
+	KEX_PQ_METHODS
 
 #define KEX_SERVER_KEX KEX_COMMON_KEX \
 	KEX_SHA2_GROUP14 \
@@ -206,4 +516,3 @@
 	KEX_DEFAULT_COMP, \
 	KEX_DEFAULT_LANG, \
 	KEX_DEFAULT_LANG
-
--- /dev/null
+++ b/oqs-scripts/build_liboqs.sh
@@ -0,0 +1,19 @@
+#!/bin/bash
+
+###########
+# Build liboqs
+#
+# Environment variables:
+#  - PREFIX: path to install liboqs, default `pwd`/../oqs
+###########
+
+set -exo pipefail
+
+PREFIX=${PREFIX:-"`pwd`/oqs"}
+
+cd oqs-scripts/tmp/liboqs
+rm -rf build
+mkdir build && cd build
+cmake .. -GNinja -DCMAKE_POSITION_INDEPENDENT_CODE=ON -DCMAKE_INSTALL_PREFIX=${PREFIX}
+ninja
+ninja install
--- /dev/null
+++ b/oqs-scripts/build_openssh.sh
@@ -0,0 +1,36 @@
+#!/bin/bash
+
+###########
+# Build OpenSSH
+#
+# Must be run after OQS has been installed
+###########
+
+set -exo pipefail
+
+PREFIX=${PREFIX:-"`pwd`/oqs-test/tmp"}
+WITH_OPENSSL=${WITH_OPENSSL:-"true"}
+
+case "$OSTYPE" in
+    darwin*)  OPENSSL_SYS_DIR=${OPENSSL_SYS_DIR:-"/usr/local/opt/openssl@1.1"} ;;
+    linux*)   OPENSSL_SYS_DIR=${OPENSSL_SYS_DIR:-"/usr"} ;;
+    *)        echo "Unknown operating system: $OSTYPE" ; exit 1 ;;
+esac
+
+if [ -f Makefile ]; then
+    make clean
+else
+    autoreconf -i
+fi
+
+if [ "x${WITH_OPENSSL}" == "xtrue" ]; then
+    ./configure --prefix="${PREFIX}" --with-ldflags="-Wl,-rpath -Wl,${PREFIX}/lib" --with-libs=-lm --with-ssl-dir="${OPENSSL_SYS_DIR}" --with-liboqs-dir="`pwd`/oqs" --with-cflags="-I${PREFIX}/include" --sysconfdir="${PREFIX}"
+else
+    ./configure --prefix="${PREFIX}" --with-ldflags="-Wl,-rpath -Wl,${PREFIX}/lib" --with-libs=-lm --without-openssl --with-liboqs-dir="`pwd`/oqs" --with-cflags="-I${PREFIX}/include" --sysconfdir="${PREFIX}"
+fi
+if [ "x${CIRCLECI}" == "xtrue" ] || [ "x${TRAVIS}" == "xtrue" ]; then
+    make -j2
+else
+    make -j
+fi
+make install
--- /dev/null
+++ b/oqs-scripts/clone_liboqs.sh
@@ -0,0 +1,17 @@
+#!/bin/bash
+
+###########
+# Clone liboqs source code
+#
+# Environment variables:
+#  - LIBOQS_REPO: which repo to check out from, default https://github.com/open-quantum-safe/liboqs.git
+#  - LIBOQS_BRANCH: which branch to check out, default master
+###########
+
+set -exo pipefail
+
+LIBOQS_REPO=${LIBOQS_REPO:-"https://github.com/open-quantum-safe/liboqs.git"}
+LIBOQS_BRANCH=${LIBOQS_BRANCH:-"master"}
+
+rm -rf oqs-scripts/tmp && mkdir oqs-scripts/tmp
+git clone --branch ${LIBOQS_BRANCH} --single-branch ${LIBOQS_REPO} oqs-scripts/tmp/liboqs
--- /dev/null
+++ b/oqs-template/configure.ac/test_pq_alg_support.fragment
@@ -0,0 +1,32 @@
+{%- for kem in config['kems'] %}
+	AC_MSG_CHECKING([for libOQS {{ kem['family'] }} support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_KEM_{{ kem['family'] }}) || ({%- for variant in kem['variants'] -%}defined({{ variant['oqs_meth']|replace("KEM_alg","ENABLE_KEM") }}){% if not loop.last -%}{{ " && " }}{%- endif -%}{%- endfor -%})
+					#else
+					#error "{{ kem['family'] }} is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_{{ kem['family'] }}], [1], [Define to 1 if LibOQS library is compiled with support for {{ kem['family'] }}])
+			], [AC_MSG_RESULT([no])
+	])
+{% endfor -%}
+{%- for sig in config['sigs'] %}
+{%- if sig['family'] != "OQSDEFAULT" %}
+	AC_MSG_CHECKING([for libOQS {{ sig['family'] }} support])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+				#include <oqs/oqs.h>
+			]], [[
+					#if defined(OQS_ENABLE_SIG_{{ sig['family'] }}) || ({%- for variant in sig['variants'] -%}defined({{ variant['oqs_meth']|replace("SIG_alg","ENABLE_SIG") }}){% if not loop.last -%}{{ " && " }}{%- endif -%}{%- endfor -%})
+					#else
+					#error "{{ sig['family'] }} is not supported"
+					#endif
+			]])],
+			[ AC_MSG_RESULT([yes])
+				AC_DEFINE([HAVE_{{ sig['family'] }}], [1], [Define to 1 if LibOQS library is compiled with support for {{ sig['family'] }}])
+			], [AC_MSG_RESULT([no])
+	])
+{%- endif %}
+{% endfor %}
--- /dev/null
+++ b/oqs-template/generate.py
@@ -0,0 +1,80 @@
+#!/usr/bin/env python3
+
+import copy
+import glob
+import jinja2
+import jinja2.ext
+import os
+import shutil
+import subprocess
+import sys
+import yaml
+
+# For list.append in Jinja templates
+Jinja2 = jinja2.Environment(loader=jinja2.FileSystemLoader(searchpath="."),extensions=['jinja2.ext.do'])
+
+def file_get_contents(filename, encoding=None):
+    with open(filename, mode='r', encoding=encoding) as fh:
+        return fh.read()
+
+def file_put_contents(filename, s, encoding=None):
+    with open(filename, mode='w', encoding=encoding) as fh:
+        fh.write(s)
+
+def populate(filename, config, delimiter, overwrite=False):
+    fragments = glob.glob(os.path.join('oqs-template', filename, '*.fragment'))
+    if overwrite == True:
+        source_file = os.path.join('oqs-template', filename, os.path.basename(filename)+ '.base')
+        contents = file_get_contents(source_file)
+    else:
+        contents = file_get_contents(filename)
+    for fragment in fragments:
+        identifier = os.path.splitext(os.path.basename(fragment))[0]
+        identifier_start = '{} OQS_TEMPLATE_FRAGMENT_{}_START'.format(delimiter, identifier.upper())
+        identifier_end = '{} OQS_TEMPLATE_FRAGMENT_{}_END'.format(delimiter, identifier.upper())
+        preamble = contents[:contents.find(identifier_start)]
+        postamble = contents[contents.find(identifier_end):]
+        if overwrite == True:
+            contents = preamble + Jinja2.get_template(fragment).render({'config': config}) + postamble.replace(identifier_end + '\n', '')
+        else:
+            contents = preamble + identifier_start + Jinja2.get_template(fragment).render({'config': config}) + postamble
+    file_put_contents(filename, contents)
+
+def load_config():
+    config = file_get_contents(os.path.join('oqs-template', 'generate.yml'), encoding='utf-8')
+    config = yaml.safe_load(config)
+    for sig in config['sigs']:
+        sig['variants'] = [variant for variant in sig['variants'] if variant['enable']]
+    config['sigs'] = [sig for sig in config['sigs'] if sig['variants']]
+    return config
+
+config = load_config()
+
+# update build script
+populate('configure.ac', config, '#####')
+
+# add kems
+populate('kex.c', config, '/////')
+populate('kex.h', config, '/////')
+populate('kexoqs.c', config, '/////')
+populate('myproposal.h', config, '/////')
+populate('regress/unittests/kex/test_kex.c', config, '/////')
+populate('ssh2.h', config, '/////')
+
+# add sigs
+populate('oqs-utils.h', config, '/////')
+populate('pathnames.h', config, '/////')
+populate('readconf.c', config, '/////')
+populate('servconf.c', config, '/////')
+populate('ssh-add.c', config, '/////')
+populate('ssh-keygen.c', config, '/////')
+populate('ssh-keyscan.c', config, '/////')
+populate('ssh-keysign.c', config, '/////')
+populate('ssh-oqs.c', config, '/////')
+populate('ssh.c', config, '/////')
+populate('sshconnect.c', config, '/////')
+populate('sshkey.c', config, '/////')
+populate('sshkey.h', config, '/////')
+
+# update test suite
+populate('oqs-test/test_openssh.py', config, '#####')
--- /dev/null
+++ b/oqs-template/generate.yml
@@ -0,0 +1,614 @@
+sigs:
+  -
+    # TODO: At the moment this should
+    # always be enabled to avoid build errors.
+    family: "OQSDEFAULT"
+    variants:
+      -
+        enable: true
+        name: "OQSDEFAULT"
+        oqs_meth: "OQS_SIG_alg_default"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+  -
+    family: "DILITHIUM"
+    variants:
+      -
+        enable: true
+        name: "DILITHIUM_2"
+        oqs_meth: "OQS_SIG_alg_dilithium_2"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "DILITHIUM_3"
+        oqs_meth: "OQS_SIG_alg_dilithium_3"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "DILITHIUM_4"
+        oqs_meth: "OQS_SIG_alg_dilithium_4"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+  -
+    family: "FALCON"
+    variants:
+      -
+        enable: true
+        name: "FALCON_512"
+        oqs_meth: "OQS_SIG_alg_falcon_512"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "FALCON_1024"
+        oqs_meth: "OQS_SIG_alg_falcon_1024"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+  -
+    family: "MQDSS"
+    variants:
+      -
+        enable: true
+        name: "MQDSS_31_48"
+        oqs_meth: "OQS_SIG_alg_mqdss_31_48"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "MQDSS_31_64"
+        oqs_meth: "OQS_SIG_alg_mqdss_31_64"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+  -
+    family: "PICNIC"
+    variants:
+      -
+        enable: true
+        name: "PICNIC_L1FS"
+        oqs_meth: "OQS_SIG_alg_picnic_L1_FS"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "PICNIC_L1UR"
+        oqs_meth: "OQS_SIG_alg_picnic_L1_UR"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "PICNIC_L1FULL"
+        oqs_meth: "OQS_SIG_alg_picnic_L1_full"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "PICNIC_L3FS"
+        oqs_meth: "OQS_SIG_alg_picnic_L3_FS"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: false
+        name: "PICNIC_L3UR"
+        oqs_meth: "OQS_SIG_alg_picnic_L3_UR"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: false
+        name: "PICNIC_L3FULL"
+        oqs_meth: "OQS_SIG_alg_picnic_L3_full"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: false
+        name: "PICNIC_L5FS"
+        oqs_meth: "OQS_SIG_alg_picnic_L5_FS"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: false
+        name: "PICNIC_L5UR"
+        oqs_meth: "OQS_SIG_alg_picnic_L5_UR"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: false
+        name: "PICNIC_L5FULL"
+        oqs_meth: "OQS_SIG_alg_picnic_L5_full"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: true
+        name: "PICNIC3_L1"
+        oqs_meth: "OQS_SIG_alg_picnic3_L1"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "PICNIC3_L3"
+        oqs_meth: "OQS_SIG_alg_picnic3_L3"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: false
+        name: "PICNIC3_L5"
+        oqs_meth: "OQS_SIG_alg_picnic3_L5"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+  -
+    family: "QTESLA"
+    variants:
+      -
+        enable: true
+        name: "QTESLA_P_I"
+        oqs_meth: "OQS_SIG_alg_qTesla_p_I"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "QTESLA_P_III"
+        oqs_meth: "OQS_SIG_alg_qTesla_p_III"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+  -
+    family: "RAINBOW"
+    variants:
+      -
+        enable: true
+        name: "RAINBOW_IA_CLASSIC"
+        oqs_meth: "OQS_SIG_alg_rainbow_Ia_classic"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "RAINBOW_IA_CYCLIC"
+        oqs_meth: "OQS_SIG_alg_rainbow_Ia_cyclic"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "RAINBOW_IA_CYCLIC_COMPRESSED"
+        oqs_meth: "OQS_SIG_alg_rainbow_Ia_cyclic_compressed"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: true
+        name: "RAINBOW_IIIC_CLASSIC"
+        oqs_meth: "OQS_SIG_alg_rainbow_IIIc_classic"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: false
+        name: "RAINBOW_IIIC_CYCLIC"
+        oqs_meth: "OQS_SIG_alg_rainbow_IIIc_cyclic"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: false
+        name: "RAINBOW_IIIC_CYCLIC_COMPRESSED"
+        oqs_meth: "OQS_SIG_alg_rainbow_IIIc_cyclic_compressed"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: true
+        name: "RAINBOW_VC_CLASSIC"
+        oqs_meth: "OQS_SIG_alg_rainbow_Vc_classic"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: false
+        name: "RAINBOW_VC_CYCLIC"
+        oqs_meth: "OQS_SIG_alg_rainbow_Vc_cyclic"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: false
+        name: "RAINBOW_VC_CYCLIC_COMPRESSED"
+        oqs_meth: "OQS_SIG_alg_rainbow_Vc_cyclic_compressed"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+  -
+    family: "SPHINCS"
+    variants:
+      -
+        enable: true
+        name: "SPHINCS_HARAKA_128F_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_haraka_128f_robust"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "SPHINCS_HARAKA_128F_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_haraka_128f_simple"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "SPHINCS_HARAKA_128S_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_haraka_128s_robust"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "SPHINCS_HARAKA_128S_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_haraka_128s_simple"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "SPHINCS_HARAKA_192F_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_haraka_192f_robust"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+
+      -
+        enable: false
+        name: "SPHINCS_HARAKA_192F_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_haraka_192f_simple"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: false
+        name: "SPHINCS_HARAKA_192S_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_haraka_192s_robust"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: false
+        name: "SPHINCS_HARAKA_192S_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_haraka_192s_simple"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: false
+        name: "SPHINCS_HARAKA_256F_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_haraka_256f_robust"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: false
+        name: "SPHINCS_HARAKA_256F_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_haraka_256f_simple"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: false
+        name: "SPHINCS_HARAKA_256S_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_haraka_256s_robust"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: false
+        name: "SPHINCS_HARAKA_256S_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_haraka_256s_simple"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: true
+        name: "SPHINCS_SHA256_128F_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_sha256_128f_robust"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHA256_128F_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_sha256_128f_simple"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHA256_128S_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_sha256_128s_robust"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHA256_128S_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_sha256_128s_simple"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHA256_192F_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_sha256_192f_robust"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+
+      -
+        enable: false
+        name: "SPHINCS_SHA256_192F_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_sha256_192f_simple"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHA256_192S_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_sha256_192s_robust"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHA256_192S_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_sha256_192s_simple"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHA256_256F_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_sha256_256f_robust"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHA256_256F_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_sha256_256f_simple"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHA256_256S_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_sha256_256s_robust"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHA256_256S_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_sha256_256s_simple"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: true
+        name: "SPHINCS_SHAKE256_128F_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_shake256_128f_robust"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHAKE256_128F_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_shake256_128f_simple"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHAKE256_128S_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_shake256_128s_robust"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHAKE256_128S_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_shake256_128s_simple"
+        mix_with: [{'name':'rsa3072'},
+                   {'name': 'p256', 'curve':'NID_X9_62_prime256v1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHAKE256_192F_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_shake256_192f_robust"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+
+      -
+        enable: false
+        name: "SPHINCS_SHAKE256_192F_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_shake256_192f_simple"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHAKE256_192S_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_shake256_192s_robust"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHAKE256_192S_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_shake256_192s_simple"
+        mix_with: [{'name': 'p384', 'curve':'NID_secp384r1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHAKE256_256F_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_shake256_256f_robust"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHAKE256_256F_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_shake256_256f_simple"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHAKE256_256S_ROBUST"
+        oqs_meth: "OQS_SIG_alg_sphincs_shake256_256s_robust"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+      -
+        enable: false
+        name: "SPHINCS_SHAKE256_256S_SIMPLE"
+        oqs_meth: "OQS_SIG_alg_sphincs_shake256_256s_simple"
+        mix_with: [{'name': 'p521', 'curve':'NID_secp521r1'}]
+
+kems:
+  -
+    family: "BIKE"
+    variants:
+      -
+        name: "BIKE1_L1_CPA"
+        oqs_meth: "OQS_KEM_alg_bike1_l1_cpa"
+      -
+        name: "BIKE1_L3_CPA"
+        oqs_meth: "OQS_KEM_alg_bike1_l3_cpa"
+      -
+        name: "BIKE1_L1_FO"
+        oqs_meth: "OQS_KEM_alg_bike1_l1_fo"
+      -
+        name: "BIKE1_L3_FO"
+        oqs_meth: "OQS_KEM_alg_bike1_l3_fo"
+  -
+    family: "CLASSIC_MCELIECE"
+    variants:
+      -
+        name: "CLASSIC_MCELIECE_348864"
+        oqs_meth: "OQS_KEM_alg_classic_mceliece_348864"
+      -
+        name: "CLASSIC_MCELIECE_348864F"
+        oqs_meth: "OQS_KEM_alg_classic_mceliece_348864f"
+      -
+        name: "CLASSIC_MCELIECE_460896"
+        oqs_meth: "OQS_KEM_alg_classic_mceliece_460896"
+      -
+        name: "CLASSIC_MCELIECE_460896F"
+        oqs_meth: "OQS_KEM_alg_classic_mceliece_460896f"
+      -
+        name: "CLASSIC_MCELIECE_6688128"
+        oqs_meth: "OQS_KEM_alg_classic_mceliece_6688128"
+      -
+        name: "CLASSIC_MCELIECE_6688128F"
+        oqs_meth: "OQS_KEM_alg_classic_mceliece_6688128f"
+      -
+        name: "CLASSIC_MCELIECE_6960119"
+        oqs_meth: "OQS_KEM_alg_classic_mceliece_6960119"
+      -
+        name: "CLASSIC_MCELIECE_6960119F"
+        oqs_meth: "OQS_KEM_alg_classic_mceliece_6960119f"
+      -
+        name: "CLASSIC_MCELIECE_8192128"
+        oqs_meth: "OQS_KEM_alg_classic_mceliece_8192128"
+      -
+        name: "CLASSIC_MCELIECE_8192128F"
+        oqs_meth: "OQS_KEM_alg_classic_mceliece_8192128f"
+  -
+    family: "FRODO"
+    variants:
+      -
+        name: "FRODO_640_AES"
+        oqs_meth: "OQS_KEM_alg_frodokem_640_aes"
+      -
+        name: "FRODO_640_SHAKE"
+        oqs_meth: "OQS_KEM_alg_frodokem_640_shake"
+      -
+        name: "FRODO_976_AES"
+        oqs_meth: "OQS_KEM_alg_frodokem_976_aes"
+      -
+        name: "FRODO_976_SHAKE"
+        oqs_meth: "OQS_KEM_alg_frodokem_976_shake"
+      -
+        name: "FRODO_1344_AES"
+        oqs_meth: "OQS_KEM_alg_frodokem_1344_aes"
+      -
+        name: "FRODO_1344_SHAKE"
+        oqs_meth: "OQS_KEM_alg_frodokem_1344_shake"
+  -
+    family: "KYBER"
+    variants:
+      -
+        name: "KYBER_512"
+        oqs_meth: "OQS_KEM_alg_kyber_512"
+      -
+        name: "KYBER_768"
+        oqs_meth: "OQS_KEM_alg_kyber_768"
+      -
+        name: "KYBER_1024"
+        oqs_meth: "OQS_KEM_alg_kyber_1024"
+      -
+        name: "KYBER_512_90S"
+        oqs_meth: "OQS_KEM_alg_kyber_512_90s"
+      -
+        name: "KYBER_768_90S"
+        oqs_meth: "OQS_KEM_alg_kyber_768_90s"
+      -
+        name: "KYBER_1024_90S"
+        oqs_meth: "OQS_KEM_alg_kyber_1024_90s"
+  -
+    family: "NEWHOPE"
+    variants:
+      -
+        name: "NEWHOPE_512"
+        oqs_meth: "OQS_KEM_alg_newhope_512cca"
+      -
+        name: "NEWHOPE_1024"
+        oqs_meth: "OQS_KEM_alg_newhope_1024cca"
+  -
+    family: "NTRU"
+    variants:
+      -
+        name: "NTRU_HPS_2048_509"
+        oqs_meth: "OQS_KEM_alg_ntru_hps2048509"
+      -
+        name: "NTRU_HPS_2048_677"
+        oqs_meth: "OQS_KEM_alg_ntru_hps2048677"
+      -
+        name: "NTRU_HRSS_701"
+        oqs_meth: "OQS_KEM_alg_ntru_hrss701"
+      -
+        name: "NTRU_HPS_4096_821"
+        oqs_meth: "OQS_KEM_alg_ntru_hps4096821"
+  -
+    family: "SABER"
+    variants:
+      -
+        name: "SABER_LIGHTSABER"
+        oqs_meth: "OQS_KEM_alg_saber_lightsaber"
+      -
+        name: "SABER_SABER"
+        oqs_meth: "OQS_KEM_alg_saber_saber"
+      -
+        name: "SABER_FIRESABER"
+        oqs_meth: "OQS_KEM_alg_saber_firesaber"
+  -
+    family: "SIDH"
+    variants:
+      -
+        name: "SIDH_p434"
+        oqs_meth: "OQS_KEM_alg_sidh_p434"
+      -
+        name: "SIDH_p503"
+        oqs_meth: "OQS_KEM_alg_sidh_p503"
+      -
+        name: "SIDH_p610"
+        oqs_meth: "OQS_KEM_alg_sidh_p610"
+      -
+        name: "SIDH_p751"
+        oqs_meth: "OQS_KEM_alg_sidh_p751"
+      -
+        name: "SIDH_P434_COMPRESSED"
+        oqs_meth: "OQS_KEM_alg_sidh_p434_compressed"
+      -
+        name: "SIDH_P503_COMPRESSED"
+        oqs_meth: "OQS_KEM_alg_sidh_p503_compressed"
+      -
+        name: "SIDH_P610_COMPRESSED"
+        oqs_meth: "OQS_KEM_alg_sidh_p610_compressed"
+      -
+        name: "SIDH_P751_COMPRESSED"
+        oqs_meth: "OQS_KEM_alg_sidh_p751_compressed"
+  -
+    family: "SIKE"
+    variants:
+      -
+        name: "SIKE_P434"
+        oqs_meth: "OQS_KEM_alg_sike_p434"
+      -
+        name: "SIKE_P503"
+        oqs_meth: "OQS_KEM_alg_sike_p503"
+      -
+        name: "SIKE_P610"
+        oqs_meth: "OQS_KEM_alg_sike_p610"
+      -
+        name: "SIKE_P751"
+        oqs_meth: "OQS_KEM_alg_sike_p751"
+      -
+        NAME: "SIKE_P434_COMPRESSED"
+        oqs_meth: "OQS_KEM_alg_sike_p434_compressed"
+      -
+        name: "SIKE_P503_COMPRESSED"
+        oqs_meth: "OQS_KEM_alg_sike_p503_compressed"
+      -
+        name: "SIKE_P610_COMPRESSED"
+        oqs_meth: "OQS_KEM_alg_sike_p610_compressed"
+      -
+        name: "SIKE_P751_COMPRESSED"
+        oqs_meth: "OQS_KEM_alg_sike_p751_compressed"
+  -
+    family: "THREEBEARS"
+    variants:
+      -
+        name: "BABYBEAR"
+        oqs_meth: "OQS_KEM_alg_threebears_babybear"
+      -
+        name: "BABYBEAR_EPHEM"
+        oqs_meth: "OQS_KEM_alg_threebears_babybear_ephem"
+      -
+        name: "MAMABEAR"
+        oqs_meth: "OQS_KEM_alg_threebears_mamabear"
+      -
+        name: "MAMABEAR_EPHEM"
+        oqs_meth: "OQS_KEM_alg_threebears_mamabear_ephem"
+      -
+        name: "PAPABEAR"
+        oqs_meth: "OQS_KEM_alg_threebears_papabear"
+      -
+        name: "PAPABEAR_EPHEM"
+        oqs_meth: "OQS_KEM_alg_threebears_papabear_ephem"
+  -
+    family: "HQC"
+    variants:
+      -
+        name: "HQC_128_1_CCA2"
+        oqs_meth: 'OQS_KEM_alg_hqc_128_1_cca2'
+      -
+        name: "HQC_192_1_CCA2"
+        oqs_meth: 'OQS_KEM_alg_hqc_192_1_cca2'
+      -
+        name: "HQC_192_2_CCA2"
+        oqs_meth: 'OQS_KEM_alg_hqc_192_2_cca2'
+      -
+        name: "HQC_256_1_CCA2"
+        oqs_meth: 'OQS_KEM_alg_hqc_256_1_cca2'
+      -
+        name: "HQC_256_2_CCA2"
+        oqs_meth: 'OQS_KEM_alg_hqc_256_2_cca2'
+      -
+        name: "HQC_256_3_CCA2"
+        oqs_meth: 'OQS_KEM_alg_hqc_256_3_cca2'
--- /dev/null
+++ b/oqs-template/kex.c/define_hybrid_kexs.fragment
@@ -0,0 +1,8 @@
+{%- for kem in config['kems'] %}
+#ifdef HAVE_{{ kem['family'] }}
+    {%- for variant in kem['variants'] %}
+	HYBRID_ECDH_OQS_KEX(KEX_ECDH_NISTP384_{{ variant['name'] }}_SHA384)
+    {%- endfor %}
+#endif /* HAVE_{{ kem['family'] }} */
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/kex.c/define_pq_kexs.fragment
@@ -0,0 +1,8 @@
+{%- for kem in config['kems'] %}
+#ifdef HAVE_{{ kem['family'] }}
+    {%- for variant in kem['variants'] %}
+	PQ_OQS_KEX(KEX_{{ variant['name'] }}_SHA384)
+    {%- endfor %}
+#endif /* HAVE_{{ kem['family'] }} */
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/kex.h/define_hybrid_kexs.fragment
@@ -0,0 +1,6 @@
+{%- for kem in config['kems'] %}
+    {%- for variant in kem['variants'] %}
+#define KEX_ECDH_NISTP384_{{ variant['name'] }}_SHA384 HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-{{ variant['name']|lower|replace('_','-') }}-sha384")
+    {%- endfor %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/kex.h/define_pq_kexs.fragment
@@ -0,0 +1,6 @@
+{%- for kem in config['kems'] %}
+    {%- for variant in kem['variants'] %}
+#define KEX_{{ variant['name'] }}_SHA384 PQ_OQS_KEX_SUFFIX("{{ variant['name']|lower|replace('_','-') }}-sha384")
+    {%- endfor %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/kexoqs.c/define_hybrid_kexs.fragment
@@ -0,0 +1,9 @@
+{%- for kem in config['kems'] %}
+#ifdef HAVE_{{ kem['family'] }}
+    {%- for variant in kem['variants'] %}
+	{HYBRID_ECDH_OQS_KEX_SUFFIX("ecdh-nistp384-{{ variant['name']|lower|replace('_','-') }}-sha384"), {{ variant['oqs_meth'] }},
+	SSH2_MSG_HY_ECDH_{{ kem['family'] }}_INIT, SSH2_MSG_HY_ECDH_{{ kem['family'] }}_REPLY},
+    {%- endfor %}
+#endif /* HAVE_{{ kem['family'] }} */
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/kexoqs.c/define_pq_kexs.fragment
@@ -0,0 +1,9 @@
+{%- for kem in config['kems'] %}
+#ifdef HAVE_{{ kem['family'] }}
+    {%- for variant in kem['variants'] %}
+	{PQ_OQS_KEX_SUFFIX("{{ variant['name']|lower|replace('_','-') }}-sha384"), {{ variant['oqs_meth'] }},
+	SSH2_MSG_PQ_{{ kem['family'] }}_INIT, SSH2_MSG_PQ_{{ kem['family'] }}_REPLY},
+    {%- endfor %}
+#endif /* HAVE_{{ kem['family'] }} */
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/myproposal.h/define_hybrid_kexs.fragment
@@ -0,0 +1,11 @@
+{%- for kem in config['kems'] %}
+#ifdef HAVE_{{ kem['family'] }}
+#define KEX_HYBRID_METHOD_{{ kem['family'] }} \
+    {%- for variant in kem['variants'] %}
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-{{ variant['name']|lower|replace('_','-') }}-sha384"){% if not loop.last -%}{{ " " }}\{%- endif -%}
+    {%- endfor %}
+#else
+#define KEX_HYBRID_METHOD_{{ kem['family'] }} ""
+#endif /* HAVE_{{ kem['family'] }} */
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/myproposal.h/define_pq_kexs.fragment
@@ -0,0 +1,12 @@
+{%- for kem in config['kems'] %}
+#ifdef HAVE_{{ kem['family'] }}
+#define KEX_PQ_METHOD_{{ kem['family'] }} \
+    {%- for variant in kem['variants'] %}
+    PQ_OQS_KEX_METHOD("{{ variant['name']|lower|replace('_','-') }}-sha384"){% if not loop.last -%}{{ " " }}\{%- endif -%}
+
+    {%- endfor %}
+#else
+#define KEX_PQ_METHOD_{{ kem['family'] }} ""
+#endif /* HAVE_{{ kem['family'] }} */
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/myproposal.h/list_hybrid_kexs.fragment
@@ -0,0 +1,7 @@
+
+#define KEX_HYBRID_METHODS \
+    HYBRID_ECDH_OQS_METHOD("ecdh-nistp384-oqsdefault-sha384") \
+{%- for kem in config['kems'] %}
+    KEX_HYBRID_METHOD_{{ kem['family'] }}{% if not loop.last -%}{{ " " }}\{%- endif -%}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/myproposal.h/list_pq_kexs.fragment
@@ -0,0 +1,7 @@
+
+#define KEX_PQ_METHODS \
+    PQ_OQS_KEX_METHOD("oqsdefault-sha384") \
+{%- for kem in config['kems'] %}
+    KEX_PQ_METHOD_{{ kem['family'] }}{% if not loop.last -%}{{ " " }}\{%- endif -%}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/myproposal.h/undefine_hybrid_kexs.fragment
@@ -0,0 +1,4 @@
+{%- for kem in config['kems'] %}
+#define KEX_HYBRID_METHOD_{{ kem['family'] }} ""
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/myproposal.h/undefine_pq_kexs.fragment
@@ -0,0 +1,4 @@
+{%- for kem in config['kems'] %}
+#define KEX_PQ_METHOD_{{ kem['family'] }} ""
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/oqs-test/test_openssh.py/list_kexs.fragment
@@ -0,0 +1,8 @@
+
+    # post-quantum only kex
+    {% for kem in config['kems'] %}{% for variant in kem['variants'] %}'{{ variant['name']|lower|replace('_','-') }}-sha384@openquantumsafe.org',
+    {%- endfor %} {%- endfor %}
+    # hybrid kex
+    {% for kem in config['kems'] %}{% for variant in kem['variants'] %}'ecdh-nistp384-{{ variant['name']|lower|replace('_','-') }}-sha384@openquantumsafe.org',
+    {%- endfor %}{% endfor %}
+
--- /dev/null
+++ b/oqs-template/oqs-test/test_openssh.py/list_sigs.fragment
@@ -0,0 +1,12 @@
+
+    # post-quantum only sigs
+    {% for sig in config['sigs'] %}{% for variant in sig['variants'] %}'ssh-{{ variant['name']|lower|replace('_','') }}',
+    {%- endfor %} {%- endfor %}
+    # hybrid sigs
+    {% for sig in config['sigs'] -%}
+        {%- for variant in sig['variants'] -%}
+            {%- for classical_alg in variant['mix_with'] -%}
+            'ssh-{{ classical_alg['name'] }}-{{ variant['name']|lower|replace('_','') }}',
+            {%- endfor -%}
+    {%- endfor %} {%- endfor %}
+
--- /dev/null
+++ b/oqs-template/oqs-utils.h/assign_pq_kt.fragment
@@ -0,0 +1,9 @@
+
+#define IS_OQS_KEY_TYPE(type) ( \
+{%- for sig in config['sigs'] -%}
+    {% for variant in sig['variants'] %}
+				(type) == KEY_{{ variant['name'] }} || \
+    {%- endfor -%}
+{% endfor %}
+				IS_HYBRID(type))
+
--- /dev/null
+++ b/oqs-template/oqs-utils.h/define_hybrid_macros.fragment
@@ -0,0 +1,40 @@
+{%- set with_rsa3072 = [] -%}
+{%- set with_p256 = [] -%}
+{%- set with_p384 = [] -%}
+{%- set with_p521 = [] -%}
+{%- for sig in config['sigs'] -%}
+    {%- for variant in sig['variants'] -%}
+        {%- for classical_alg in variant['mix_with'] -%}
+            {%- if classical_alg.name == 'rsa3072' -%}
+                {%- do with_rsa3072.append(variant) -%}
+            {%- elif classical_alg.name == 'p256' -%}
+                {%- do with_p256.append(variant) -%}
+            {%- elif classical_alg.name == 'p384' -%}
+                {%- do with_p384.append(variant) -%}
+            {%- elif classical_alg.name == 'p521' -%}
+                {%- do with_p521.append(variant) -%}
+            {%- endif -%}
+        {%- endfor -%}
+    {%- endfor -%}
+{%- endfor %}
+#define IS_RSA_HYBRID_ALG_NAME(alg) ( \
+{%- for pq_alg in with_rsa3072 %}
+				strcmp(alg, "ssh-rsa3072-{{ pq_alg['name']|lower|replace('_','') }}") == 0{%- if not loop.last %} || \{%- else -%}){%- endif -%}
+{%- endfor %}
+
+#define IS_RSA_HYBRID(alg) ( \
+{%- for pq_alg in with_rsa3072 %}
+				alg == KEY_RSA3072_{{ pq_alg['name'] }}{%- if not loop.last %} || \{% else %}){% endif %}
+{%- endfor %}
+
+#define IS_ECDSA_HYBRID(alg) ( \
+{%- for pq_alg in with_p256 %}
+				alg == KEY_P256_{{ pq_alg['name'] }}{%- if not loop.last or with_p384 or with_p521 %} || \{% else %}){% endif %}
+{%- endfor -%}
+{%- for pq_alg in with_p384 %}
+				alg == KEY_P384_{{ pq_alg['name'] }}{%- if not loop.last or with_p521 %} || \{% else %}){% endif %}
+{%- endfor %}
+{%- for pq_alg in with_p521 %}
+				alg == KEY_P521_{{ pq_alg['name'] }}{%- if not loop.last %} || \{% else %}){% endif %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/oqs-utils.h/define_hybrid_switch_cases.fragment
@@ -0,0 +1,35 @@
+{%- set with_rsa3072 = [] -%}
+{%- set with_p256 = [] -%}
+{%- set with_p384 = [] -%}
+{%- set with_p521 = [] -%}
+{%- for sig in config['sigs'] -%}
+    {%- for variant in sig['variants'] -%}
+        {%- for classical_alg in variant['mix_with'] -%}
+            {%- if classical_alg.name == 'rsa3072' -%}
+                {%- do with_rsa3072.append(variant) -%}
+            {%- elif classical_alg.name == 'p256' -%}
+                {%- do with_p256.append(variant) -%}
+            {%- elif classical_alg.name == 'p384' -%}
+                {%- do with_p384.append(variant) -%}
+            {%- elif classical_alg.name == 'p521' -%}
+                {%- do with_p521.append(variant) -%}
+            {%- endif -%}
+        {%- endfor -%}
+    {%- endfor -%}
+{%- endfor %}
+#define CASE_KEY_RSA_HYBRID \
+{%- for pq_alg in with_rsa3072 %}
+	case KEY_RSA3072_{{ pq_alg['name'] }}{%- if not loop.last %}: \{% endif %}
+{%- endfor %}
+
+#define CASE_KEY_ECDSA_HYBRID \
+{%- for pq_alg in with_p256 %}
+	case KEY_P256_{{ pq_alg['name'] }}{%- if not loop.last or with_p384 or with_p521 %}: \ {%-endif %}
+{%- endfor %}
+{%- for pq_alg in with_p384 %}
+	case KEY_P384_{{ pq_alg['name'] }}{%- if not loop.last or with_p521 %}: \{% endif %}
+{%- endfor %}
+{%- for pq_alg in with_p521 %}
+	case KEY_P521_{{ pq_alg['name'] }}{%- if not loop.last %}: \{% endif %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/oqs-utils.h/define_pq_switch_cases.fragment
@@ -0,0 +1,9 @@
+
+#define CASE_KEY_OQS \
+{%- for sig in config['sigs'] -%}
+    {% set outer_loop_last = loop.last %}
+    {%- for variant in sig['variants'] %}
+	case KEY_{{ variant['name'] }}{% if not (outer_loop_last and loop.last) %}: \{% endif %}
+    {%- endfor -%}
+{% endfor %}
+
--- /dev/null
+++ b/oqs-template/pathnames.h/define_oqs_id_files.fragment
@@ -0,0 +1,13 @@
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+#define _PATH_SSH_CLIENT_ID_{{ variant['name'] }} _PATH_SSH_USER_DIR "/id_{{ variant['name']|lower|replace('_','') }}"
+    {%- endfor %}
+{%- endfor %}
+{%- for sig in config['sigs'] -%}
+    {%- for variant in sig['variants'] -%}
+        {%- for classical_alg in variant['mix_with'] %}
+#define _PATH_SSH_CLIENT_ID_{{ classical_alg.name|upper }}_{{ variant['name'] }} _PATH_SSH_USER_DIR "/id_{{ classical_alg.name }}_{{ variant['name']|lower|replace('_','') }}"
+        {%- endfor -%}
+    {%- endfor %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/pathnames.h/define_oqs_key_files.fragment
@@ -0,0 +1,13 @@
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+#define _PATH_HOST_{{ variant['name'] }}_KEY_FILE SSHDIR "/ssh_host_{{ variant['name']|lower|replace('_','') }}_key"
+    {%- endfor %}
+{%- endfor %}
+{%- for sig in config['sigs'] -%}
+    {%- for variant in sig['variants'] -%}
+        {%- for classical_alg in variant['mix_with'] %}
+#define _PATH_HOST_{{ classical_alg.name|upper }}_{{ variant['name'] }}_KEY_FILE SSHDIR "/ssh_host_{{ classical_alg.name }}_{{ variant['name']|lower|replace('_','') }}_key"
+        {%- endfor -%}
+    {%- endfor %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/readconf.c/add_hybrid_id_files.fragment
@@ -0,0 +1,8 @@
+{% for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] -%}
+        {%- for classical_alg in variant['mix_with'] %}
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_{{ classical_alg.name|upper }}_{{ variant['name'] }}, 0);
+        {%- endfor -%}
+    {%- endfor -%}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/readconf.c/add_pq_id_files.fragment
@@ -0,0 +1,6 @@
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_{{ variant['name'] }}, 0);
+    {%- endfor %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/regress/unittests/kex/test_kex.c/do_hybrid_kexs.fragment
@@ -0,0 +1,8 @@
+{%- for kem in config['kems'] %}
+#ifdef HAVE_{{ kem['family'] }}
+    {%- for variant in kem['variants'] %}
+	do_kex(KEX_ECDH_NISTP384_{{ variant['name'] }}_SHA384);
+    {%- endfor %}
+#endif /* HAVE_{{ kem['family'] }} */
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/regress/unittests/kex/test_kex.c/do_pq_kexs.fragment
@@ -0,0 +1,8 @@
+{%- for kem in config['kems'] %}
+#ifdef HAVE_{{ kem['family'] }}
+    {%- for variant in kem['variants'] %}
+	do_kex(KEX_{{ variant['name'] }}_SHA384);
+    {%- endfor %}
+#endif /* HAVE_{{ kem['family'] }} */
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/servconf.c/add_hybrid_hostkeys.fragment
@@ -0,0 +1,9 @@
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+        {%- for classical_alg in variant['mix_with'] %}
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_{{ classical_alg.name|upper }}_{{ variant['name'] }}_KEY_FILE);
+        {%- endfor -%}
+    {%- endfor %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/servconf.c/add_pq_hostkeys.fragment
@@ -0,0 +1,7 @@
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_{{ variant['name'] }}_KEY_FILE);
+    {%- endfor %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/ssh-add.c/list_hybrid_id_paths.fragment
@@ -0,0 +1,8 @@
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+        {%- for classical_alg in variant['mix_with'] %}
+	_PATH_SSH_CLIENT_ID_{{ classical_alg.name|upper }}_{{ variant['name'] }},
+        {%- endfor -%}
+    {%- endfor %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/ssh-add.c/list_pq_id_paths.fragment
@@ -0,0 +1,6 @@
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+	_PATH_SSH_CLIENT_ID_{{ variant['name'] }},
+    {%- endfor %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/ssh-keygen.c/add_hybrid_kt.fragment
@@ -0,0 +1,28 @@
+{%- set with_rsa = [] -%}
+{%- set with_ecdsa = [] -%}
+{%- for sig in config['sigs'] -%}
+    {%- for variant in sig['variants'] -%}
+        {%- for classical_alg in variant['mix_with'] -%}
+            {%- if classical_alg.name == 'rsa3072' -%}
+                {%- do with_rsa.append(variant) -%}
+            {%- elif classical_alg.name == 'p256' -%}
+                {%- do with_ecdsa.append({'name': variant['name'], 'curve':'p256'}) -%}
+            {%- elif classical_alg.name == 'p384' -%}
+                {%- do with_ecdsa.append({'name': variant['name'], 'curve':'p384'}) -%}
+            {%- elif classical_alg.name == 'p521' -%}
+                {%- do with_ecdsa.append({'name': variant['name'], 'curve':'p521'}) -%}
+            {%- endif -%}
+        {%- endfor -%}
+    {%- endfor -%}
+{%- endfor %}
+#ifdef WITH_OPENSSL
+{%- for pq_alg in with_rsa %}
+		{ "rsa3072_{{ pq_alg['name']|lower|replace('_','') }}", "RSA3072_{{ pq_alg['name'] }}", _PATH_HOST_RSA3072_{{ pq_alg['name'] }}_KEY_FILE },
+{%- endfor %}
+#ifdef OPENSSL_HAS_ECC
+{%- for pq_alg in with_ecdsa %}
+		{ "{{ pq_alg['curve']}}_{{ pq_alg['name']|lower|replace('_','') }}", "{{ pq_alg['curve']|upper }}_{{ pq_alg['name'] }}", _PATH_HOST_{{ pq_alg['curve']|upper }}_{{ pq_alg['name'] }}_KEY_FILE },
+{%- endfor %}
+#endif /* OPENSSL_HAS_ECC */
+#endif /* WITH_OPENSSL */
+
--- /dev/null
+++ b/oqs-template/ssh-keygen.c/add_pq_kt.fragment
@@ -0,0 +1,6 @@
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+		{ "{{ variant['name']|lower|replace('_','') }}", "{{ variant['name'] }}", _PATH_HOST_{{ variant['name'] }}_KEY_FILE },
+    {%- endfor %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/ssh-keygen.c/assign_pq_id_paths.fragment
@@ -0,0 +1,8 @@
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+		case KEY_{{ variant['name'] }}:
+			name = _PATH_SSH_CLIENT_ID_{{ variant['name'] }};
+			break;
+    {%- endfor %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/ssh-keygen.c/print_pq_rr.fragment
@@ -0,0 +1,7 @@
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+			n += do_print_resource_record(pw,
+                 _PATH_HOST_{{ variant['name'] }}_KEY_FILE, rr_hostname);
+    {%- endfor %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/ssh-keygen.c/set_bits.fragment
@@ -0,0 +1,23 @@
+{%- set with_p384 = [] -%}
+{%- set with_p521 = [] -%}
+{%- for sig in config['sigs'] -%}
+    {%- for variant in sig['variants'] -%}
+        {%- for classical_alg in variant['mix_with'] -%}
+            {%- if classical_alg.name == 'p384' -%}
+                {%- do with_p384.append(variant) -%}
+            {%- elif classical_alg.name == 'p521' -%}
+                {%- do with_p521.append(variant) -%}
+            {%- endif -%}
+        {%- endfor -%}
+    {%- endfor -%}
+{%- endfor %}
+{%- for pq_alg in with_p384 %}
+		case KEY_P384_{{ pq_alg['name'] }}:
+{%- endfor %}
+			*bitsp = 384;
+			break;
+{%- for pq_alg in with_p521 %}
+		case KEY_P521_{{ pq_alg['name'] }}:
+{%- endfor %}
+			*bitsp = 521;
+
--- /dev/null
+++ b/oqs-template/ssh-keyscan.c/assign_kt_markers.fragment
@@ -0,0 +1,22 @@
+{% set count = namespace(val=5) %}
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+#define KT_{{ variant['name'] }} ((uint64_t)1<<{{ count.val }})
+        {%- set count.val = count.val + 1 -%}
+    {%- endfor %}
+{%- endfor %}
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+        {%- for classical_alg in variant['mix_with'] %}
+#define KT_{{ classical_alg.name|upper }}_{{ variant['name'] }} ((uint64_t)1<<{{ count.val }})
+            {%- set count.val = count.val + 1 -%}
+        {%- endfor -%}
+    {%- endfor %}
+{%- endfor %}
+
+{% set last_sig = config['sigs']|last -%}
+{%- set last_variant = last_sig['variants']|last %}
+{%- set last_classical_alg = last_variant['mix_with']|last -%}
+#define KT_MIN KT_DSA
+#define KT_MAX KT_{{ last_classical_alg.name|upper }}_{{ last_variant['name'] }}
+
--- /dev/null
+++ b/oqs-template/ssh-keyscan.c/get_kt.fragment
@@ -0,0 +1,16 @@
+{% for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+                   KT_{{ variant['name'] }}| \
+    {%- endfor -%}
+{%- endfor -%}
+{%- set last_sig = config['sigs']|last -%}
+{%- set last_variant = last_sig['variants']|last -%}
+{%- set last_classical_alg = last_variant['mix_with']|last -%}
+{% for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] -%}
+        {%- for classical_alg in variant['mix_with'] %}
+                   KT_{{ classical_alg.name|upper }}_{{ variant['name'] }}{%- if (variant == last_variant) and (classical_alg.name == last_classical_alg.name) -%};{%- else -%}| \{%- endif -%}
+        {% endfor -%}
+    {%- endfor -%}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/ssh-keyscan.c/switch_kt.fragment
@@ -0,0 +1,17 @@
+{% for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+				case KEY_{{ variant['name'] }}:
+					get_keytypes |= KT_{{ variant['name'] }};
+					break;
+    {%- endfor -%}
+{%- endfor %}
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+        {%- for classical_alg in variant['mix_with'] %}
+				case KEY_{{ classical_alg.name|upper }}_{{ variant['name'] }}:
+					get_keytypes |= KT_{{ classical_alg.name|upper }}_{{ variant['name'] }};
+					break;
+        {%- endfor -%}
+    {%- endfor -%}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/ssh-keysign.c/count_kt.fragment
@@ -0,0 +1,11 @@
+{# Start at 6 after counting OpenSSH instrinsics #}
+{%- set count = namespace(val=5) -%}
+{%- for sig in config['sigs'] -%}
+    {%- for variant in sig['variants'] -%}
+        {%- set count.val = count.val + 1 -%}
+        {# Count hybrids #}
+        {%- set count.val = count.val + variant['mix_with']|length -%}
+    {%- endfor -%}
+{%- endfor %}
+#define NUM_KEYTYPES {{ count.val }}
+
--- /dev/null
+++ b/oqs-template/ssh-keysign.c/open_keyfiles.fragment
@@ -0,0 +1,13 @@
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+	key_fd[i++] = open(_PATH_HOST_{{ variant['name'] }}_KEY_FILE, O_RDONLY);
+    {%- endfor %}
+{%- endfor %}
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+        {%- for classical_alg in variant['mix_with'] %}
+	key_fd[i++] = open(_PATH_HOST_{{ classical_alg.name|upper }}_{{ variant['name'] }}_KEY_FILE, O_RDONLY);
+        {%- endfor -%}
+    {%- endfor -%}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/ssh-oqs.c/ossh_kt_to_oqs_meth.fragment
@@ -0,0 +1,10 @@
+{% for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+		case KEY_{{ variant['name'] }}:
+        {%- for classical_alg in variant['mix_with'] %}
+		case KEY_{{ classical_alg.name|upper }}_{{ variant['name'] }}:
+        {%- endfor %}
+			return {{ variant['oqs_meth'] }};
+    {%- endfor -%}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/ssh.c/count_keys.fragment
@@ -0,0 +1,11 @@
+{# Start at 10 after counting OpenSSH instrinsics #}
+{%- set count = namespace(val=10) -%}
+{%- for sig in config['sigs'] -%}
+    {%- for variant in sig['variants'] -%}
+        {%- set count.val = count.val + 1 -%}
+        {# Count hybrids #}
+        {%- set count.val = count.val + variant['mix_with']|length -%}
+    {%- endfor -%}
+{%- endfor %}
+		sensitive_data.nkeys = {{ count.val }};
+
--- /dev/null
+++ b/oqs-template/ssh.c/load_pubkeys.fragment
@@ -0,0 +1,16 @@
+{%- set count = namespace(val=10) %}
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+			L_PUBKEY(_PATH_HOST_{{ variant['name'] }}_KEY_FILE, {{ count.val }});
+        {%- set count.val = count.val + 1 -%}
+    {%- endfor -%}
+{%- endfor %}
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+        {%- for classical_alg in variant['mix_with'] %}
+			L_PUBKEY(_PATH_HOST_{{ classical_alg.name|upper }}_{{ variant['name'] }}_KEY_FILE, {{ count.val }});
+            {%- set count.val = count.val + 1 -%}
+        {%- endfor -%}
+    {%- endfor -%}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/ssh2.h/assign_hybrid_kex_markers.fragment
@@ -0,0 +1,4 @@
+{%- for kem in config['kems'] %}
+#define SSH2_MSG_HY_ECDH_{{ kem['family'] }}_INIT    30
+#define SSH2_MSG_HY_ECDH_{{ kem['family'] }}_REPLY   31
+{% endfor %}
--- /dev/null
+++ b/oqs-template/ssh2.h/assign_pq_kex_markers.fragment
@@ -0,0 +1,4 @@
+{%- for kem in config['kems'] %}
+#define SSH2_MSG_PQ_{{ kem['family'] }}_INIT    30
+#define SSH2_MSG_PQ_{{ kem['family'] }}_REPLY   31
+{% endfor %}
--- /dev/null
+++ b/oqs-template/sshconnect.c/list_kt.fragment
@@ -0,0 +1,13 @@
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+		KEY_{{ variant['name'] }},
+    {%- endfor %}
+{%- endfor %}
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+        {%- for classical_alg in variant['mix_with'] %}
+		KEY_{{ classical_alg.name|upper }}_{{ variant['name'] }},
+        {%- endfor -%}
+    {%- endfor -%}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/sshkey.c/add_hybrid_kt.fragment
@@ -0,0 +1,9 @@
+
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+        {%- for classical_alg in variant['mix_with'] %}
+	{ "ssh-{{ classical_alg.name }}-{{ variant['name']|lower|replace('_','') }}", "{{ classical_alg.name|upper }}_{{ variant['name']|replace('_','') }}", NULL, KEY_{{ classical_alg.name|upper }}_{{ variant['name'] }}, {% if classical_alg.curve -%}{{ classical_alg.curve }}{%- else -%}0{%- endif -%}, 0, 0 },
+        {%- endfor -%}
+    {%- endfor %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/sshkey.c/add_pq_kt.fragment
@@ -0,0 +1,6 @@
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+	{ "ssh-{{ variant['name']|lower|replace('_','') }}", "{{ variant['name']|replace('_','') }}", NULL, KEY_{{ variant['name'] }}, 0, 0, 0 },
+    {%- endfor %}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-template/sshkey.h/enum_kt.fragment
@@ -0,0 +1,13 @@
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+	KEY_{{ variant['name'] }},
+    {%- endfor %}
+{%- endfor %}
+{%- for sig in config['sigs'] %}
+    {%- for variant in sig['variants'] %}
+        {%- for classical_alg in variant['mix_with'] %}
+	KEY_{{ classical_alg.name|upper }}_{{ variant['name'] }},
+        {%- endfor -%}
+    {%- endfor -%}
+{%- endfor %}
+
--- /dev/null
+++ b/oqs-test/README.md
@@ -0,0 +1,61 @@
+OQS-OpenSSH Integration Testing
+===============================
+
+[![CircleCI](https://circleci.com/gh/open-quantum-safe/openssh-portable/tree/OQS-master.svg?style=svg)](https://circleci.com/gh/open-quantum-safe/openssh-portable/tree/OQS-master)
+
+---
+
+This directory contains scripts for testing the OQS fork of OpenSSH with liboqs, using all supported algorithms. The [README.md file for the OQS-OpenSSH fork](https://github.com/open-quantum-safe/openssh-portable/blob/OQS-master/README.md) describes the various key exchange and authentication mechanisms supported.
+
+First make sure you have **installed the dependencies** for the target OS as indicated in the [top-level testing README](https://github.com/open-quantum-safe/openssh-portable/blob/OQS-master/README.md).
+
+Testing on Linux and macOS
+--------------------------
+
+The scripts have been tested on macOS 10.14, Debian 10 (Buster), and Ubuntu 18.04 (Bionic).
+
+### Running directly
+
+Before running the script on Linux, you may need to create directories and users for OpenSSH privilege separation.  (On some Linux installations this will already exist, on others you may need to create it.)  Please try the following:
+
+1. Create the privilege separation directory:
+
+		sudo mkdir -p -m 0755 /var/empty
+
+2. Create the privilege separation user:
+
+		sudo groupadd sshd
+		sudo useradd -g sshd -c 'sshd privsep' -d /var/empty -s /bin/false sshd
+
+Then run:
+
+	cd oqs_test
+	./run.sh
+
+Alternatively, to log the run.sh output while following live, try:
+
+    ./run.sh | tee `date "+%Y%m%d-%Hh%Mm%Ss-openssh.log.txt"`
+
+### Running using CircleCI
+
+You can locally run any of the integration tests that CircleCI runs.  First, you need to install CircleCI's local command line interface as indicated in the [installation instructions](https://circleci.com/docs/2.0/local-cli/).  Then:
+
+	circleci local execute --job <jobname>
+
+where `<jobname>` is one of the following:
+
+- `ssh-amd64-buster-liboqs-master-with-openssl-with-pqauth`
+- `ssh-amd64-buster-liboqs-master-with-openssl-no-pqauth`
+- `ssh-amd64-buster-liboqs-master-no-openssl-no-pqauth`
+- `ssh-x86_64-bionic-liboqs-master-with-openssl-with-pqauth`
+- `ssh-x86_64-bionic-liboqs-master-with-openssl-no-pqauth`
+- `ssh-x86_64-bionic-liboqs-master-no-openssl-no-pqauth`
+
+By default, these jobs will use the current Github versions of liboqs and OQS-OpenSSH.  You can override these by passing environment variables to CircleCI:
+
+	circleci local execute --job <jobname> --env <NAME>=<VALUE> --env <NAME>=<VALUE> ...
+
+where `<NAME>` is one of the following:
+
+- `LIBOQS_REPO`: which repo to check out from, default `https://github.com/open-quantum-safe/liboqs.git`
+- `LIBOQS_BRANCH`: which branch to check out, default `master`
--- /dev/null
+++ b/oqs-test/do_openssh.sh
@@ -0,0 +1,77 @@
+#!/bin/bash
+
+###########
+# Run one client/server interaction in OpenSSH
+#
+# Environment variables:
+#  - KEXALG: key exchange algorithm to use
+#  - SIGALG: signature algorithm to use
+#  - PREFIX: path to install directory
+#  - PORT: port to run server on
+###########
+
+set -x
+
+OKAY=1
+
+PREFIX=${PREFIX:-"$(pwd)/oqs-test/tmp"}
+
+rm -f "${PREFIX}"/server_log.txt
+rm -f "${PREFIX}"/client_log.txt
+
+rm -f "${PREFIX}"/ssh_server/authorized_keys
+touch "${PREFIX}"/ssh_server/authorized_keys
+chmod 600 "${PREFIX}"/ssh_server/authorized_keys
+cat "${PREFIX}"/ssh_client/*.pub >> "${PREFIX}"/ssh_server/authorized_keys
+
+"${PREFIX}"/sbin/sshd -q -p "${PORT}" -d \
+  -f "${PREFIX}/sshd_config" \
+  -o "KexAlgorithms=${KEXALG}" \
+  -o "AuthorizedKeysFile=${PREFIX}/ssh_server/authorized_keys" \
+  -o "HostKeyAlgorithms=${SIGALG}" \
+  -o "PubkeyAcceptedKeyTypes=${SIGALG}" \
+  -o "StrictModes=no" \
+  -h "${PREFIX}/ssh_server/id_${SIGALG}" \
+  >> ${PREFIX}/server_log.txt 2>&1 &
+
+if [[ "${SIGALG}" =~ "rainbowi" ]]; then
+    sleep 10
+elif [[ "${SIGALG}" =~ "rainbowiii" ]]; then
+    sleep 20
+elif [[ "${SIGALG}" =~ "rainbowv" ]]; then
+    sleep 60
+else
+    sleep 2
+fi
+
+SERVER_PID=$!
+
+"${PREFIX}/bin/ssh" \
+  -p ${PORT} 127.0.0.1 \
+  -F ${PREFIX}/ssh_config \
+  -o "UserKnownHostsFile /dev/null" \
+  -o "KexAlgorithms=${KEXALG}" \
+  -o "HostKeyAlgorithms=${SIGALG}" \
+  -o "PubkeyAcceptedKeyTypes=${SIGALG}" \
+  -o StrictHostKeyChecking=no \
+  -i "${PREFIX}/ssh_client/id_${SIGALG}" \
+  "exit" \
+  >> ${PREFIX}/client_log.txt 2>&1
+
+kill -9 ${SERVER_PID}
+
+cat ${PREFIX}/client_log.txt | grep SSH_CONNECTION
+if [ $? -eq 0 ];then
+  OKAY=0
+fi
+
+echo "--- SERVER LOG ---"
+cat ${PREFIX}/server_log.txt
+
+echo "--- CLIENT LOG ---"
+cat ${PREFIX}/client_log.txt
+
+rm -f ${PREFIX}/server_log.txt
+rm -f ${PREFIX}/client_log.txt
+
+exit ${OKAY}
--- /dev/null
+++ b/oqs-test/helpers.py
@@ -0,0 +1,50 @@
+import os
+import subprocess
+
+def run_subprocess(command, working_dir='.', env=None, expected_returncode=0):
+    """
+    Helper function to run a shell command and report success/failure
+    depending on the exit status of the shell command.
+    """
+    if env is not None:
+        env_ = os.environ.copy()
+        env_.update(env)
+        env = env_
+
+    # Note we need to capture stdout/stderr from the subprocess,
+    # then print it, which nose/unittest will then capture and
+    # buffer appropriately
+    print(working_dir + " > " + " ".join(command))
+    result = subprocess.run(
+        command,
+        stdout=subprocess.PIPE,
+        stderr=subprocess.STDOUT,
+        cwd=working_dir,
+        env=env,
+    )
+    print(result.stdout.decode('utf-8'))
+    assert result.returncode == expected_returncode, \
+        "Got unexpected return code {}".format(result.returncode)
+    return result.stdout.decode('utf-8')
+
+def run_subprocess_fork(command, working_dir='.', env=None, expected_returncode=0):
+    """
+    Helper function to run a shell command and report success/failure
+    depending on the exit status of the shell command.
+    """
+    if env is not None:
+        env_ = os.environ.copy()
+        env_.update(env)
+        env = env_
+
+    # Note we need to capture stdout/stderr from the subprocess,
+    # then print it, which nose/unittest will then capture and
+    # buffer appropriately
+    print(working_dir + " > " + " ".join(command))
+    return subprocess.Popen(
+        command,
+        stdout=subprocess.PIPE,
+        stderr=subprocess.STDOUT,
+        cwd=working_dir,
+        env=env,
+    )
--- /dev/null
+++ b/oqs-test/test_openssh.py
@@ -0,0 +1,89 @@
+import helpers
+import os
+import sys
+import time
+
+sig_algs = ['ssh-ed25519']
+if 'WITH_PQAUTH' in os.environ and os.environ['WITH_PQAUTH'] == 'true':
+    # post-quantum
+    sig_algs += [
+##### OQS_TEMPLATE_FRAGMENT_LIST_SIGS_START
+    # post-quantum only sigs
+    'ssh-oqsdefault','ssh-dilithium2','ssh-falcon512','ssh-mqdss3148','ssh-picnicl1fs','ssh-picnic3l1','ssh-qteslapi','ssh-rainbowiaclassic','ssh-rainbowiiicclassic','ssh-rainbowvcclassic','ssh-sphincsharaka128frobust','ssh-sphincssha256128frobust','ssh-sphincsshake256128frobust',
+    # hybrid sigs
+    'ssh-rsa3072-oqsdefault','ssh-p256-oqsdefault','ssh-rsa3072-dilithium2','ssh-p256-dilithium2','ssh-rsa3072-falcon512','ssh-p256-falcon512','ssh-rsa3072-mqdss3148','ssh-p256-mqdss3148','ssh-rsa3072-picnicl1fs','ssh-p256-picnicl1fs','ssh-rsa3072-picnic3l1','ssh-p256-picnic3l1','ssh-rsa3072-qteslapi','ssh-p256-qteslapi','ssh-rsa3072-rainbowiaclassic','ssh-p256-rainbowiaclassic','ssh-p384-rainbowiiicclassic','ssh-p521-rainbowvcclassic','ssh-rsa3072-sphincsharaka128frobust','ssh-p256-sphincsharaka128frobust','ssh-rsa3072-sphincssha256128frobust','ssh-p256-sphincssha256128frobust','ssh-rsa3072-sphincsshake256128frobust','ssh-p256-sphincsshake256128frobust',
+##### OQS_TEMPLATE_FRAGMENT_LIST_SIGS_END
+]
+
+kex_algs = [
+##### OQS_TEMPLATE_FRAGMENT_LIST_KEXS_START
+    # post-quantum only kex
+    'bike1-l1-cpa-sha384@openquantumsafe.org','bike1-l3-cpa-sha384@openquantumsafe.org','bike1-l1-fo-sha384@openquantumsafe.org','bike1-l3-fo-sha384@openquantumsafe.org','classic-mceliece-348864-sha384@openquantumsafe.org','classic-mceliece-348864f-sha384@openquantumsafe.org','classic-mceliece-460896-sha384@openquantumsafe.org','classic-mceliece-460896f-sha384@openquantumsafe.org','classic-mceliece-6688128-sha384@openquantumsafe.org','classic-mceliece-6688128f-sha384@openquantumsafe.org','classic-mceliece-6960119-sha384@openquantumsafe.org','classic-mceliece-6960119f-sha384@openquantumsafe.org','classic-mceliece-8192128-sha384@openquantumsafe.org','classic-mceliece-8192128f-sha384@openquantumsafe.org','frodo-640-aes-sha384@openquantumsafe.org','frodo-640-shake-sha384@openquantumsafe.org','frodo-976-aes-sha384@openquantumsafe.org','frodo-976-shake-sha384@openquantumsafe.org','frodo-1344-aes-sha384@openquantumsafe.org','frodo-1344-shake-sha384@openquantumsafe.org','kyber-512-sha384@openquantumsafe.org','kyber-768-sha384@openquantumsafe.org','kyber-1024-sha384@openquantumsafe.org','kyber-512-90s-sha384@openquantumsafe.org','kyber-768-90s-sha384@openquantumsafe.org','kyber-1024-90s-sha384@openquantumsafe.org','newhope-512-sha384@openquantumsafe.org','newhope-1024-sha384@openquantumsafe.org','ntru-hps-2048-509-sha384@openquantumsafe.org','ntru-hps-2048-677-sha384@openquantumsafe.org','ntru-hrss-701-sha384@openquantumsafe.org','ntru-hps-4096-821-sha384@openquantumsafe.org','saber-lightsaber-sha384@openquantumsafe.org','saber-saber-sha384@openquantumsafe.org','saber-firesaber-sha384@openquantumsafe.org','sidh-p434-sha384@openquantumsafe.org','sidh-p503-sha384@openquantumsafe.org','sidh-p610-sha384@openquantumsafe.org','sidh-p751-sha384@openquantumsafe.org','sidh-p434-compressed-sha384@openquantumsafe.org','sidh-p503-compressed-sha384@openquantumsafe.org','sidh-p610-compressed-sha384@openquantumsafe.org','sidh-p751-compressed-sha384@openquantumsafe.org','sike-p434-sha384@openquantumsafe.org','sike-p503-sha384@openquantumsafe.org','sike-p610-sha384@openquantumsafe.org','sike-p751-sha384@openquantumsafe.org','-sha384@openquantumsafe.org','sike-p503-compressed-sha384@openquantumsafe.org','sike-p610-compressed-sha384@openquantumsafe.org','sike-p751-compressed-sha384@openquantumsafe.org','babybear-sha384@openquantumsafe.org','babybear-ephem-sha384@openquantumsafe.org','mamabear-sha384@openquantumsafe.org','mamabear-ephem-sha384@openquantumsafe.org','papabear-sha384@openquantumsafe.org','papabear-ephem-sha384@openquantumsafe.org','hqc-128-1-cca2-sha384@openquantumsafe.org','hqc-192-1-cca2-sha384@openquantumsafe.org','hqc-192-2-cca2-sha384@openquantumsafe.org','hqc-256-1-cca2-sha384@openquantumsafe.org','hqc-256-2-cca2-sha384@openquantumsafe.org','hqc-256-3-cca2-sha384@openquantumsafe.org',
+    # hybrid kex
+    'ecdh-nistp384-bike1-l1-cpa-sha384@openquantumsafe.org','ecdh-nistp384-bike1-l3-cpa-sha384@openquantumsafe.org','ecdh-nistp384-bike1-l1-fo-sha384@openquantumsafe.org','ecdh-nistp384-bike1-l3-fo-sha384@openquantumsafe.org','ecdh-nistp384-classic-mceliece-348864-sha384@openquantumsafe.org','ecdh-nistp384-classic-mceliece-348864f-sha384@openquantumsafe.org','ecdh-nistp384-classic-mceliece-460896-sha384@openquantumsafe.org','ecdh-nistp384-classic-mceliece-460896f-sha384@openquantumsafe.org','ecdh-nistp384-classic-mceliece-6688128-sha384@openquantumsafe.org','ecdh-nistp384-classic-mceliece-6688128f-sha384@openquantumsafe.org','ecdh-nistp384-classic-mceliece-6960119-sha384@openquantumsafe.org','ecdh-nistp384-classic-mceliece-6960119f-sha384@openquantumsafe.org','ecdh-nistp384-classic-mceliece-8192128-sha384@openquantumsafe.org','ecdh-nistp384-classic-mceliece-8192128f-sha384@openquantumsafe.org','ecdh-nistp384-frodo-640-aes-sha384@openquantumsafe.org','ecdh-nistp384-frodo-640-shake-sha384@openquantumsafe.org','ecdh-nistp384-frodo-976-aes-sha384@openquantumsafe.org','ecdh-nistp384-frodo-976-shake-sha384@openquantumsafe.org','ecdh-nistp384-frodo-1344-aes-sha384@openquantumsafe.org','ecdh-nistp384-frodo-1344-shake-sha384@openquantumsafe.org','ecdh-nistp384-kyber-512-sha384@openquantumsafe.org','ecdh-nistp384-kyber-768-sha384@openquantumsafe.org','ecdh-nistp384-kyber-1024-sha384@openquantumsafe.org','ecdh-nistp384-kyber-512-90s-sha384@openquantumsafe.org','ecdh-nistp384-kyber-768-90s-sha384@openquantumsafe.org','ecdh-nistp384-kyber-1024-90s-sha384@openquantumsafe.org','ecdh-nistp384-newhope-512-sha384@openquantumsafe.org','ecdh-nistp384-newhope-1024-sha384@openquantumsafe.org','ecdh-nistp384-ntru-hps-2048-509-sha384@openquantumsafe.org','ecdh-nistp384-ntru-hps-2048-677-sha384@openquantumsafe.org','ecdh-nistp384-ntru-hrss-701-sha384@openquantumsafe.org','ecdh-nistp384-ntru-hps-4096-821-sha384@openquantumsafe.org','ecdh-nistp384-saber-lightsaber-sha384@openquantumsafe.org','ecdh-nistp384-saber-saber-sha384@openquantumsafe.org','ecdh-nistp384-saber-firesaber-sha384@openquantumsafe.org','ecdh-nistp384-sidh-p434-sha384@openquantumsafe.org','ecdh-nistp384-sidh-p503-sha384@openquantumsafe.org','ecdh-nistp384-sidh-p610-sha384@openquantumsafe.org','ecdh-nistp384-sidh-p751-sha384@openquantumsafe.org','ecdh-nistp384-sidh-p434-compressed-sha384@openquantumsafe.org','ecdh-nistp384-sidh-p503-compressed-sha384@openquantumsafe.org','ecdh-nistp384-sidh-p610-compressed-sha384@openquantumsafe.org','ecdh-nistp384-sidh-p751-compressed-sha384@openquantumsafe.org','ecdh-nistp384-sike-p434-sha384@openquantumsafe.org','ecdh-nistp384-sike-p503-sha384@openquantumsafe.org','ecdh-nistp384-sike-p610-sha384@openquantumsafe.org','ecdh-nistp384-sike-p751-sha384@openquantumsafe.org','ecdh-nistp384--sha384@openquantumsafe.org','ecdh-nistp384-sike-p503-compressed-sha384@openquantumsafe.org','ecdh-nistp384-sike-p610-compressed-sha384@openquantumsafe.org','ecdh-nistp384-sike-p751-compressed-sha384@openquantumsafe.org','ecdh-nistp384-babybear-sha384@openquantumsafe.org','ecdh-nistp384-babybear-ephem-sha384@openquantumsafe.org','ecdh-nistp384-mamabear-sha384@openquantumsafe.org','ecdh-nistp384-mamabear-ephem-sha384@openquantumsafe.org','ecdh-nistp384-papabear-sha384@openquantumsafe.org','ecdh-nistp384-papabear-ephem-sha384@openquantumsafe.org','ecdh-nistp384-hqc-128-1-cca2-sha384@openquantumsafe.org','ecdh-nistp384-hqc-192-1-cca2-sha384@openquantumsafe.org','ecdh-nistp384-hqc-192-2-cca2-sha384@openquantumsafe.org','ecdh-nistp384-hqc-256-1-cca2-sha384@openquantumsafe.org','ecdh-nistp384-hqc-256-2-cca2-sha384@openquantumsafe.org','ecdh-nistp384-hqc-256-3-cca2-sha384@openquantumsafe.org',
+##### OQS_TEMPLATE_FRAGMENT_LIST_KEXS_END
+        ]
+
+
+def test_gen_keys():
+    global sig_algs
+    helpers.run_subprocess(
+        ['rm', '-rf', 'ssh_client'],
+        working_dir=os.path.join('oqs-test', 'tmp')
+    )
+    helpers.run_subprocess(
+        ['rm', '-rf', 'ssh_server'],
+        working_dir=os.path.join('oqs-test', 'tmp')
+    )
+    os.mkdir(os.path.join('oqs-test', 'tmp', 'ssh_client'), mode=0o700)
+    os.mkdir(os.path.join('oqs-test', 'tmp', 'ssh_server'), mode=0o700)
+    for party in ['client', 'server']:
+        for sig_alg in sig_algs:
+            yield (gen_keys, sig_alg, party)
+
+def gen_keys(sig_alg, party):
+    helpers.run_subprocess(
+        [
+            'bin/ssh-keygen',
+            '-t', sig_alg,
+            '-N', '',
+            '-f', os.path.join('ssh_{}'.format(party), 'id_{}'.format(sig_alg))
+        ],
+        os.path.join('oqs-test', 'tmp')
+    )
+
+def test_connection():
+    global sig_algs, kex_algs
+    port = 22345
+    for sig_alg in sig_algs:
+        if 'rainbow' in sig_alg:
+            # TODO: Revisit this after round 3 candidates come out
+            if 'classic-mceliece-8192128f-sha384@openquantumsafe.org' in kex_algs:
+                yield(run_connection, sig_alg, 'classic-mceliece-8192128f-sha384@openquantumsafe.org', port)
+            else:
+                yield(run_connection, sig_alg, kex_algs[0], port)
+            port = port + 1
+        else:
+            for kex_alg in kex_algs:
+                if ('WITH_OPENSSL' in os.environ and os.environ['WITH_OPENSSL'] != 'true') and ('ecdh' in kex_alg):
+                    continue
+                yield(run_connection, sig_alg, kex_alg, port)
+                port = port + 1
+
+def run_connection(sig_alg, kex_alg, port):
+    helpers.run_subprocess(
+        [os.path.join('oqs-test', 'do_openssh.sh')],
+        env={
+            'SIGALG': sig_alg,
+            'KEXALG': kex_alg,
+            'PORT': str(port),
+        }
+    )
+
+if __name__ == '__main__':
+    try:
+        import nose2
+        nose2.main()
+    except ImportError:
+        import nose
+        nose.runmodule()
--- /dev/null
+++ b/oqs-utils.h
@@ -0,0 +1,118 @@
+#ifndef OQS_UTIL_H
+#define OQS_UTIL_H
+
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_HYBRID_MACROS_START
+#define IS_RSA_HYBRID_ALG_NAME(alg) ( \
+				strcmp(alg, "ssh-rsa3072-oqsdefault") == 0 || \
+				strcmp(alg, "ssh-rsa3072-dilithium2") == 0 || \
+				strcmp(alg, "ssh-rsa3072-falcon512") == 0 || \
+				strcmp(alg, "ssh-rsa3072-mqdss3148") == 0 || \
+				strcmp(alg, "ssh-rsa3072-picnicl1fs") == 0 || \
+				strcmp(alg, "ssh-rsa3072-picnic3l1") == 0 || \
+				strcmp(alg, "ssh-rsa3072-qteslapi") == 0 || \
+				strcmp(alg, "ssh-rsa3072-rainbowiaclassic") == 0 || \
+				strcmp(alg, "ssh-rsa3072-sphincsharaka128frobust") == 0 || \
+				strcmp(alg, "ssh-rsa3072-sphincssha256128frobust") == 0 || \
+				strcmp(alg, "ssh-rsa3072-sphincsshake256128frobust") == 0)
+
+#define IS_RSA_HYBRID(alg) ( \
+				alg == KEY_RSA3072_OQSDEFAULT || \
+				alg == KEY_RSA3072_DILITHIUM_2 || \
+				alg == KEY_RSA3072_FALCON_512 || \
+				alg == KEY_RSA3072_MQDSS_31_48 || \
+				alg == KEY_RSA3072_PICNIC_L1FS || \
+				alg == KEY_RSA3072_PICNIC3_L1 || \
+				alg == KEY_RSA3072_QTESLA_P_I || \
+				alg == KEY_RSA3072_RAINBOW_IA_CLASSIC || \
+				alg == KEY_RSA3072_SPHINCS_HARAKA_128F_ROBUST || \
+				alg == KEY_RSA3072_SPHINCS_SHA256_128F_ROBUST || \
+				alg == KEY_RSA3072_SPHINCS_SHAKE256_128F_ROBUST)
+
+#define IS_ECDSA_HYBRID(alg) ( \
+				alg == KEY_P256_OQSDEFAULT || \
+				alg == KEY_P256_DILITHIUM_2 || \
+				alg == KEY_P256_FALCON_512 || \
+				alg == KEY_P256_MQDSS_31_48 || \
+				alg == KEY_P256_PICNIC_L1FS || \
+				alg == KEY_P256_PICNIC3_L1 || \
+				alg == KEY_P256_QTESLA_P_I || \
+				alg == KEY_P256_RAINBOW_IA_CLASSIC || \
+				alg == KEY_P256_SPHINCS_HARAKA_128F_ROBUST || \
+				alg == KEY_P256_SPHINCS_SHA256_128F_ROBUST || \
+				alg == KEY_P256_SPHINCS_SHAKE256_128F_ROBUST || \
+				alg == KEY_P384_RAINBOW_IIIC_CLASSIC || \
+				alg == KEY_P521_RAINBOW_VC_CLASSIC)
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_HYBRID_MACROS_END
+
+#define IS_HYBRID(alg) (IS_RSA_HYBRID(alg) || IS_ECDSA_HYBRID(alg))
+
+///// OQS_TEMPLATE_FRAGMENT_ASSIGN_PQ_KT_START
+#define IS_OQS_KEY_TYPE(type) ( \
+				(type) == KEY_OQSDEFAULT || \
+				(type) == KEY_DILITHIUM_2 || \
+				(type) == KEY_FALCON_512 || \
+				(type) == KEY_MQDSS_31_48 || \
+				(type) == KEY_PICNIC_L1FS || \
+				(type) == KEY_PICNIC3_L1 || \
+				(type) == KEY_QTESLA_P_I || \
+				(type) == KEY_RAINBOW_IA_CLASSIC || \
+				(type) == KEY_RAINBOW_IIIC_CLASSIC || \
+				(type) == KEY_RAINBOW_VC_CLASSIC || \
+				(type) == KEY_SPHINCS_HARAKA_128F_ROBUST || \
+				(type) == KEY_SPHINCS_SHA256_128F_ROBUST || \
+				(type) == KEY_SPHINCS_SHAKE256_128F_ROBUST || \
+				IS_HYBRID(type))
+///// OQS_TEMPLATE_FRAGMENT_ASSIGN_PQ_KT_END
+
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_PQ_SWITCH_CASES_START
+#define CASE_KEY_OQS \
+	case KEY_OQSDEFAULT: \
+	case KEY_DILITHIUM_2: \
+	case KEY_FALCON_512: \
+	case KEY_MQDSS_31_48: \
+	case KEY_PICNIC_L1FS: \
+	case KEY_PICNIC3_L1: \
+	case KEY_QTESLA_P_I: \
+	case KEY_RAINBOW_IA_CLASSIC: \
+	case KEY_RAINBOW_IIIC_CLASSIC: \
+	case KEY_RAINBOW_VC_CLASSIC: \
+	case KEY_SPHINCS_HARAKA_128F_ROBUST: \
+	case KEY_SPHINCS_SHA256_128F_ROBUST: \
+	case KEY_SPHINCS_SHAKE256_128F_ROBUST
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_PQ_SWITCH_CASES_END
+
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_HYBRID_SWITCH_CASES_START
+#define CASE_KEY_RSA_HYBRID \
+	case KEY_RSA3072_OQSDEFAULT: \
+	case KEY_RSA3072_DILITHIUM_2: \
+	case KEY_RSA3072_FALCON_512: \
+	case KEY_RSA3072_MQDSS_31_48: \
+	case KEY_RSA3072_PICNIC_L1FS: \
+	case KEY_RSA3072_PICNIC3_L1: \
+	case KEY_RSA3072_QTESLA_P_I: \
+	case KEY_RSA3072_RAINBOW_IA_CLASSIC: \
+	case KEY_RSA3072_SPHINCS_HARAKA_128F_ROBUST: \
+	case KEY_RSA3072_SPHINCS_SHA256_128F_ROBUST: \
+	case KEY_RSA3072_SPHINCS_SHAKE256_128F_ROBUST
+
+#define CASE_KEY_ECDSA_HYBRID \
+	case KEY_P256_OQSDEFAULT: \
+	case KEY_P256_DILITHIUM_2: \
+	case KEY_P256_FALCON_512: \
+	case KEY_P256_MQDSS_31_48: \
+	case KEY_P256_PICNIC_L1FS: \
+	case KEY_P256_PICNIC3_L1: \
+	case KEY_P256_QTESLA_P_I: \
+	case KEY_P256_RAINBOW_IA_CLASSIC: \
+	case KEY_P256_SPHINCS_HARAKA_128F_ROBUST: \
+	case KEY_P256_SPHINCS_SHA256_128F_ROBUST: \
+	case KEY_P256_SPHINCS_SHAKE256_128F_ROBUST: \
+	case KEY_P384_RAINBOW_IIIC_CLASSIC: \
+	case KEY_P521_RAINBOW_VC_CLASSIC
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_HYBRID_SWITCH_CASES_END
+
+#define CASE_KEY_HYBRID \
+	CASE_KEY_RSA_HYBRID: \
+	CASE_KEY_ECDSA_HYBRID
+
+#endif /* OQS_UTIL_H */
--- a/packet.c
+++ b/packet.c
@@ -99,7 +99,10 @@
 #define DBG(x)
 #endif
 
-#define PACKET_MAX_SIZE (256 * 1024)
+/* OQS note: We have increased this from
+ * (256 * 1024) to (2048 * 1024).
+ */
+#define PACKET_MAX_SIZE (2048 * 1024)
 
 struct packet_state {
 	u_int32_t seqnr;
--- a/pathnames.h
+++ b/pathnames.h
@@ -41,6 +41,45 @@
 #define _PATH_HOST_ED25519_KEY_FILE	SSHDIR "/ssh_host_ed25519_key"
 #define _PATH_HOST_XMSS_KEY_FILE	SSHDIR "/ssh_host_xmss_key"
 #define _PATH_HOST_RSA_KEY_FILE		SSHDIR "/ssh_host_rsa_key"
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_OQS_KEY_FILES_START
+#define _PATH_HOST_OQSDEFAULT_KEY_FILE SSHDIR "/ssh_host_oqsdefault_key"
+#define _PATH_HOST_DILITHIUM_2_KEY_FILE SSHDIR "/ssh_host_dilithium2_key"
+#define _PATH_HOST_FALCON_512_KEY_FILE SSHDIR "/ssh_host_falcon512_key"
+#define _PATH_HOST_MQDSS_31_48_KEY_FILE SSHDIR "/ssh_host_mqdss3148_key"
+#define _PATH_HOST_PICNIC_L1FS_KEY_FILE SSHDIR "/ssh_host_picnicl1fs_key"
+#define _PATH_HOST_PICNIC3_L1_KEY_FILE SSHDIR "/ssh_host_picnic3l1_key"
+#define _PATH_HOST_QTESLA_P_I_KEY_FILE SSHDIR "/ssh_host_qteslapi_key"
+#define _PATH_HOST_RAINBOW_IA_CLASSIC_KEY_FILE SSHDIR "/ssh_host_rainbowiaclassic_key"
+#define _PATH_HOST_RAINBOW_IIIC_CLASSIC_KEY_FILE SSHDIR "/ssh_host_rainbowiiicclassic_key"
+#define _PATH_HOST_RAINBOW_VC_CLASSIC_KEY_FILE SSHDIR "/ssh_host_rainbowvcclassic_key"
+#define _PATH_HOST_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE SSHDIR "/ssh_host_sphincsharaka128frobust_key"
+#define _PATH_HOST_SPHINCS_SHA256_128F_ROBUST_KEY_FILE SSHDIR "/ssh_host_sphincssha256128frobust_key"
+#define _PATH_HOST_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE SSHDIR "/ssh_host_sphincsshake256128frobust_key"
+#define _PATH_HOST_RSA3072_OQSDEFAULT_KEY_FILE SSHDIR "/ssh_host_rsa3072_oqsdefault_key"
+#define _PATH_HOST_P256_OQSDEFAULT_KEY_FILE SSHDIR "/ssh_host_p256_oqsdefault_key"
+#define _PATH_HOST_RSA3072_DILITHIUM_2_KEY_FILE SSHDIR "/ssh_host_rsa3072_dilithium2_key"
+#define _PATH_HOST_P256_DILITHIUM_2_KEY_FILE SSHDIR "/ssh_host_p256_dilithium2_key"
+#define _PATH_HOST_RSA3072_FALCON_512_KEY_FILE SSHDIR "/ssh_host_rsa3072_falcon512_key"
+#define _PATH_HOST_P256_FALCON_512_KEY_FILE SSHDIR "/ssh_host_p256_falcon512_key"
+#define _PATH_HOST_RSA3072_MQDSS_31_48_KEY_FILE SSHDIR "/ssh_host_rsa3072_mqdss3148_key"
+#define _PATH_HOST_P256_MQDSS_31_48_KEY_FILE SSHDIR "/ssh_host_p256_mqdss3148_key"
+#define _PATH_HOST_RSA3072_PICNIC_L1FS_KEY_FILE SSHDIR "/ssh_host_rsa3072_picnicl1fs_key"
+#define _PATH_HOST_P256_PICNIC_L1FS_KEY_FILE SSHDIR "/ssh_host_p256_picnicl1fs_key"
+#define _PATH_HOST_RSA3072_PICNIC3_L1_KEY_FILE SSHDIR "/ssh_host_rsa3072_picnic3l1_key"
+#define _PATH_HOST_P256_PICNIC3_L1_KEY_FILE SSHDIR "/ssh_host_p256_picnic3l1_key"
+#define _PATH_HOST_RSA3072_QTESLA_P_I_KEY_FILE SSHDIR "/ssh_host_rsa3072_qteslapi_key"
+#define _PATH_HOST_P256_QTESLA_P_I_KEY_FILE SSHDIR "/ssh_host_p256_qteslapi_key"
+#define _PATH_HOST_RSA3072_RAINBOW_IA_CLASSIC_KEY_FILE SSHDIR "/ssh_host_rsa3072_rainbowiaclassic_key"
+#define _PATH_HOST_P256_RAINBOW_IA_CLASSIC_KEY_FILE SSHDIR "/ssh_host_p256_rainbowiaclassic_key"
+#define _PATH_HOST_P384_RAINBOW_IIIC_CLASSIC_KEY_FILE SSHDIR "/ssh_host_p384_rainbowiiicclassic_key"
+#define _PATH_HOST_P521_RAINBOW_VC_CLASSIC_KEY_FILE SSHDIR "/ssh_host_p521_rainbowvcclassic_key"
+#define _PATH_HOST_RSA3072_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE SSHDIR "/ssh_host_rsa3072_sphincsharaka128frobust_key"
+#define _PATH_HOST_P256_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE SSHDIR "/ssh_host_p256_sphincsharaka128frobust_key"
+#define _PATH_HOST_RSA3072_SPHINCS_SHA256_128F_ROBUST_KEY_FILE SSHDIR "/ssh_host_rsa3072_sphincssha256128frobust_key"
+#define _PATH_HOST_P256_SPHINCS_SHA256_128F_ROBUST_KEY_FILE SSHDIR "/ssh_host_p256_sphincssha256128frobust_key"
+#define _PATH_HOST_RSA3072_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE SSHDIR "/ssh_host_rsa3072_sphincsshake256128frobust_key"
+#define _PATH_HOST_P256_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE SSHDIR "/ssh_host_p256_sphincsshake256128frobust_key"
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_OQS_KEY_FILES_END
 #define _PATH_DH_MODULI			SSHDIR "/moduli"
 
 #ifndef _PATH_SSH_PROGRAM
@@ -77,6 +116,45 @@
 #define _PATH_SSH_CLIENT_ID_RSA		_PATH_SSH_USER_DIR "/id_rsa"
 #define _PATH_SSH_CLIENT_ID_ED25519	_PATH_SSH_USER_DIR "/id_ed25519"
 #define _PATH_SSH_CLIENT_ID_XMSS	_PATH_SSH_USER_DIR "/id_xmss"
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_OQS_ID_FILES_START
+#define _PATH_SSH_CLIENT_ID_OQSDEFAULT _PATH_SSH_USER_DIR "/id_oqsdefault"
+#define _PATH_SSH_CLIENT_ID_DILITHIUM_2 _PATH_SSH_USER_DIR "/id_dilithium2"
+#define _PATH_SSH_CLIENT_ID_FALCON_512 _PATH_SSH_USER_DIR "/id_falcon512"
+#define _PATH_SSH_CLIENT_ID_MQDSS_31_48 _PATH_SSH_USER_DIR "/id_mqdss3148"
+#define _PATH_SSH_CLIENT_ID_PICNIC_L1FS _PATH_SSH_USER_DIR "/id_picnicl1fs"
+#define _PATH_SSH_CLIENT_ID_PICNIC3_L1 _PATH_SSH_USER_DIR "/id_picnic3l1"
+#define _PATH_SSH_CLIENT_ID_QTESLA_P_I _PATH_SSH_USER_DIR "/id_qteslapi"
+#define _PATH_SSH_CLIENT_ID_RAINBOW_IA_CLASSIC _PATH_SSH_USER_DIR "/id_rainbowiaclassic"
+#define _PATH_SSH_CLIENT_ID_RAINBOW_IIIC_CLASSIC _PATH_SSH_USER_DIR "/id_rainbowiiicclassic"
+#define _PATH_SSH_CLIENT_ID_RAINBOW_VC_CLASSIC _PATH_SSH_USER_DIR "/id_rainbowvcclassic"
+#define _PATH_SSH_CLIENT_ID_SPHINCS_HARAKA_128F_ROBUST _PATH_SSH_USER_DIR "/id_sphincsharaka128frobust"
+#define _PATH_SSH_CLIENT_ID_SPHINCS_SHA256_128F_ROBUST _PATH_SSH_USER_DIR "/id_sphincssha256128frobust"
+#define _PATH_SSH_CLIENT_ID_SPHINCS_SHAKE256_128F_ROBUST _PATH_SSH_USER_DIR "/id_sphincsshake256128frobust"
+#define _PATH_SSH_CLIENT_ID_RSA3072_OQSDEFAULT _PATH_SSH_USER_DIR "/id_rsa3072_oqsdefault"
+#define _PATH_SSH_CLIENT_ID_P256_OQSDEFAULT _PATH_SSH_USER_DIR "/id_p256_oqsdefault"
+#define _PATH_SSH_CLIENT_ID_RSA3072_DILITHIUM_2 _PATH_SSH_USER_DIR "/id_rsa3072_dilithium2"
+#define _PATH_SSH_CLIENT_ID_P256_DILITHIUM_2 _PATH_SSH_USER_DIR "/id_p256_dilithium2"
+#define _PATH_SSH_CLIENT_ID_RSA3072_FALCON_512 _PATH_SSH_USER_DIR "/id_rsa3072_falcon512"
+#define _PATH_SSH_CLIENT_ID_P256_FALCON_512 _PATH_SSH_USER_DIR "/id_p256_falcon512"
+#define _PATH_SSH_CLIENT_ID_RSA3072_MQDSS_31_48 _PATH_SSH_USER_DIR "/id_rsa3072_mqdss3148"
+#define _PATH_SSH_CLIENT_ID_P256_MQDSS_31_48 _PATH_SSH_USER_DIR "/id_p256_mqdss3148"
+#define _PATH_SSH_CLIENT_ID_RSA3072_PICNIC_L1FS _PATH_SSH_USER_DIR "/id_rsa3072_picnicl1fs"
+#define _PATH_SSH_CLIENT_ID_P256_PICNIC_L1FS _PATH_SSH_USER_DIR "/id_p256_picnicl1fs"
+#define _PATH_SSH_CLIENT_ID_RSA3072_PICNIC3_L1 _PATH_SSH_USER_DIR "/id_rsa3072_picnic3l1"
+#define _PATH_SSH_CLIENT_ID_P256_PICNIC3_L1 _PATH_SSH_USER_DIR "/id_p256_picnic3l1"
+#define _PATH_SSH_CLIENT_ID_RSA3072_QTESLA_P_I _PATH_SSH_USER_DIR "/id_rsa3072_qteslapi"
+#define _PATH_SSH_CLIENT_ID_P256_QTESLA_P_I _PATH_SSH_USER_DIR "/id_p256_qteslapi"
+#define _PATH_SSH_CLIENT_ID_RSA3072_RAINBOW_IA_CLASSIC _PATH_SSH_USER_DIR "/id_rsa3072_rainbowiaclassic"
+#define _PATH_SSH_CLIENT_ID_P256_RAINBOW_IA_CLASSIC _PATH_SSH_USER_DIR "/id_p256_rainbowiaclassic"
+#define _PATH_SSH_CLIENT_ID_P384_RAINBOW_IIIC_CLASSIC _PATH_SSH_USER_DIR "/id_p384_rainbowiiicclassic"
+#define _PATH_SSH_CLIENT_ID_P521_RAINBOW_VC_CLASSIC _PATH_SSH_USER_DIR "/id_p521_rainbowvcclassic"
+#define _PATH_SSH_CLIENT_ID_RSA3072_SPHINCS_HARAKA_128F_ROBUST _PATH_SSH_USER_DIR "/id_rsa3072_sphincsharaka128frobust"
+#define _PATH_SSH_CLIENT_ID_P256_SPHINCS_HARAKA_128F_ROBUST _PATH_SSH_USER_DIR "/id_p256_sphincsharaka128frobust"
+#define _PATH_SSH_CLIENT_ID_RSA3072_SPHINCS_SHA256_128F_ROBUST _PATH_SSH_USER_DIR "/id_rsa3072_sphincssha256128frobust"
+#define _PATH_SSH_CLIENT_ID_P256_SPHINCS_SHA256_128F_ROBUST _PATH_SSH_USER_DIR "/id_p256_sphincssha256128frobust"
+#define _PATH_SSH_CLIENT_ID_RSA3072_SPHINCS_SHAKE256_128F_ROBUST _PATH_SSH_USER_DIR "/id_rsa3072_sphincsshake256128frobust"
+#define _PATH_SSH_CLIENT_ID_P256_SPHINCS_SHAKE256_128F_ROBUST _PATH_SSH_USER_DIR "/id_p256_sphincsshake256128frobust"
+///// OQS_TEMPLATE_FRAGMENT_DEFINE_OQS_ID_FILES_END
 
 /*
  * Configuration file in user's home directory.  This file need not be
--- a/readconf.c
+++ b/readconf.c
@@ -2074,6 +2074,51 @@
 		add_identity_file(options, "~/",
 		    _PATH_SSH_CLIENT_ID_ED25519, 0);
 		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_XMSS, 0);
+#ifdef WITH_PQ_AUTH
+///// OQS_TEMPLATE_FRAGMENT_ADD_PQ_ID_FILES_START
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_OQSDEFAULT, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_DILITHIUM_2, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_FALCON_512, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_MQDSS_31_48, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_PICNIC_L1FS, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_PICNIC3_L1, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_QTESLA_P_I, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_RAINBOW_IA_CLASSIC, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_RAINBOW_IIIC_CLASSIC, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_RAINBOW_VC_CLASSIC, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_SPHINCS_HARAKA_128F_ROBUST, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_SPHINCS_SHA256_128F_ROBUST, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_SPHINCS_SHAKE256_128F_ROBUST, 0);
+///// OQS_TEMPLATE_FRAGMENT_ADD_PQ_ID_FILES_END
+#endif /* WITH_PQ_AUTH */
+#ifdef WITH_HYBRID_AUTH
+///// OQS_TEMPLATE_FRAGMENT_ADD_HYBRID_ID_FILES_START
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_RSA3072_OQSDEFAULT, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_P256_OQSDEFAULT, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_RSA3072_DILITHIUM_2, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_P256_DILITHIUM_2, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_RSA3072_FALCON_512, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_P256_FALCON_512, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_RSA3072_MQDSS_31_48, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_P256_MQDSS_31_48, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_RSA3072_PICNIC_L1FS, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_P256_PICNIC_L1FS, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_RSA3072_PICNIC3_L1, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_P256_PICNIC3_L1, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_RSA3072_QTESLA_P_I, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_P256_QTESLA_P_I, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_RSA3072_RAINBOW_IA_CLASSIC, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_P256_RAINBOW_IA_CLASSIC, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_P384_RAINBOW_IIIC_CLASSIC, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_P521_RAINBOW_VC_CLASSIC, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_RSA3072_SPHINCS_HARAKA_128F_ROBUST, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_P256_SPHINCS_HARAKA_128F_ROBUST, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_RSA3072_SPHINCS_SHA256_128F_ROBUST, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_P256_SPHINCS_SHA256_128F_ROBUST, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_RSA3072_SPHINCS_SHAKE256_128F_ROBUST, 0);
+		add_identity_file(options, "~/", _PATH_SSH_CLIENT_ID_P256_SPHINCS_SHAKE256_128F_ROBUST, 0);
+///// OQS_TEMPLATE_FRAGMENT_ADD_HYBRID_ID_FILES_END
+#endif /* WITH_HYBRID_AUTH */
 	}
 	if (options->escape_char == -1)
 		options->escape_char = '~';
--- a/regress/misc/kexfuzz/kexfuzz.c
+++ b/regress/misc/kexfuzz/kexfuzz.c
@@ -284,8 +284,10 @@
 	server2->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;
 # ifdef OPENSSL_HAS_ECC
 	server2->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;
+	server2->kex->kex[KEX_HY_ECDH_OQS] = get_hybrid_ecdh_oqs_server_cb();
 # endif
 #endif
+	server2->kex->kex[KEX_PQ_OQS] = get_pq_oqs_server_cb();
 	server2->kex->kex[KEX_C25519_SHA256] = kexc25519_server;
 	server2->kex->load_host_public_key = server->kex->load_host_public_key;
 	server2->kex->load_host_private_key = server->kex->load_host_private_key;
--- a/regress/unittests/kex/Makefile
+++ b/regress/unittests/kex/Makefile
@@ -11,6 +11,8 @@
 SRCS+=addrmatch.c bitmap.c packet.c dispatch.c canohost.c ssh_api.c
 SRCS+=kex.c kexc25519.c kexc25519c.c kexc25519s.c kexdh.c kexdhc.c kexdhs.c
 SRCS+=kexecdh.c kexecdhc.c kexecdhs.c kexgex.c kexgexc.c kexgexs.c
+SRCS+=kexoqs.c kexhyecdh.c kexhyecdhoqs.c kexhyecdhoqsc.c kexhyecdhoqss.c
+SRCS+=kexpqoqs.c kexpqoqsc.c kexpqoqss.c
 SRCS+=dh.c compat.c
 SRCS+=ed25519.c hash.c ge25519.c fe25519.c sc25519.c verify.c
 SRCS+=cipher-chachapoly.c chacha.c poly1305.c
@@ -26,4 +28,4 @@
 
 .include <bsd.regress.mk>
 
-LDADD+=-lz
+LDADD+=-lz -loqs
--- a/regress/unittests/kex/test_kex.c
+++ b/regress/unittests/kex/test_kex.c
@@ -151,7 +151,9 @@
 	server2->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;
 #ifdef OPENSSL_HAS_ECC
 	server2->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;
+	server2->kex->kex[KEX_HY_ECDH_OQS] = get_hybrid_ecdh_oqs_server_cb();
 #endif
+	server2->kex->kex[KEX_PQ_OQS] = get_pq_oqs_server_cb();
 	server2->kex->kex[KEX_C25519_SHA256] = kexc25519_server;
 	server2->kex->load_host_public_key = server->kex->load_host_public_key;
 	server2->kex->load_host_private_key = server->kex->load_host_private_key;
@@ -194,9 +196,189 @@
 	do_kex("ecdh-sha2-nistp256");
 	do_kex("ecdh-sha2-nistp384");
 	do_kex("ecdh-sha2-nistp521");
-#endif
+#if defined(WITH_OQS) && defined(WITH_HYBRID_KEX)
+	do_kex(KEX_ECDH_NISTP384_OQSDEFAULT_SHA384);
+///// OQS_TEMPLATE_FRAGMENT_DO_HYBRID_KEXS_START
+#ifdef HAVE_BIKE
+	do_kex(KEX_ECDH_NISTP384_BIKE1_L1_CPA_SHA384);
+	do_kex(KEX_ECDH_NISTP384_BIKE1_L3_CPA_SHA384);
+	do_kex(KEX_ECDH_NISTP384_BIKE1_L1_FO_SHA384);
+	do_kex(KEX_ECDH_NISTP384_BIKE1_L3_FO_SHA384);
+#endif /* HAVE_BIKE */
+#ifdef HAVE_CLASSIC_MCELIECE
+	do_kex(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_348864_SHA384);
+	do_kex(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_348864F_SHA384);
+	do_kex(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_460896_SHA384);
+	do_kex(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_460896F_SHA384);
+	do_kex(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_6688128_SHA384);
+	do_kex(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_6688128F_SHA384);
+	do_kex(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_6960119_SHA384);
+	do_kex(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_6960119F_SHA384);
+	do_kex(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_8192128_SHA384);
+	do_kex(KEX_ECDH_NISTP384_CLASSIC_MCELIECE_8192128F_SHA384);
+#endif /* HAVE_CLASSIC_MCELIECE */
+#ifdef HAVE_FRODO
+	do_kex(KEX_ECDH_NISTP384_FRODO_640_AES_SHA384);
+	do_kex(KEX_ECDH_NISTP384_FRODO_640_SHAKE_SHA384);
+	do_kex(KEX_ECDH_NISTP384_FRODO_976_AES_SHA384);
+	do_kex(KEX_ECDH_NISTP384_FRODO_976_SHAKE_SHA384);
+	do_kex(KEX_ECDH_NISTP384_FRODO_1344_AES_SHA384);
+	do_kex(KEX_ECDH_NISTP384_FRODO_1344_SHAKE_SHA384);
+#endif /* HAVE_FRODO */
+#ifdef HAVE_KYBER
+	do_kex(KEX_ECDH_NISTP384_KYBER_512_SHA384);
+	do_kex(KEX_ECDH_NISTP384_KYBER_768_SHA384);
+	do_kex(KEX_ECDH_NISTP384_KYBER_1024_SHA384);
+	do_kex(KEX_ECDH_NISTP384_KYBER_512_90S_SHA384);
+	do_kex(KEX_ECDH_NISTP384_KYBER_768_90S_SHA384);
+	do_kex(KEX_ECDH_NISTP384_KYBER_1024_90S_SHA384);
+#endif /* HAVE_KYBER */
+#ifdef HAVE_NEWHOPE
+	do_kex(KEX_ECDH_NISTP384_NEWHOPE_512_SHA384);
+	do_kex(KEX_ECDH_NISTP384_NEWHOPE_1024_SHA384);
+#endif /* HAVE_NEWHOPE */
+#ifdef HAVE_NTRU
+	do_kex(KEX_ECDH_NISTP384_NTRU_HPS_2048_509_SHA384);
+	do_kex(KEX_ECDH_NISTP384_NTRU_HPS_2048_677_SHA384);
+	do_kex(KEX_ECDH_NISTP384_NTRU_HRSS_701_SHA384);
+	do_kex(KEX_ECDH_NISTP384_NTRU_HPS_4096_821_SHA384);
+#endif /* HAVE_NTRU */
+#ifdef HAVE_SABER
+	do_kex(KEX_ECDH_NISTP384_SABER_LIGHTSABER_SHA384);
+	do_kex(KEX_ECDH_NISTP384_SABER_SABER_SHA384);
+	do_kex(KEX_ECDH_NISTP384_SABER_FIRESABER_SHA384);
+#endif /* HAVE_SABER */
+#ifdef HAVE_SIDH
+	do_kex(KEX_ECDH_NISTP384_SIDH_p434_SHA384);
+	do_kex(KEX_ECDH_NISTP384_SIDH_p503_SHA384);
+	do_kex(KEX_ECDH_NISTP384_SIDH_p610_SHA384);
+	do_kex(KEX_ECDH_NISTP384_SIDH_p751_SHA384);
+	do_kex(KEX_ECDH_NISTP384_SIDH_P434_COMPRESSED_SHA384);
+	do_kex(KEX_ECDH_NISTP384_SIDH_P503_COMPRESSED_SHA384);
+	do_kex(KEX_ECDH_NISTP384_SIDH_P610_COMPRESSED_SHA384);
+	do_kex(KEX_ECDH_NISTP384_SIDH_P751_COMPRESSED_SHA384);
+#endif /* HAVE_SIDH */
+#ifdef HAVE_SIKE
+	do_kex(KEX_ECDH_NISTP384_SIKE_P434_SHA384);
+	do_kex(KEX_ECDH_NISTP384_SIKE_P503_SHA384);
+	do_kex(KEX_ECDH_NISTP384_SIKE_P610_SHA384);
+	do_kex(KEX_ECDH_NISTP384_SIKE_P751_SHA384);
+	do_kex(KEX_ECDH_NISTP384__SHA384);
+	do_kex(KEX_ECDH_NISTP384_SIKE_P503_COMPRESSED_SHA384);
+	do_kex(KEX_ECDH_NISTP384_SIKE_P610_COMPRESSED_SHA384);
+	do_kex(KEX_ECDH_NISTP384_SIKE_P751_COMPRESSED_SHA384);
+#endif /* HAVE_SIKE */
+#ifdef HAVE_THREEBEARS
+	do_kex(KEX_ECDH_NISTP384_BABYBEAR_SHA384);
+	do_kex(KEX_ECDH_NISTP384_BABYBEAR_EPHEM_SHA384);
+	do_kex(KEX_ECDH_NISTP384_MAMABEAR_SHA384);
+	do_kex(KEX_ECDH_NISTP384_MAMABEAR_EPHEM_SHA384);
+	do_kex(KEX_ECDH_NISTP384_PAPABEAR_SHA384);
+	do_kex(KEX_ECDH_NISTP384_PAPABEAR_EPHEM_SHA384);
+#endif /* HAVE_THREEBEARS */
+#ifdef HAVE_HQC
+	do_kex(KEX_ECDH_NISTP384_HQC_128_1_CCA2_SHA384);
+	do_kex(KEX_ECDH_NISTP384_HQC_192_1_CCA2_SHA384);
+	do_kex(KEX_ECDH_NISTP384_HQC_192_2_CCA2_SHA384);
+	do_kex(KEX_ECDH_NISTP384_HQC_256_1_CCA2_SHA384);
+	do_kex(KEX_ECDH_NISTP384_HQC_256_2_CCA2_SHA384);
+	do_kex(KEX_ECDH_NISTP384_HQC_256_3_CCA2_SHA384);
+#endif /* HAVE_HQC */
+///// OQS_TEMPLATE_FRAGMENT_DO_HYBRID_KEXS_END
+#endif /* defined(WITH_OQS) && defined(WITH_HYBRID_KEX) */
+#endif /* OPENSSL_HAS_ECC */
 	do_kex("diffie-hellman-group-exchange-sha256");
 	do_kex("diffie-hellman-group-exchange-sha1");
 	do_kex("diffie-hellman-group14-sha1");
 	do_kex("diffie-hellman-group1-sha1");
+#if defined(WITH_OQS) && defined(WITH_OQ_KEX)
+	do_kex(KEX_OQSDEFAULT_SHA384);
+///// OQS_TEMPLATE_FRAGMENT_DO_PQ_KEXS_START
+#ifdef HAVE_BIKE
+	do_kex(KEX_BIKE1_L1_CPA_SHA384);
+	do_kex(KEX_BIKE1_L3_CPA_SHA384);
+	do_kex(KEX_BIKE1_L1_FO_SHA384);
+	do_kex(KEX_BIKE1_L3_FO_SHA384);
+#endif /* HAVE_BIKE */
+#ifdef HAVE_CLASSIC_MCELIECE
+	do_kex(KEX_CLASSIC_MCELIECE_348864_SHA384);
+	do_kex(KEX_CLASSIC_MCELIECE_348864F_SHA384);
+	do_kex(KEX_CLASSIC_MCELIECE_460896_SHA384);
+	do_kex(KEX_CLASSIC_MCELIECE_460896F_SHA384);
+	do_kex(KEX_CLASSIC_MCELIECE_6688128_SHA384);
+	do_kex(KEX_CLASSIC_MCELIECE_6688128F_SHA384);
+	do_kex(KEX_CLASSIC_MCELIECE_6960119_SHA384);
+	do_kex(KEX_CLASSIC_MCELIECE_6960119F_SHA384);
+	do_kex(KEX_CLASSIC_MCELIECE_8192128_SHA384);
+	do_kex(KEX_CLASSIC_MCELIECE_8192128F_SHA384);
+#endif /* HAVE_CLASSIC_MCELIECE */
+#ifdef HAVE_FRODO
+	do_kex(KEX_FRODO_640_AES_SHA384);
+	do_kex(KEX_FRODO_640_SHAKE_SHA384);
+	do_kex(KEX_FRODO_976_AES_SHA384);
+	do_kex(KEX_FRODO_976_SHAKE_SHA384);
+	do_kex(KEX_FRODO_1344_AES_SHA384);
+	do_kex(KEX_FRODO_1344_SHAKE_SHA384);
+#endif /* HAVE_FRODO */
+#ifdef HAVE_KYBER
+	do_kex(KEX_KYBER_512_SHA384);
+	do_kex(KEX_KYBER_768_SHA384);
+	do_kex(KEX_KYBER_1024_SHA384);
+	do_kex(KEX_KYBER_512_90S_SHA384);
+	do_kex(KEX_KYBER_768_90S_SHA384);
+	do_kex(KEX_KYBER_1024_90S_SHA384);
+#endif /* HAVE_KYBER */
+#ifdef HAVE_NEWHOPE
+	do_kex(KEX_NEWHOPE_512_SHA384);
+	do_kex(KEX_NEWHOPE_1024_SHA384);
+#endif /* HAVE_NEWHOPE */
+#ifdef HAVE_NTRU
+	do_kex(KEX_NTRU_HPS_2048_509_SHA384);
+	do_kex(KEX_NTRU_HPS_2048_677_SHA384);
+	do_kex(KEX_NTRU_HRSS_701_SHA384);
+	do_kex(KEX_NTRU_HPS_4096_821_SHA384);
+#endif /* HAVE_NTRU */
+#ifdef HAVE_SABER
+	do_kex(KEX_SABER_LIGHTSABER_SHA384);
+	do_kex(KEX_SABER_SABER_SHA384);
+	do_kex(KEX_SABER_FIRESABER_SHA384);
+#endif /* HAVE_SABER */
+#ifdef HAVE_SIDH
+	do_kex(KEX_SIDH_p434_SHA384);
+	do_kex(KEX_SIDH_p503_SHA384);
+	do_kex(KEX_SIDH_p610_SHA384);
+	do_kex(KEX_SIDH_p751_SHA384);
+	do_kex(KEX_SIDH_P434_COMPRESSED_SHA384);
+	do_kex(KEX_SIDH_P503_COMPRESSED_SHA384);
+	do_kex(KEX_SIDH_P610_COMPRESSED_SHA384);
+	do_kex(KEX_SIDH_P751_COMPRESSED_SHA384);
+#endif /* HAVE_SIDH */
+#ifdef HAVE_SIKE
+	do_kex(KEX_SIKE_P434_SHA384);
+	do_kex(KEX_SIKE_P503_SHA384);
+	do_kex(KEX_SIKE_P610_SHA384);
+	do_kex(KEX_SIKE_P751_SHA384);
+	do_kex(KEX__SHA384);
+	do_kex(KEX_SIKE_P503_COMPRESSED_SHA384);
+	do_kex(KEX_SIKE_P610_COMPRESSED_SHA384);
+	do_kex(KEX_SIKE_P751_COMPRESSED_SHA384);
+#endif /* HAVE_SIKE */
+#ifdef HAVE_THREEBEARS
+	do_kex(KEX_BABYBEAR_SHA384);
+	do_kex(KEX_BABYBEAR_EPHEM_SHA384);
+	do_kex(KEX_MAMABEAR_SHA384);
+	do_kex(KEX_MAMABEAR_EPHEM_SHA384);
+	do_kex(KEX_PAPABEAR_SHA384);
+	do_kex(KEX_PAPABEAR_EPHEM_SHA384);
+#endif /* HAVE_THREEBEARS */
+#ifdef HAVE_HQC
+	do_kex(KEX_HQC_128_1_CCA2_SHA384);
+	do_kex(KEX_HQC_192_1_CCA2_SHA384);
+	do_kex(KEX_HQC_192_2_CCA2_SHA384);
+	do_kex(KEX_HQC_256_1_CCA2_SHA384);
+	do_kex(KEX_HQC_256_2_CCA2_SHA384);
+	do_kex(KEX_HQC_256_3_CCA2_SHA384);
+#endif /* HAVE_HQC */
+///// OQS_TEMPLATE_FRAGMENT_DO_PQ_KEXS_END
+#endif /* defined(WITH_OQS) && defined(WITH_PQ_KEX) */
 }
--- a/servconf.c
+++ b/servconf.c
@@ -282,6 +282,88 @@
 		servconf_add_hostkey("[default]", 0, options,
 		    _PATH_HOST_XMSS_KEY_FILE);
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+///// OQS_TEMPLATE_FRAGMENT_ADD_PQ_HOSTKEYS_START
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_OQSDEFAULT_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_DILITHIUM_2_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_FALCON_512_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_MQDSS_31_48_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_PICNIC_L1FS_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_PICNIC3_L1_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_QTESLA_P_I_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_RAINBOW_IA_CLASSIC_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_RAINBOW_IIIC_CLASSIC_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_RAINBOW_VC_CLASSIC_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_SPHINCS_SHA256_128F_ROBUST_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE);
+///// OQS_TEMPLATE_FRAGMENT_ADD_PQ_HOSTKEYS_END
+#endif /* WITH_PQ_AUTH */
+#ifdef WITH_HYBRID_AUTH
+///// OQS_TEMPLATE_FRAGMENT_ADD_HYBRID_HOSTKEYS_START
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_RSA3072_OQSDEFAULT_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_P256_OQSDEFAULT_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_RSA3072_DILITHIUM_2_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_P256_DILITHIUM_2_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_RSA3072_FALCON_512_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_P256_FALCON_512_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_RSA3072_MQDSS_31_48_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_P256_MQDSS_31_48_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_RSA3072_PICNIC_L1FS_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_P256_PICNIC_L1FS_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_RSA3072_PICNIC3_L1_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_P256_PICNIC3_L1_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_RSA3072_QTESLA_P_I_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_P256_QTESLA_P_I_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_RSA3072_RAINBOW_IA_CLASSIC_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_P256_RAINBOW_IA_CLASSIC_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_P384_RAINBOW_IIIC_CLASSIC_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_P521_RAINBOW_VC_CLASSIC_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_RSA3072_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_P256_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_RSA3072_SPHINCS_SHA256_128F_ROBUST_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_P256_SPHINCS_SHA256_128F_ROBUST_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_RSA3072_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE);
+		servconf_add_hostkey("[default]", 0, options,
+		    _PATH_HOST_P256_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE);
+///// OQS_TEMPLATE_FRAGMENT_ADD_HYBRID_HOSTKEYS_END
+#endif /* WITH_HYBRID_AUTH */
 	}
 	/* No certificates by default */
 	if (options->num_ports == 0)
--- a/ssh-add.c
+++ b/ssh-add.c
@@ -79,6 +79,51 @@
 #endif /* WITH_OPENSSL */
 	_PATH_SSH_CLIENT_ID_ED25519,
 	_PATH_SSH_CLIENT_ID_XMSS,
+#ifdef WITH_PQ_AUTH
+///// OQS_TEMPLATE_FRAGMENT_LIST_PQ_ID_PATHS_START
+	_PATH_SSH_CLIENT_ID_OQSDEFAULT,
+	_PATH_SSH_CLIENT_ID_DILITHIUM_2,
+	_PATH_SSH_CLIENT_ID_FALCON_512,
+	_PATH_SSH_CLIENT_ID_MQDSS_31_48,
+	_PATH_SSH_CLIENT_ID_PICNIC_L1FS,
+	_PATH_SSH_CLIENT_ID_PICNIC3_L1,
+	_PATH_SSH_CLIENT_ID_QTESLA_P_I,
+	_PATH_SSH_CLIENT_ID_RAINBOW_IA_CLASSIC,
+	_PATH_SSH_CLIENT_ID_RAINBOW_IIIC_CLASSIC,
+	_PATH_SSH_CLIENT_ID_RAINBOW_VC_CLASSIC,
+	_PATH_SSH_CLIENT_ID_SPHINCS_HARAKA_128F_ROBUST,
+	_PATH_SSH_CLIENT_ID_SPHINCS_SHA256_128F_ROBUST,
+	_PATH_SSH_CLIENT_ID_SPHINCS_SHAKE256_128F_ROBUST,
+///// OQS_TEMPLATE_FRAGMENT_LIST_PQ_ID_PATHS_END
+#endif /* WITH_PQ_AUTH */
+#ifdef WITH_HYBRID_AUTH
+///// OQS_TEMPLATE_FRAGMENT_LIST_HYBRID_ID_PATHS_START
+	_PATH_SSH_CLIENT_ID_RSA3072_OQSDEFAULT,
+	_PATH_SSH_CLIENT_ID_P256_OQSDEFAULT,
+	_PATH_SSH_CLIENT_ID_RSA3072_DILITHIUM_2,
+	_PATH_SSH_CLIENT_ID_P256_DILITHIUM_2,
+	_PATH_SSH_CLIENT_ID_RSA3072_FALCON_512,
+	_PATH_SSH_CLIENT_ID_P256_FALCON_512,
+	_PATH_SSH_CLIENT_ID_RSA3072_MQDSS_31_48,
+	_PATH_SSH_CLIENT_ID_P256_MQDSS_31_48,
+	_PATH_SSH_CLIENT_ID_RSA3072_PICNIC_L1FS,
+	_PATH_SSH_CLIENT_ID_P256_PICNIC_L1FS,
+	_PATH_SSH_CLIENT_ID_RSA3072_PICNIC3_L1,
+	_PATH_SSH_CLIENT_ID_P256_PICNIC3_L1,
+	_PATH_SSH_CLIENT_ID_RSA3072_QTESLA_P_I,
+	_PATH_SSH_CLIENT_ID_P256_QTESLA_P_I,
+	_PATH_SSH_CLIENT_ID_RSA3072_RAINBOW_IA_CLASSIC,
+	_PATH_SSH_CLIENT_ID_P256_RAINBOW_IA_CLASSIC,
+	_PATH_SSH_CLIENT_ID_P384_RAINBOW_IIIC_CLASSIC,
+	_PATH_SSH_CLIENT_ID_P521_RAINBOW_VC_CLASSIC,
+	_PATH_SSH_CLIENT_ID_RSA3072_SPHINCS_HARAKA_128F_ROBUST,
+	_PATH_SSH_CLIENT_ID_P256_SPHINCS_HARAKA_128F_ROBUST,
+	_PATH_SSH_CLIENT_ID_RSA3072_SPHINCS_SHA256_128F_ROBUST,
+	_PATH_SSH_CLIENT_ID_P256_SPHINCS_SHA256_128F_ROBUST,
+	_PATH_SSH_CLIENT_ID_RSA3072_SPHINCS_SHAKE256_128F_ROBUST,
+	_PATH_SSH_CLIENT_ID_P256_SPHINCS_SHAKE256_128F_ROBUST,
+///// OQS_TEMPLATE_FRAGMENT_LIST_HYBRID_ID_PATHS_END
+#endif /* WITH_HYBRID_AUTH */
 	NULL
 };
 
--- a/ssh-ecdsa.c
+++ b/ssh-ecdsa.c
@@ -42,6 +42,7 @@
 #include "digest.h"
 #define SSHKEY_INTERNAL
 #include "sshkey.h"
+#include "oqs-utils.h"
 
 #include "openbsd-compat/openssl-compat.h"
 
@@ -64,7 +65,8 @@
 		*sigp = NULL;
 
 	if (key == NULL || key->ecdsa == NULL ||
-	    sshkey_type_plain(key->type) != KEY_ECDSA)
+	    (sshkey_type_plain(key->type) != KEY_ECDSA &&
+	     !IS_ECDSA_HYBRID(sshkey_type_plain(key->type))))
 		return SSH_ERR_INVALID_ARGUMENT;
 
 	if ((hash_alg = sshkey_ec_nid_to_hash_alg(key->ecdsa_nid)) == -1 ||
@@ -125,7 +127,8 @@
 	char *ktype = NULL;
 
 	if (key == NULL || key->ecdsa == NULL ||
-	    sshkey_type_plain(key->type) != KEY_ECDSA ||
+	    (sshkey_type_plain(key->type) != KEY_ECDSA &&
+	     !IS_ECDSA_HYBRID(sshkey_type_plain(key->type))) ||
 	    signature == NULL || signaturelen == 0)
 		return SSH_ERR_INVALID_ARGUMENT;
 
--- a/ssh-keygen.c
+++ b/ssh-keygen.c
@@ -24,6 +24,11 @@
 #include "openbsd-compat/openssl-compat.h"
 #endif
 
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+#include <oqs/oqs.h>
+#endif
+#include "oqs-utils.h"
+
 #include <errno.h>
 #include <fcntl.h>
 #include <netdb.h>
@@ -215,7 +220,7 @@
 #ifdef WITH_OPENSSL
 		if (type == KEY_DSA)
 			*bitsp = DEFAULT_BITS_DSA;
-		else if (type == KEY_ECDSA) {
+		else if (type == KEY_ECDSA || IS_ECDSA_HYBRID(type)) {
 			if (name != NULL &&
 			    (nid = sshkey_ecdsa_nid_from_name(name)) > 0)
 				*bitsp = sshkey_curve_nid_to_bits(nid);
@@ -225,9 +230,27 @@
 #endif
 			*bitsp = DEFAULT_BITS;
 	}
+	  /* OQS note: different parameter sets for one PQ scheme are identified
+	   * by different types (unlike ECDSA which uses one key type and a 2nd
+	   * 'nid' value to identify the curve. We need this special processing
+	   * for ECDSA hybrid of levels 3+ to avoid defaulting to P256 when
+	   * name is NULL (like when called from do_gen_all_hostkeys).
+	   */
+	if (name == NULL && IS_ECDSA_HYBRID(type)) {
+		switch (type) {
+///// OQS_TEMPLATE_FRAGMENT_SET_BITS_START
+		case KEY_P384_RAINBOW_IIIC_CLASSIC:
+			*bitsp = 384;
+			break;
+		case KEY_P521_RAINBOW_VC_CLASSIC:
+			*bitsp = 521;
+///// OQS_TEMPLATE_FRAGMENT_SET_BITS_END
+		}
+	}
 #ifdef WITH_OPENSSL
 	maxbits = (type == KEY_DSA) ?
 	    OPENSSL_DSA_MAX_MODULUS_BITS : OPENSSL_RSA_MAX_MODULUS_BITS;
+	/* FIXMEOQS: do some PQ algs increase the maxbit value? */
 	if (*bitsp > maxbits)
 		fatal("key bits exceeds maximum %d", maxbits);
 	switch (type) {
@@ -241,6 +264,9 @@
 			    SSH_RSA_MINIMUM_MODULUS_SIZE);
 		break;
 	case KEY_ECDSA:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_ECDSA_HYBRID:
+#endif
 		if (sshkey_ecdsa_bits_to_nid(*bitsp) == -1)
 			fatal("Invalid ECDSA key length: valid lengths are "
 			    "256, 384 or 521 bits");
@@ -280,6 +306,47 @@
 		case KEY_XMSS_CERT:
 			name = _PATH_SSH_CLIENT_ID_XMSS;
 			break;
+///// OQS_TEMPLATE_FRAGMENT_ASSIGN_PQ_ID_PATHS_START
+		case KEY_OQSDEFAULT:
+			name = _PATH_SSH_CLIENT_ID_OQSDEFAULT;
+			break;
+		case KEY_DILITHIUM_2:
+			name = _PATH_SSH_CLIENT_ID_DILITHIUM_2;
+			break;
+		case KEY_FALCON_512:
+			name = _PATH_SSH_CLIENT_ID_FALCON_512;
+			break;
+		case KEY_MQDSS_31_48:
+			name = _PATH_SSH_CLIENT_ID_MQDSS_31_48;
+			break;
+		case KEY_PICNIC_L1FS:
+			name = _PATH_SSH_CLIENT_ID_PICNIC_L1FS;
+			break;
+		case KEY_PICNIC3_L1:
+			name = _PATH_SSH_CLIENT_ID_PICNIC3_L1;
+			break;
+		case KEY_QTESLA_P_I:
+			name = _PATH_SSH_CLIENT_ID_QTESLA_P_I;
+			break;
+		case KEY_RAINBOW_IA_CLASSIC:
+			name = _PATH_SSH_CLIENT_ID_RAINBOW_IA_CLASSIC;
+			break;
+		case KEY_RAINBOW_IIIC_CLASSIC:
+			name = _PATH_SSH_CLIENT_ID_RAINBOW_IIIC_CLASSIC;
+			break;
+		case KEY_RAINBOW_VC_CLASSIC:
+			name = _PATH_SSH_CLIENT_ID_RAINBOW_VC_CLASSIC;
+			break;
+		case KEY_SPHINCS_HARAKA_128F_ROBUST:
+			name = _PATH_SSH_CLIENT_ID_SPHINCS_HARAKA_128F_ROBUST;
+			break;
+		case KEY_SPHINCS_SHA256_128F_ROBUST:
+			name = _PATH_SSH_CLIENT_ID_SPHINCS_SHA256_128F_ROBUST;
+			break;
+		case KEY_SPHINCS_SHAKE256_128F_ROBUST:
+			name = _PATH_SSH_CLIENT_ID_SPHINCS_SHAKE256_128F_ROBUST;
+			break;
+///// OQS_TEMPLATE_FRAGMENT_ASSIGN_PQ_ID_PATHS_END
 		default:
 			fatal("bad key type");
 		}
@@ -1012,6 +1079,55 @@
 #ifdef WITH_XMSS
 		{ "xmss", "XMSS",_PATH_HOST_XMSS_KEY_FILE },
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+///// OQS_TEMPLATE_FRAGMENT_ADD_PQ_KT_START
+		{ "oqsdefault", "OQSDEFAULT", _PATH_HOST_OQSDEFAULT_KEY_FILE },
+		{ "dilithium2", "DILITHIUM_2", _PATH_HOST_DILITHIUM_2_KEY_FILE },
+		{ "falcon512", "FALCON_512", _PATH_HOST_FALCON_512_KEY_FILE },
+		{ "mqdss3148", "MQDSS_31_48", _PATH_HOST_MQDSS_31_48_KEY_FILE },
+		{ "picnicl1fs", "PICNIC_L1FS", _PATH_HOST_PICNIC_L1FS_KEY_FILE },
+		{ "picnic3l1", "PICNIC3_L1", _PATH_HOST_PICNIC3_L1_KEY_FILE },
+		{ "qteslapi", "QTESLA_P_I", _PATH_HOST_QTESLA_P_I_KEY_FILE },
+		{ "rainbowiaclassic", "RAINBOW_IA_CLASSIC", _PATH_HOST_RAINBOW_IA_CLASSIC_KEY_FILE },
+		{ "rainbowiiicclassic", "RAINBOW_IIIC_CLASSIC", _PATH_HOST_RAINBOW_IIIC_CLASSIC_KEY_FILE },
+		{ "rainbowvcclassic", "RAINBOW_VC_CLASSIC", _PATH_HOST_RAINBOW_VC_CLASSIC_KEY_FILE },
+		{ "sphincsharaka128frobust", "SPHINCS_HARAKA_128F_ROBUST", _PATH_HOST_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE },
+		{ "sphincssha256128frobust", "SPHINCS_SHA256_128F_ROBUST", _PATH_HOST_SPHINCS_SHA256_128F_ROBUST_KEY_FILE },
+		{ "sphincsshake256128frobust", "SPHINCS_SHAKE256_128F_ROBUST", _PATH_HOST_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE },
+///// OQS_TEMPLATE_FRAGMENT_ADD_PQ_KT_END
+#endif /* WITH_PQ_AUTH */
+#ifdef WITH_HYBRID_AUTH
+///// OQS_TEMPLATE_FRAGMENT_ADD_HYBRID_KT_START
+#ifdef WITH_OPENSSL
+		{ "rsa3072_oqsdefault", "RSA3072_OQSDEFAULT", _PATH_HOST_RSA3072_OQSDEFAULT_KEY_FILE },
+		{ "rsa3072_dilithium2", "RSA3072_DILITHIUM_2", _PATH_HOST_RSA3072_DILITHIUM_2_KEY_FILE },
+		{ "rsa3072_falcon512", "RSA3072_FALCON_512", _PATH_HOST_RSA3072_FALCON_512_KEY_FILE },
+		{ "rsa3072_mqdss3148", "RSA3072_MQDSS_31_48", _PATH_HOST_RSA3072_MQDSS_31_48_KEY_FILE },
+		{ "rsa3072_picnicl1fs", "RSA3072_PICNIC_L1FS", _PATH_HOST_RSA3072_PICNIC_L1FS_KEY_FILE },
+		{ "rsa3072_picnic3l1", "RSA3072_PICNIC3_L1", _PATH_HOST_RSA3072_PICNIC3_L1_KEY_FILE },
+		{ "rsa3072_qteslapi", "RSA3072_QTESLA_P_I", _PATH_HOST_RSA3072_QTESLA_P_I_KEY_FILE },
+		{ "rsa3072_rainbowiaclassic", "RSA3072_RAINBOW_IA_CLASSIC", _PATH_HOST_RSA3072_RAINBOW_IA_CLASSIC_KEY_FILE },
+		{ "rsa3072_sphincsharaka128frobust", "RSA3072_SPHINCS_HARAKA_128F_ROBUST", _PATH_HOST_RSA3072_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE },
+		{ "rsa3072_sphincssha256128frobust", "RSA3072_SPHINCS_SHA256_128F_ROBUST", _PATH_HOST_RSA3072_SPHINCS_SHA256_128F_ROBUST_KEY_FILE },
+		{ "rsa3072_sphincsshake256128frobust", "RSA3072_SPHINCS_SHAKE256_128F_ROBUST", _PATH_HOST_RSA3072_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE },
+#ifdef OPENSSL_HAS_ECC
+		{ "p256_oqsdefault", "P256_OQSDEFAULT", _PATH_HOST_P256_OQSDEFAULT_KEY_FILE },
+		{ "p256_dilithium2", "P256_DILITHIUM_2", _PATH_HOST_P256_DILITHIUM_2_KEY_FILE },
+		{ "p256_falcon512", "P256_FALCON_512", _PATH_HOST_P256_FALCON_512_KEY_FILE },
+		{ "p256_mqdss3148", "P256_MQDSS_31_48", _PATH_HOST_P256_MQDSS_31_48_KEY_FILE },
+		{ "p256_picnicl1fs", "P256_PICNIC_L1FS", _PATH_HOST_P256_PICNIC_L1FS_KEY_FILE },
+		{ "p256_picnic3l1", "P256_PICNIC3_L1", _PATH_HOST_P256_PICNIC3_L1_KEY_FILE },
+		{ "p256_qteslapi", "P256_QTESLA_P_I", _PATH_HOST_P256_QTESLA_P_I_KEY_FILE },
+		{ "p256_rainbowiaclassic", "P256_RAINBOW_IA_CLASSIC", _PATH_HOST_P256_RAINBOW_IA_CLASSIC_KEY_FILE },
+		{ "p384_rainbowiiicclassic", "P384_RAINBOW_IIIC_CLASSIC", _PATH_HOST_P384_RAINBOW_IIIC_CLASSIC_KEY_FILE },
+		{ "p521_rainbowvcclassic", "P521_RAINBOW_VC_CLASSIC", _PATH_HOST_P521_RAINBOW_VC_CLASSIC_KEY_FILE },
+		{ "p256_sphincsharaka128frobust", "P256_SPHINCS_HARAKA_128F_ROBUST", _PATH_HOST_P256_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE },
+		{ "p256_sphincssha256128frobust", "P256_SPHINCS_SHA256_128F_ROBUST", _PATH_HOST_P256_SPHINCS_SHA256_128F_ROBUST_KEY_FILE },
+		{ "p256_sphincsshake256128frobust", "P256_SPHINCS_SHAKE256_128F_ROBUST", _PATH_HOST_P256_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE },
+#endif /* OPENSSL_HAS_ECC */
+#endif /* WITH_OPENSSL */
+///// OQS_TEMPLATE_FRAGMENT_ADD_HYBRID_KT_END
+#endif /* WITH_HYBRID_AUTH */
 		{ NULL, NULL, NULL }
 	};
 
@@ -1497,6 +1613,7 @@
 		}
 	}
 
+	// FIXMEOQS: should we add the OQS key types here?
 	if (private->type != KEY_ED25519 && private->type != KEY_XMSS &&
 	    !use_new_format) {
 		error("Comments are only supported for keys stored in "
@@ -2387,7 +2504,17 @@
 usage(void)
 {
 	fprintf(stderr,
-	    "usage: ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa]\n"
+	    "usage: ssh-keygen [-q] [-b bits] [-t dsa | ecdsa | ed25519 | rsa"
+#ifdef WITH_PQ_AUTH
+	    " |\n"
+	    "                   oqsdefault | picnicL1FS | qteslaI | qteslaIIIsize | qteslaIIIspeed"
+#endif
+#ifdef WITH_HYBRID_AUTH
+	    " |\n"
+	    "                   rsa3072_oqsdefault | p256_oqsdefault | rsa3072_picnicL1FS | p256_picnicL1FS |\n"
+	    "                   rsa3072_qteslaI | p256_qteslaI | p384_qteslaIIIsize | p384_qteslaIIIspeed"
+#endif
+	    "                  ]\n"
 	    "                  [-N new_passphrase] [-C comment] [-f output_keyfile]\n"
 	    "       ssh-keygen -p [-P old_passphrase] [-N new_passphrase] [-f keyfile]\n"
 	    "       ssh-keygen -i [-m key_format] [-f input_keyfile]\n"
@@ -2749,7 +2876,6 @@
 				fatal("%s: %s", identity_file, strerror(errno));
 			exit(0);
 		} else {
-
 			n += do_print_resource_record(pw,
 			    _PATH_HOST_RSA_KEY_FILE, rr_hostname);
 			n += do_print_resource_record(pw,
@@ -2760,6 +2886,35 @@
 			    _PATH_HOST_ED25519_KEY_FILE, rr_hostname);
 			n += do_print_resource_record(pw,
 			    _PATH_HOST_XMSS_KEY_FILE, rr_hostname);
+///// OQS_TEMPLATE_FRAGMENT_PRINT_PQ_RR_START
+			n += do_print_resource_record(pw,
+                 _PATH_HOST_OQSDEFAULT_KEY_FILE, rr_hostname);
+			n += do_print_resource_record(pw,
+                 _PATH_HOST_DILITHIUM_2_KEY_FILE, rr_hostname);
+			n += do_print_resource_record(pw,
+                 _PATH_HOST_FALCON_512_KEY_FILE, rr_hostname);
+			n += do_print_resource_record(pw,
+                 _PATH_HOST_MQDSS_31_48_KEY_FILE, rr_hostname);
+			n += do_print_resource_record(pw,
+                 _PATH_HOST_PICNIC_L1FS_KEY_FILE, rr_hostname);
+			n += do_print_resource_record(pw,
+                 _PATH_HOST_PICNIC3_L1_KEY_FILE, rr_hostname);
+			n += do_print_resource_record(pw,
+                 _PATH_HOST_QTESLA_P_I_KEY_FILE, rr_hostname);
+			n += do_print_resource_record(pw,
+                 _PATH_HOST_RAINBOW_IA_CLASSIC_KEY_FILE, rr_hostname);
+			n += do_print_resource_record(pw,
+                 _PATH_HOST_RAINBOW_IIIC_CLASSIC_KEY_FILE, rr_hostname);
+			n += do_print_resource_record(pw,
+                 _PATH_HOST_RAINBOW_VC_CLASSIC_KEY_FILE, rr_hostname);
+			n += do_print_resource_record(pw,
+                 _PATH_HOST_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE, rr_hostname);
+			n += do_print_resource_record(pw,
+                 _PATH_HOST_SPHINCS_SHA256_128F_ROBUST_KEY_FILE, rr_hostname);
+			n += do_print_resource_record(pw,
+                 _PATH_HOST_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE, rr_hostname);
+///// OQS_TEMPLATE_FRAGMENT_PRINT_PQ_RR_END
+
 			if (n == 0)
 				fatal("no keys found.");
 			exit(0);
--- a/ssh-keyscan.c
+++ b/ssh-keyscan.c
@@ -8,7 +8,7 @@
  */
 
 #include "includes.h"
- 
+
 #include <sys/types.h>
 #include "openbsd-compat/sys-queue.h"
 #include <sys/resource.h>
@@ -54,17 +54,95 @@
 
 int ssh_port = SSH_DEFAULT_PORT;
 
-#define KT_DSA		(1)
-#define KT_RSA		(1<<1)
-#define KT_ECDSA	(1<<2)
-#define KT_ED25519	(1<<3)
-#define KT_XMSS		(1<<4)
-
-#define KT_MIN		KT_DSA
-#define KT_MAX		KT_XMSS
+#define KT_DSA			(1)
+#define KT_RSA			(1<<1)
+#define KT_ECDSA		(1<<2)
+#define KT_ED25519		(1<<3)
+#define KT_XMSS			(1<<4)
+///// OQS_TEMPLATE_FRAGMENT_ASSIGN_KT_MARKERS_START
+#define KT_OQSDEFAULT ((uint64_t)1<<5)
+#define KT_DILITHIUM_2 ((uint64_t)1<<6)
+#define KT_FALCON_512 ((uint64_t)1<<7)
+#define KT_MQDSS_31_48 ((uint64_t)1<<8)
+#define KT_PICNIC_L1FS ((uint64_t)1<<9)
+#define KT_PICNIC3_L1 ((uint64_t)1<<10)
+#define KT_QTESLA_P_I ((uint64_t)1<<11)
+#define KT_RAINBOW_IA_CLASSIC ((uint64_t)1<<12)
+#define KT_RAINBOW_IIIC_CLASSIC ((uint64_t)1<<13)
+#define KT_RAINBOW_VC_CLASSIC ((uint64_t)1<<14)
+#define KT_SPHINCS_HARAKA_128F_ROBUST ((uint64_t)1<<15)
+#define KT_SPHINCS_SHA256_128F_ROBUST ((uint64_t)1<<16)
+#define KT_SPHINCS_SHAKE256_128F_ROBUST ((uint64_t)1<<17)
+#define KT_RSA3072_OQSDEFAULT ((uint64_t)1<<18)
+#define KT_P256_OQSDEFAULT ((uint64_t)1<<19)
+#define KT_RSA3072_DILITHIUM_2 ((uint64_t)1<<20)
+#define KT_P256_DILITHIUM_2 ((uint64_t)1<<21)
+#define KT_RSA3072_FALCON_512 ((uint64_t)1<<22)
+#define KT_P256_FALCON_512 ((uint64_t)1<<23)
+#define KT_RSA3072_MQDSS_31_48 ((uint64_t)1<<24)
+#define KT_P256_MQDSS_31_48 ((uint64_t)1<<25)
+#define KT_RSA3072_PICNIC_L1FS ((uint64_t)1<<26)
+#define KT_P256_PICNIC_L1FS ((uint64_t)1<<27)
+#define KT_RSA3072_PICNIC3_L1 ((uint64_t)1<<28)
+#define KT_P256_PICNIC3_L1 ((uint64_t)1<<29)
+#define KT_RSA3072_QTESLA_P_I ((uint64_t)1<<30)
+#define KT_P256_QTESLA_P_I ((uint64_t)1<<31)
+#define KT_RSA3072_RAINBOW_IA_CLASSIC ((uint64_t)1<<32)
+#define KT_P256_RAINBOW_IA_CLASSIC ((uint64_t)1<<33)
+#define KT_P384_RAINBOW_IIIC_CLASSIC ((uint64_t)1<<34)
+#define KT_P521_RAINBOW_VC_CLASSIC ((uint64_t)1<<35)
+#define KT_RSA3072_SPHINCS_HARAKA_128F_ROBUST ((uint64_t)1<<36)
+#define KT_P256_SPHINCS_HARAKA_128F_ROBUST ((uint64_t)1<<37)
+#define KT_RSA3072_SPHINCS_SHA256_128F_ROBUST ((uint64_t)1<<38)
+#define KT_P256_SPHINCS_SHA256_128F_ROBUST ((uint64_t)1<<39)
+#define KT_RSA3072_SPHINCS_SHAKE256_128F_ROBUST ((uint64_t)1<<40)
+#define KT_P256_SPHINCS_SHAKE256_128F_ROBUST ((uint64_t)1<<41)
+
+#define KT_MIN KT_DSA
+#define KT_MAX KT_P256_SPHINCS_SHAKE256_128F_ROBUST
+///// OQS_TEMPLATE_FRAGMENT_ASSIGN_KT_MARKERS_END
 
 int get_cert = 0;
-int get_keytypes = KT_RSA|KT_ECDSA|KT_ED25519;
+uint64_t get_keytypes = KT_RSA|KT_ECDSA|KT_ED25519| \
+///// OQS_TEMPLATE_FRAGMENT_GET_KT_START
+                   KT_OQSDEFAULT| \
+                   KT_DILITHIUM_2| \
+                   KT_FALCON_512| \
+                   KT_MQDSS_31_48| \
+                   KT_PICNIC_L1FS| \
+                   KT_PICNIC3_L1| \
+                   KT_QTESLA_P_I| \
+                   KT_RAINBOW_IA_CLASSIC| \
+                   KT_RAINBOW_IIIC_CLASSIC| \
+                   KT_RAINBOW_VC_CLASSIC| \
+                   KT_SPHINCS_HARAKA_128F_ROBUST| \
+                   KT_SPHINCS_SHA256_128F_ROBUST| \
+                   KT_SPHINCS_SHAKE256_128F_ROBUST| \
+                   KT_RSA3072_OQSDEFAULT| \
+                   KT_P256_OQSDEFAULT| \
+                   KT_RSA3072_DILITHIUM_2| \
+                   KT_P256_DILITHIUM_2| \
+                   KT_RSA3072_FALCON_512| \
+                   KT_P256_FALCON_512| \
+                   KT_RSA3072_MQDSS_31_48| \
+                   KT_P256_MQDSS_31_48| \
+                   KT_RSA3072_PICNIC_L1FS| \
+                   KT_P256_PICNIC_L1FS| \
+                   KT_RSA3072_PICNIC3_L1| \
+                   KT_P256_PICNIC3_L1| \
+                   KT_RSA3072_QTESLA_P_I| \
+                   KT_P256_QTESLA_P_I| \
+                   KT_RSA3072_RAINBOW_IA_CLASSIC| \
+                   KT_P256_RAINBOW_IA_CLASSIC| \
+                   KT_P384_RAINBOW_IIIC_CLASSIC| \
+                   KT_P521_RAINBOW_VC_CLASSIC| \
+                   KT_RSA3072_SPHINCS_HARAKA_128F_ROBUST| \
+                   KT_P256_SPHINCS_HARAKA_128F_ROBUST| \
+                   KT_RSA3072_SPHINCS_SHA256_128F_ROBUST| \
+                   KT_P256_SPHINCS_SHA256_128F_ROBUST| \
+                   KT_RSA3072_SPHINCS_SHAKE256_128F_ROBUST| \
+                   KT_P256_SPHINCS_SHAKE256_128F_ROBUST;
+///// OQS_TEMPLATE_FRAGMENT_GET_KT_END
 
 int hash_hosts = 0;		/* Hash hostname on output */
 
@@ -271,8 +349,10 @@
 	c->c_ssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;
 # ifdef OPENSSL_HAS_ECC
 	c->c_ssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_client;
+	c->c_ssh->kex->kex[KEX_HY_ECDH_OQS] = get_hybrid_ecdh_oqs_client_cb();
 # endif
 #endif
+	c->c_ssh->kex->kex[KEX_PQ_OQS] = get_pq_oqs_client_cb();
 	c->c_ssh->kex->kex[KEX_C25519_SHA256] = kexc25519_client;
 	ssh_set_verify_host_key_callback(c->c_ssh, key_print_wrapper);
 	/*
@@ -607,7 +687,7 @@
 do_host(char *host)
 {
 	char *name = strnnsep(&host, " \t\n");
-	int j;
+	uint64_t j;
 
 	if (name == NULL)
 		return;
@@ -726,6 +806,119 @@
 				case KEY_XMSS:
 					get_keytypes |= KT_XMSS;
 					break;
+///// OQS_TEMPLATE_FRAGMENT_SWITCH_KT_START
+				case KEY_OQSDEFAULT:
+					get_keytypes |= KT_OQSDEFAULT;
+					break;
+				case KEY_DILITHIUM_2:
+					get_keytypes |= KT_DILITHIUM_2;
+					break;
+				case KEY_FALCON_512:
+					get_keytypes |= KT_FALCON_512;
+					break;
+				case KEY_MQDSS_31_48:
+					get_keytypes |= KT_MQDSS_31_48;
+					break;
+				case KEY_PICNIC_L1FS:
+					get_keytypes |= KT_PICNIC_L1FS;
+					break;
+				case KEY_PICNIC3_L1:
+					get_keytypes |= KT_PICNIC3_L1;
+					break;
+				case KEY_QTESLA_P_I:
+					get_keytypes |= KT_QTESLA_P_I;
+					break;
+				case KEY_RAINBOW_IA_CLASSIC:
+					get_keytypes |= KT_RAINBOW_IA_CLASSIC;
+					break;
+				case KEY_RAINBOW_IIIC_CLASSIC:
+					get_keytypes |= KT_RAINBOW_IIIC_CLASSIC;
+					break;
+				case KEY_RAINBOW_VC_CLASSIC:
+					get_keytypes |= KT_RAINBOW_VC_CLASSIC;
+					break;
+				case KEY_SPHINCS_HARAKA_128F_ROBUST:
+					get_keytypes |= KT_SPHINCS_HARAKA_128F_ROBUST;
+					break;
+				case KEY_SPHINCS_SHA256_128F_ROBUST:
+					get_keytypes |= KT_SPHINCS_SHA256_128F_ROBUST;
+					break;
+				case KEY_SPHINCS_SHAKE256_128F_ROBUST:
+					get_keytypes |= KT_SPHINCS_SHAKE256_128F_ROBUST;
+					break;
+				case KEY_RSA3072_OQSDEFAULT:
+					get_keytypes |= KT_RSA3072_OQSDEFAULT;
+					break;
+				case KEY_P256_OQSDEFAULT:
+					get_keytypes |= KT_P256_OQSDEFAULT;
+					break;
+				case KEY_RSA3072_DILITHIUM_2:
+					get_keytypes |= KT_RSA3072_DILITHIUM_2;
+					break;
+				case KEY_P256_DILITHIUM_2:
+					get_keytypes |= KT_P256_DILITHIUM_2;
+					break;
+				case KEY_RSA3072_FALCON_512:
+					get_keytypes |= KT_RSA3072_FALCON_512;
+					break;
+				case KEY_P256_FALCON_512:
+					get_keytypes |= KT_P256_FALCON_512;
+					break;
+				case KEY_RSA3072_MQDSS_31_48:
+					get_keytypes |= KT_RSA3072_MQDSS_31_48;
+					break;
+				case KEY_P256_MQDSS_31_48:
+					get_keytypes |= KT_P256_MQDSS_31_48;
+					break;
+				case KEY_RSA3072_PICNIC_L1FS:
+					get_keytypes |= KT_RSA3072_PICNIC_L1FS;
+					break;
+				case KEY_P256_PICNIC_L1FS:
+					get_keytypes |= KT_P256_PICNIC_L1FS;
+					break;
+				case KEY_RSA3072_PICNIC3_L1:
+					get_keytypes |= KT_RSA3072_PICNIC3_L1;
+					break;
+				case KEY_P256_PICNIC3_L1:
+					get_keytypes |= KT_P256_PICNIC3_L1;
+					break;
+				case KEY_RSA3072_QTESLA_P_I:
+					get_keytypes |= KT_RSA3072_QTESLA_P_I;
+					break;
+				case KEY_P256_QTESLA_P_I:
+					get_keytypes |= KT_P256_QTESLA_P_I;
+					break;
+				case KEY_RSA3072_RAINBOW_IA_CLASSIC:
+					get_keytypes |= KT_RSA3072_RAINBOW_IA_CLASSIC;
+					break;
+				case KEY_P256_RAINBOW_IA_CLASSIC:
+					get_keytypes |= KT_P256_RAINBOW_IA_CLASSIC;
+					break;
+				case KEY_P384_RAINBOW_IIIC_CLASSIC:
+					get_keytypes |= KT_P384_RAINBOW_IIIC_CLASSIC;
+					break;
+				case KEY_P521_RAINBOW_VC_CLASSIC:
+					get_keytypes |= KT_P521_RAINBOW_VC_CLASSIC;
+					break;
+				case KEY_RSA3072_SPHINCS_HARAKA_128F_ROBUST:
+					get_keytypes |= KT_RSA3072_SPHINCS_HARAKA_128F_ROBUST;
+					break;
+				case KEY_P256_SPHINCS_HARAKA_128F_ROBUST:
+					get_keytypes |= KT_P256_SPHINCS_HARAKA_128F_ROBUST;
+					break;
+				case KEY_RSA3072_SPHINCS_SHA256_128F_ROBUST:
+					get_keytypes |= KT_RSA3072_SPHINCS_SHA256_128F_ROBUST;
+					break;
+				case KEY_P256_SPHINCS_SHA256_128F_ROBUST:
+					get_keytypes |= KT_P256_SPHINCS_SHA256_128F_ROBUST;
+					break;
+				case KEY_RSA3072_SPHINCS_SHAKE256_128F_ROBUST:
+					get_keytypes |= KT_RSA3072_SPHINCS_SHAKE256_128F_ROBUST;
+					break;
+				case KEY_P256_SPHINCS_SHAKE256_128F_ROBUST:
+					get_keytypes |= KT_P256_SPHINCS_SHAKE256_128F_ROBUST;
+					break;
+///// OQS_TEMPLATE_FRAGMENT_SWITCH_KT_END
 				case KEY_UNSPEC:
 				default:
 					fatal("Unknown key type \"%s\"", tname);
--- a/ssh-keysign.c
+++ b/ssh-keysign.c
@@ -166,7 +166,9 @@
 {
 	struct sshbuf *b;
 	Options options;
-#define NUM_KEYTYPES 5
+///// OQS_TEMPLATE_FRAGMENT_COUNT_KT_START
+#define NUM_KEYTYPES 42
+///// OQS_TEMPLATE_FRAGMENT_COUNT_KT_END
 	struct sshkey *keys[NUM_KEYTYPES], *key = NULL;
 	struct passwd *pw;
 	int r, key_fd[NUM_KEYTYPES], i, found, version = 2, fd;
@@ -190,11 +192,45 @@
 
 	i = 0;
 	/* XXX This really needs to read sshd_config for the paths */
-	key_fd[i++] = open(_PATH_HOST_DSA_KEY_FILE, O_RDONLY);
-	key_fd[i++] = open(_PATH_HOST_ECDSA_KEY_FILE, O_RDONLY);
-	key_fd[i++] = open(_PATH_HOST_ED25519_KEY_FILE, O_RDONLY);
-	key_fd[i++] = open(_PATH_HOST_XMSS_KEY_FILE, O_RDONLY);
-	key_fd[i++] = open(_PATH_HOST_RSA_KEY_FILE, O_RDONLY);
+///// OQS_TEMPLATE_FRAGMENT_OPEN_KEYFILES_START
+	key_fd[i++] = open(_PATH_HOST_OQSDEFAULT_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_DILITHIUM_2_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_FALCON_512_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_MQDSS_31_48_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_PICNIC_L1FS_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_PICNIC3_L1_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_QTESLA_P_I_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_RAINBOW_IA_CLASSIC_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_RAINBOW_IIIC_CLASSIC_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_RAINBOW_VC_CLASSIC_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_SPHINCS_SHA256_128F_ROBUST_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_RSA3072_OQSDEFAULT_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_P256_OQSDEFAULT_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_RSA3072_DILITHIUM_2_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_P256_DILITHIUM_2_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_RSA3072_FALCON_512_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_P256_FALCON_512_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_RSA3072_MQDSS_31_48_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_P256_MQDSS_31_48_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_RSA3072_PICNIC_L1FS_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_P256_PICNIC_L1FS_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_RSA3072_PICNIC3_L1_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_P256_PICNIC3_L1_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_RSA3072_QTESLA_P_I_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_P256_QTESLA_P_I_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_RSA3072_RAINBOW_IA_CLASSIC_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_P256_RAINBOW_IA_CLASSIC_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_P384_RAINBOW_IIIC_CLASSIC_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_P521_RAINBOW_VC_CLASSIC_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_RSA3072_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_P256_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_RSA3072_SPHINCS_SHA256_128F_ROBUST_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_P256_SPHINCS_SHA256_128F_ROBUST_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_RSA3072_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE, O_RDONLY);
+	key_fd[i++] = open(_PATH_HOST_P256_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE, O_RDONLY);
+///// OQS_TEMPLATE_FRAGMENT_OPEN_KEYFILES_END
 
 	if ((pw = getpwuid(getuid())) == NULL)
 		fatal("getpwuid failed");
--- /dev/null
+++ b/ssh-oqs.c
@@ -0,0 +1,222 @@
+/* OQS authentication methods. */
+
+#include "includes.h"
+
+#include <string.h>
+#include <oqs/oqs.h>
+
+#include "sshbuf.h"
+#include "ssherr.h"
+#include "ssh-oqs.h"
+#include "oqs-utils.h"
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+
+/*
+ * Maps OpenSSH key types to OQS IDs
+ */
+const char* get_oqs_alg_name(int openssh_type)
+{
+	switch (openssh_type)
+	{
+///// OQS_TEMPLATE_FRAGMENT_OSSH_KT_TO_OQS_METH_START
+		case KEY_OQSDEFAULT:
+		case KEY_RSA3072_OQSDEFAULT:
+		case KEY_P256_OQSDEFAULT:
+			return OQS_SIG_alg_default;
+		case KEY_DILITHIUM_2:
+		case KEY_RSA3072_DILITHIUM_2:
+		case KEY_P256_DILITHIUM_2:
+			return OQS_SIG_alg_dilithium_2;
+		case KEY_FALCON_512:
+		case KEY_RSA3072_FALCON_512:
+		case KEY_P256_FALCON_512:
+			return OQS_SIG_alg_falcon_512;
+		case KEY_MQDSS_31_48:
+		case KEY_RSA3072_MQDSS_31_48:
+		case KEY_P256_MQDSS_31_48:
+			return OQS_SIG_alg_mqdss_31_48;
+		case KEY_PICNIC_L1FS:
+		case KEY_RSA3072_PICNIC_L1FS:
+		case KEY_P256_PICNIC_L1FS:
+			return OQS_SIG_alg_picnic_L1_FS;
+		case KEY_PICNIC3_L1:
+		case KEY_RSA3072_PICNIC3_L1:
+		case KEY_P256_PICNIC3_L1:
+			return OQS_SIG_alg_picnic3_L1;
+		case KEY_QTESLA_P_I:
+		case KEY_RSA3072_QTESLA_P_I:
+		case KEY_P256_QTESLA_P_I:
+			return OQS_SIG_alg_qTesla_p_I;
+		case KEY_RAINBOW_IA_CLASSIC:
+		case KEY_RSA3072_RAINBOW_IA_CLASSIC:
+		case KEY_P256_RAINBOW_IA_CLASSIC:
+			return OQS_SIG_alg_rainbow_Ia_classic;
+		case KEY_RAINBOW_IIIC_CLASSIC:
+		case KEY_P384_RAINBOW_IIIC_CLASSIC:
+			return OQS_SIG_alg_rainbow_IIIc_classic;
+		case KEY_RAINBOW_VC_CLASSIC:
+		case KEY_P521_RAINBOW_VC_CLASSIC:
+			return OQS_SIG_alg_rainbow_Vc_classic;
+		case KEY_SPHINCS_HARAKA_128F_ROBUST:
+		case KEY_RSA3072_SPHINCS_HARAKA_128F_ROBUST:
+		case KEY_P256_SPHINCS_HARAKA_128F_ROBUST:
+			return OQS_SIG_alg_sphincs_haraka_128f_robust;
+		case KEY_SPHINCS_SHA256_128F_ROBUST:
+		case KEY_RSA3072_SPHINCS_SHA256_128F_ROBUST:
+		case KEY_P256_SPHINCS_SHA256_128F_ROBUST:
+			return OQS_SIG_alg_sphincs_sha256_128f_robust;
+		case KEY_SPHINCS_SHAKE256_128F_ROBUST:
+		case KEY_RSA3072_SPHINCS_SHAKE256_128F_ROBUST:
+		case KEY_P256_SPHINCS_SHAKE256_128F_ROBUST:
+			return OQS_SIG_alg_sphincs_shake256_128f_robust;
+///// OQS_TEMPLATE_FRAGMENT_OSSH_KT_TO_OQS_METH_END
+		default:
+			return NULL;
+	}
+}
+
+int
+sshkey_oqs_generate_private_key(struct sshkey *k, int type)
+{
+	int ret = SSH_ERR_INTERNAL_ERROR;
+	const char* oqs_alg_name = get_oqs_alg_name(type);
+
+	/* generate PQC key */
+	if ((k->oqs_sig = OQS_SIG_new(oqs_alg_name)) == NULL) {
+		return ret;
+	}
+	if ((k->oqs_sk = malloc(k->oqs_sig->length_secret_key)) == NULL) {
+		ret = SSH_ERR_ALLOC_FAIL;
+		goto err;
+	}
+	if ((k->oqs_pk = malloc(k->oqs_sig->length_public_key)) == NULL) {
+		ret = SSH_ERR_ALLOC_FAIL;
+		goto err;
+	}
+	if (OQS_SIG_keypair(k->oqs_sig, k->oqs_pk, k->oqs_sk) != OQS_SUCCESS) {
+		ret = SSH_ERR_INTERNAL_ERROR;
+		goto err;
+	}
+
+  return 0;
+
+err:
+	free(k->oqs_sk);
+	free(k->oqs_pk);
+	OQS_SIG_free(k->oqs_sig);
+	return ret;
+}
+
+int
+ssh_oqs_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
+    const u_char *data, size_t datalen, u_int compat)
+{
+	u_char *sig = NULL;
+	size_t siglen = 0, len;
+	int ret;
+	struct sshbuf *b = NULL;
+
+	if (lenp != NULL)
+		*lenp = 0;
+	if (sigp != NULL)
+		*sigp = NULL;
+
+	if (key == NULL ||
+	    !IS_OQS_KEY_TYPE(sshkey_type_plain(key->type)) ||
+	    key->oqs_sk == NULL)
+		return SSH_ERR_INVALID_ARGUMENT;
+	siglen = key->oqs_sig->length_signature;
+	if ((sig = malloc(siglen)) == NULL)
+		return SSH_ERR_ALLOC_FAIL;
+	if (OQS_SIG_sign(key->oqs_sig, sig, &siglen, data, datalen, key->oqs_sk) != OQS_SUCCESS) {
+		ret = SSH_ERR_LIBCRYPTO_ERROR;
+		goto out;
+	}
+	/* encode signature */
+	if ((b = sshbuf_new()) == NULL) {
+		ret = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+	/* OQS note: all the OQS algs use the same format, so we identify the signature as "ssh-oqs" */
+	if ((ret = sshbuf_put_cstring(b, "ssh-oqs")) != 0 ||
+	    (ret = sshbuf_put_string(b, sig, siglen)) != 0)
+		goto out;
+	len = sshbuf_len(b);
+	if (sigp != NULL) {
+		if ((*sigp = malloc(len)) == NULL) {
+			ret = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		memcpy(*sigp, sshbuf_ptr(b), len);
+	}
+	if (lenp != NULL)
+		*lenp = len;
+
+	/* success */
+	ret = 0;
+ out:
+	sshbuf_free(b);
+	if (sig != NULL) {
+		explicit_bzero(sig, siglen);
+		free(sig);
+	}
+
+	return ret;
+}
+
+int
+ssh_oqs_verify(const struct sshkey *key,
+    const u_char *signature, size_t signaturelen,
+    const u_char *data, size_t datalen, u_int compat)
+{
+	struct sshbuf *b = NULL;
+	char *ktype = NULL;
+	const u_char *sigblob;
+	u_char *m = NULL;
+	size_t slen;
+	unsigned long long smlen = 0;
+	int ret;
+
+	if (key == NULL ||
+	    !IS_OQS_KEY_TYPE(sshkey_type_plain(key->type)) ||
+	    key->oqs_pk == NULL ||
+	    signature == NULL || signaturelen == 0)
+		return SSH_ERR_INVALID_ARGUMENT;
+
+	if ((b = sshbuf_from(signature, signaturelen)) == NULL)
+		return SSH_ERR_ALLOC_FAIL;
+	if ((ret = sshbuf_get_cstring(b, &ktype, NULL)) != 0 ||
+	    (ret = sshbuf_get_string_direct(b, &sigblob, &slen)) != 0)
+		goto out;
+	/* OQS note: all the OQS algs use the same format, so we identify the signature as "ssh-oqs" */
+	if (strcmp("ssh-oqs", ktype) != 0) {
+		ret = SSH_ERR_KEY_TYPE_MISMATCH;
+		goto out;
+	}
+	if (sshbuf_len(b) != 0) {
+		ret = SSH_ERR_UNEXPECTED_TRAILING_DATA;
+		goto out;
+	}
+	if (slen > key->oqs_sig->length_signature) {
+		ret = SSH_ERR_INVALID_FORMAT;
+		goto out;
+	}
+	if (OQS_SIG_verify(key->oqs_sig, data, datalen, sigblob, slen, key->oqs_pk) != OQS_SUCCESS) {
+		ret = SSH_ERR_SIGNATURE_INVALID;
+		goto out;
+	}
+
+	/* success */
+	ret = 0;
+ out:
+	if (m != NULL) {
+		explicit_bzero(m, smlen);
+		free(m);
+	}
+	sshbuf_free(b);
+	free(ktype);
+	return ret;
+}
+
+
+#endif /* WITH_PQ_AUTH */
--- /dev/null
+++ b/ssh-oqs.h
@@ -0,0 +1,11 @@
+#ifndef SSH_OQS_H
+#define SSH_OQS_H
+
+#include "sshkey.h"
+
+const char* get_oqs_alg_name(int);
+int sshkey_oqs_generate_private_key(struct sshkey *, int);
+int ssh_oqs_sign(const struct sshkey *, u_char **, size_t *, const u_char *, size_t, u_int);
+int ssh_oqs_verify(const struct sshkey *, const u_char *, size_t, const u_char *, size_t, u_int);
+
+#endif /* SSH_OQS_H */
--- a/ssh-rsa.c
+++ b/ssh-rsa.c
@@ -34,6 +34,7 @@
 #include "sshkey.h"
 #include "digest.h"
 #include "log.h"
+#include "oqs-utils.h"
 
 #include "openbsd-compat/openssl-compat.h"
 
@@ -62,7 +63,9 @@
 {
 	if (strcmp(ident, "ssh-rsa") == 0)
 		return SSH_DIGEST_SHA1;
-	if (strcmp(ident, "rsa-sha2-256") == 0)
+	if (strcmp(ident, "rsa-sha2-256") == 0 ||
+	    /* OQS note: RSA is currently only used for L1 PQ hybrids, corresponding to SHA256 security level */
+	    IS_RSA_HYBRID_ALG_NAME(ident))
 		return SSH_DIGEST_SHA256;
 	if (strcmp(ident, "rsa-sha2-512") == 0)
 		return SSH_DIGEST_SHA512;
@@ -115,7 +118,8 @@
 	int r;
 
 	if (key == NULL || key->rsa == NULL ||
-	    sshkey_type_plain(key->type) != KEY_RSA)
+	    (sshkey_type_plain(key->type) != KEY_RSA &&
+	     !IS_RSA_HYBRID(sshkey_type_plain(key->type))))
 		return SSH_ERR_INVALID_ARGUMENT;
 
 	RSA_get0_key(key->rsa, NULL, NULL, &rsa_d);
@@ -181,7 +185,8 @@
 	else
 		hash_alg = rsa_hash_id_from_keyname(alg_ident);
 	if (key == NULL || key->rsa == NULL || hash_alg == -1 ||
-	    sshkey_type_plain(key->type) != KEY_RSA)
+	    (sshkey_type_plain(key->type) != KEY_RSA &&
+	     !IS_RSA_HYBRID(sshkey_type_plain(key->type))))
 		return SSH_ERR_INVALID_ARGUMENT;
 	RSA_get0_key(key->rsa, &rsa_n, NULL, NULL);
 	if (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)
@@ -254,7 +259,8 @@
 	u_char digest[SSH_DIGEST_MAX_LENGTH], *osigblob, *sigblob = NULL;
 
 	if (key == NULL || key->rsa == NULL ||
-	    sshkey_type_plain(key->type) != KEY_RSA ||
+	    (sshkey_type_plain(key->type) != KEY_RSA &&
+	     !IS_RSA_HYBRID(sshkey_type_plain(key->type))) ||
 	    sig == NULL || siglen == 0)
 		return SSH_ERR_INVALID_ARGUMENT;
 	RSA_get0_key(key->rsa, &rsa_n, NULL, NULL);
@@ -267,6 +273,7 @@
 		ret = SSH_ERR_INVALID_FORMAT;
 		goto out;
 	}
+
 	if ((hash_alg = rsa_hash_id_from_ident(sigtype)) == -1) {
 		ret = SSH_ERR_KEY_TYPE_MISMATCH;
 		goto out;
--- a/ssh.c
+++ b/ssh.c
@@ -1387,7 +1387,9 @@
 	sensitive_data.nkeys = 0;
 	sensitive_data.keys = NULL;
 	if (options.hostbased_authentication) {
-		sensitive_data.nkeys = 10;
+///// OQS_TEMPLATE_FRAGMENT_COUNT_KEYS_START
+		sensitive_data.nkeys = 47;
+///// OQS_TEMPLATE_FRAGMENT_COUNT_KEYS_END
 		sensitive_data.keys = xcalloc(sensitive_data.nkeys,
 		    sizeof(struct sshkey));
 
@@ -1415,6 +1417,45 @@
 			L_PUBKEY(_PATH_HOST_DSA_KEY_FILE, 7);
 			L_CERT(_PATH_HOST_XMSS_KEY_FILE, 8);
 			L_PUBKEY(_PATH_HOST_XMSS_KEY_FILE, 9);
+///// OQS_TEMPLATE_FRAGMENT_LOAD_PUBKEYS_START
+			L_PUBKEY(_PATH_HOST_OQSDEFAULT_KEY_FILE, 10);
+			L_PUBKEY(_PATH_HOST_DILITHIUM_2_KEY_FILE, 11);
+			L_PUBKEY(_PATH_HOST_FALCON_512_KEY_FILE, 12);
+			L_PUBKEY(_PATH_HOST_MQDSS_31_48_KEY_FILE, 13);
+			L_PUBKEY(_PATH_HOST_PICNIC_L1FS_KEY_FILE, 14);
+			L_PUBKEY(_PATH_HOST_PICNIC3_L1_KEY_FILE, 15);
+			L_PUBKEY(_PATH_HOST_QTESLA_P_I_KEY_FILE, 16);
+			L_PUBKEY(_PATH_HOST_RAINBOW_IA_CLASSIC_KEY_FILE, 17);
+			L_PUBKEY(_PATH_HOST_RAINBOW_IIIC_CLASSIC_KEY_FILE, 18);
+			L_PUBKEY(_PATH_HOST_RAINBOW_VC_CLASSIC_KEY_FILE, 19);
+			L_PUBKEY(_PATH_HOST_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE, 20);
+			L_PUBKEY(_PATH_HOST_SPHINCS_SHA256_128F_ROBUST_KEY_FILE, 21);
+			L_PUBKEY(_PATH_HOST_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE, 22);
+			L_PUBKEY(_PATH_HOST_RSA3072_OQSDEFAULT_KEY_FILE, 23);
+			L_PUBKEY(_PATH_HOST_P256_OQSDEFAULT_KEY_FILE, 24);
+			L_PUBKEY(_PATH_HOST_RSA3072_DILITHIUM_2_KEY_FILE, 25);
+			L_PUBKEY(_PATH_HOST_P256_DILITHIUM_2_KEY_FILE, 26);
+			L_PUBKEY(_PATH_HOST_RSA3072_FALCON_512_KEY_FILE, 27);
+			L_PUBKEY(_PATH_HOST_P256_FALCON_512_KEY_FILE, 28);
+			L_PUBKEY(_PATH_HOST_RSA3072_MQDSS_31_48_KEY_FILE, 29);
+			L_PUBKEY(_PATH_HOST_P256_MQDSS_31_48_KEY_FILE, 30);
+			L_PUBKEY(_PATH_HOST_RSA3072_PICNIC_L1FS_KEY_FILE, 31);
+			L_PUBKEY(_PATH_HOST_P256_PICNIC_L1FS_KEY_FILE, 32);
+			L_PUBKEY(_PATH_HOST_RSA3072_PICNIC3_L1_KEY_FILE, 33);
+			L_PUBKEY(_PATH_HOST_P256_PICNIC3_L1_KEY_FILE, 34);
+			L_PUBKEY(_PATH_HOST_RSA3072_QTESLA_P_I_KEY_FILE, 35);
+			L_PUBKEY(_PATH_HOST_P256_QTESLA_P_I_KEY_FILE, 36);
+			L_PUBKEY(_PATH_HOST_RSA3072_RAINBOW_IA_CLASSIC_KEY_FILE, 37);
+			L_PUBKEY(_PATH_HOST_P256_RAINBOW_IA_CLASSIC_KEY_FILE, 38);
+			L_PUBKEY(_PATH_HOST_P384_RAINBOW_IIIC_CLASSIC_KEY_FILE, 39);
+			L_PUBKEY(_PATH_HOST_P521_RAINBOW_VC_CLASSIC_KEY_FILE, 40);
+			L_PUBKEY(_PATH_HOST_RSA3072_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE, 41);
+			L_PUBKEY(_PATH_HOST_P256_SPHINCS_HARAKA_128F_ROBUST_KEY_FILE, 42);
+			L_PUBKEY(_PATH_HOST_RSA3072_SPHINCS_SHA256_128F_ROBUST_KEY_FILE, 43);
+			L_PUBKEY(_PATH_HOST_P256_SPHINCS_SHA256_128F_ROBUST_KEY_FILE, 44);
+			L_PUBKEY(_PATH_HOST_RSA3072_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE, 45);
+			L_PUBKEY(_PATH_HOST_P256_SPHINCS_SHAKE256_128F_ROBUST_KEY_FILE, 46);
+///// OQS_TEMPLATE_FRAGMENT_LOAD_PUBKEYS_END
 		}
 	}
 
--- a/ssh2.h
+++ b/ssh2.h
@@ -107,6 +107,83 @@
 #define SSH2_MSG_KEX_ECDH_INIT				30
 #define SSH2_MSG_KEX_ECDH_REPLY				31
 
+/* PQ-only */
+#define SSH2_MSG_PQ_OQSDEFAULT_INIT			30
+#define SSH2_MSG_PQ_OQSDEFAULT_REPLY		31
+///// OQS_TEMPLATE_FRAGMENT_ASSIGN_PQ_KEX_MARKERS_START
+#define SSH2_MSG_PQ_BIKE_INIT    30
+#define SSH2_MSG_PQ_BIKE_REPLY   31
+
+#define SSH2_MSG_PQ_CLASSIC_MCELIECE_INIT    30
+#define SSH2_MSG_PQ_CLASSIC_MCELIECE_REPLY   31
+
+#define SSH2_MSG_PQ_FRODO_INIT    30
+#define SSH2_MSG_PQ_FRODO_REPLY   31
+
+#define SSH2_MSG_PQ_KYBER_INIT    30
+#define SSH2_MSG_PQ_KYBER_REPLY   31
+
+#define SSH2_MSG_PQ_NEWHOPE_INIT    30
+#define SSH2_MSG_PQ_NEWHOPE_REPLY   31
+
+#define SSH2_MSG_PQ_NTRU_INIT    30
+#define SSH2_MSG_PQ_NTRU_REPLY   31
+
+#define SSH2_MSG_PQ_SABER_INIT    30
+#define SSH2_MSG_PQ_SABER_REPLY   31
+
+#define SSH2_MSG_PQ_SIDH_INIT    30
+#define SSH2_MSG_PQ_SIDH_REPLY   31
+
+#define SSH2_MSG_PQ_SIKE_INIT    30
+#define SSH2_MSG_PQ_SIKE_REPLY   31
+
+#define SSH2_MSG_PQ_THREEBEARS_INIT    30
+#define SSH2_MSG_PQ_THREEBEARS_REPLY   31
+
+#define SSH2_MSG_PQ_HQC_INIT    30
+#define SSH2_MSG_PQ_HQC_REPLY   31
+///// OQS_TEMPLATE_FRAGMENT_ASSIGN_PQ_KEX_MARKERS_END
+
+/* hybrid */
+#define SSH2_MSG_HY_ECDH_OQSDEFAULT_INIT		30
+#define SSH2_MSG_HY_ECDH_OQSDEFAULT_REPLY		31
+
+///// OQS_TEMPLATE_FRAGMENT_ASSIGN_HYBRID_KEX_MARKERS_START
+#define SSH2_MSG_HY_ECDH_BIKE_INIT    30
+#define SSH2_MSG_HY_ECDH_BIKE_REPLY   31
+
+#define SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_INIT    30
+#define SSH2_MSG_HY_ECDH_CLASSIC_MCELIECE_REPLY   31
+
+#define SSH2_MSG_HY_ECDH_FRODO_INIT    30
+#define SSH2_MSG_HY_ECDH_FRODO_REPLY   31
+
+#define SSH2_MSG_HY_ECDH_KYBER_INIT    30
+#define SSH2_MSG_HY_ECDH_KYBER_REPLY   31
+
+#define SSH2_MSG_HY_ECDH_NEWHOPE_INIT    30
+#define SSH2_MSG_HY_ECDH_NEWHOPE_REPLY   31
+
+#define SSH2_MSG_HY_ECDH_NTRU_INIT    30
+#define SSH2_MSG_HY_ECDH_NTRU_REPLY   31
+
+#define SSH2_MSG_HY_ECDH_SABER_INIT    30
+#define SSH2_MSG_HY_ECDH_SABER_REPLY   31
+
+#define SSH2_MSG_HY_ECDH_SIDH_INIT    30
+#define SSH2_MSG_HY_ECDH_SIDH_REPLY   31
+
+#define SSH2_MSG_HY_ECDH_SIKE_INIT    30
+#define SSH2_MSG_HY_ECDH_SIKE_REPLY   31
+
+#define SSH2_MSG_HY_ECDH_THREEBEARS_INIT    30
+#define SSH2_MSG_HY_ECDH_THREEBEARS_REPLY   31
+
+#define SSH2_MSG_HY_ECDH_HQC_INIT    30
+#define SSH2_MSG_HY_ECDH_HQC_REPLY   31
+///// OQS_TEMPLATE_FRAGMENT_ASSIGN_HYBRID_KEX_MARKERS_END
+
 /* user authentication: generic */
 
 #define SSH2_MSG_USERAUTH_REQUEST			50
--- a/ssh_api.c
+++ b/ssh_api.c
@@ -108,8 +108,10 @@
 		ssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;
 # ifdef OPENSSL_HAS_ECC
 		ssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_server;
+		ssh->kex->kex[KEX_HY_ECDH_OQS] = get_hybrid_ecdh_oqs_server_cb();
 # endif
 #endif /* WITH_OPENSSL */
+		ssh->kex->kex[KEX_PQ_OQS] = get_pq_oqs_server_cb();
 		ssh->kex->kex[KEX_C25519_SHA256] = kexc25519_server;
 		ssh->kex->load_host_public_key=&_ssh_host_public_key;
 		ssh->kex->load_host_private_key=&_ssh_host_private_key;
@@ -125,8 +127,10 @@
 		ssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;
 # ifdef OPENSSL_HAS_ECC
 		ssh->kex->kex[KEX_ECDH_SHA2] = kexecdh_client;
+		ssh->kex->kex[KEX_HY_ECDH_OQS] = get_hybrid_ecdh_oqs_client_cb();
 # endif
 #endif /* WITH_OPENSSL */
+		ssh->kex->kex[KEX_PQ_OQS] = get_pq_oqs_client_cb();
 		ssh->kex->kex[KEX_C25519_SHA256] = kexc25519_client;
 		ssh->kex->verify_host_key =&_ssh_verify_host_key;
 	}
--- a/sshconnect.c
+++ b/sshconnect.c
@@ -1463,6 +1463,45 @@
 		KEY_ECDSA,
 		KEY_ED25519,
 		KEY_XMSS,
+///// OQS_TEMPLATE_FRAGMENT_LIST_KT_START
+		KEY_OQSDEFAULT,
+		KEY_DILITHIUM_2,
+		KEY_FALCON_512,
+		KEY_MQDSS_31_48,
+		KEY_PICNIC_L1FS,
+		KEY_PICNIC3_L1,
+		KEY_QTESLA_P_I,
+		KEY_RAINBOW_IA_CLASSIC,
+		KEY_RAINBOW_IIIC_CLASSIC,
+		KEY_RAINBOW_VC_CLASSIC,
+		KEY_SPHINCS_HARAKA_128F_ROBUST,
+		KEY_SPHINCS_SHA256_128F_ROBUST,
+		KEY_SPHINCS_SHAKE256_128F_ROBUST,
+		KEY_RSA3072_OQSDEFAULT,
+		KEY_P256_OQSDEFAULT,
+		KEY_RSA3072_DILITHIUM_2,
+		KEY_P256_DILITHIUM_2,
+		KEY_RSA3072_FALCON_512,
+		KEY_P256_FALCON_512,
+		KEY_RSA3072_MQDSS_31_48,
+		KEY_P256_MQDSS_31_48,
+		KEY_RSA3072_PICNIC_L1FS,
+		KEY_P256_PICNIC_L1FS,
+		KEY_RSA3072_PICNIC3_L1,
+		KEY_P256_PICNIC3_L1,
+		KEY_RSA3072_QTESLA_P_I,
+		KEY_P256_QTESLA_P_I,
+		KEY_RSA3072_RAINBOW_IA_CLASSIC,
+		KEY_P256_RAINBOW_IA_CLASSIC,
+		KEY_P384_RAINBOW_IIIC_CLASSIC,
+		KEY_P521_RAINBOW_VC_CLASSIC,
+		KEY_RSA3072_SPHINCS_HARAKA_128F_ROBUST,
+		KEY_P256_SPHINCS_HARAKA_128F_ROBUST,
+		KEY_RSA3072_SPHINCS_SHA256_128F_ROBUST,
+		KEY_P256_SPHINCS_SHA256_128F_ROBUST,
+		KEY_RSA3072_SPHINCS_SHAKE256_128F_ROBUST,
+		KEY_P256_SPHINCS_SHAKE256_128F_ROBUST,
+///// OQS_TEMPLATE_FRAGMENT_LIST_KT_END
 		-1
 	};
 	int i, ret = 0;
--- a/sshconnect2.c
+++ b/sshconnect2.c
@@ -246,8 +246,10 @@
 	kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;
 # ifdef OPENSSL_HAS_ECC
 	kex->kex[KEX_ECDH_SHA2] = kexecdh_client;
+	kex->kex[KEX_HY_ECDH_OQS] = get_hybrid_ecdh_oqs_client_cb();
 # endif
 #endif
+	kex->kex[KEX_PQ_OQS] = get_pq_oqs_client_cb();
 	kex->kex[KEX_C25519_SHA256] = kexc25519_client;
 #ifdef GSSAPI
 	if (options.gss_keyex) {
--- a/sshd.c
+++ b/sshd.c
@@ -138,6 +138,8 @@
 int deny_severity;
 #endif /* LIBWRAP */
 
+#include "oqs-utils.h"
+
 /* Re-exec fds */
 #define REEXEC_DEVCRYPTO_RESERVED_FD	(STDERR_FILENO + 1)
 #define REEXEC_STARTUP_PIPE_FD		(STDERR_FILENO + 2)
@@ -741,6 +743,8 @@
 		case KEY_ECDSA:
 		case KEY_ED25519:
 		case KEY_XMSS:
+		CASE_KEY_OQS:
+		CASE_KEY_HYBRID:
 			append_hostkey_type(b, sshkey_ssh_name(key));
 			break;
 		}
@@ -776,7 +780,6 @@
 {
 	u_int i;
 	struct sshkey *key;
-
 	for (i = 0; i < options.num_host_key_files; i++) {
 		switch (type) {
 		case KEY_RSA_CERT:
@@ -793,7 +796,7 @@
 			break;
 		}
 		if (key != NULL && key->type == type &&
-		    (key->type != KEY_ECDSA || key->ecdsa_nid == nid))
+		    ((key->type != KEY_ECDSA && !IS_ECDSA_HYBRID(key->type)) || key->ecdsa_nid == nid))
 			return need_private ?
 			    sensitive_data.host_keys[i] : key;
 	}
@@ -1814,6 +1817,8 @@
 		case KEY_ECDSA:
 		case KEY_ED25519:
 		case KEY_XMSS:
+		CASE_KEY_OQS:
+		CASE_KEY_HYBRID:
 			if (have_agent || key != NULL)
 				sensitive_data.have_ssh2_key = 1;
 			break;
@@ -2439,8 +2444,10 @@
 	kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;
 # ifdef OPENSSL_HAS_ECC
 	kex->kex[KEX_ECDH_SHA2] = kexecdh_server;
+	kex->kex[KEX_HY_ECDH_OQS] = get_hybrid_ecdh_oqs_server_cb();
 # endif
 #endif
+	kex->kex[KEX_PQ_OQS] = get_pq_oqs_server_cb();
 	kex->kex[KEX_C25519_SHA256] = kexc25519_server;
 #ifdef GSSAPI
 	if (options.gss_keyex) {
--- a/sshkey.c
+++ b/sshkey.c
@@ -25,6 +25,28 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+/* OQS note:
+   In addition to post-quantum (PQ) signatures; we also support classical/PQ hybrids. In that case, a classical and a PQ signature
+   are generated on the same data, and the resulting signatures are concatenated. We combine RSA or ECDSA (using the NIST curves)
+   with the supported OQS algorithm at an equivalent security level; this means using:
+   - RSA3072 and NIST-P256 for L1 schemes, and
+   - NIST-P384 for L3 schemes (RSA isn't supported above L1 for efficiency reasons)
+
+   New key types have been defined for the hybrid cases, identified by the "ssh-<classical>-<pq>" string, where <classical> is either
+   "p256", "p384", or "rsa3072" and <pq> is one of the supported PQ schemes.
+
+   Keys are serialized sequentially: the classical key is serialized first, followed by the PQ one. The SSH key encoding contains
+   all the length and serialization information, so the OpenSSH serialization for each type is called sequentially.
+
+   The OpenSSH signature code is called sequentially: the classical handling is performed first (including hashing the signed data
+   with the appropriate SHA2 functions (SHA256 for L1 schemes, SHA384 for L3 schemes)), followed by the PQ one (in which case the
+   data is signed/verified directly). The resulting signatures are encoded as follows:
+   - classical_sig_len: 4 bytes encoding the size of the classical signature
+   - classical_sig: the classical signature of length classical_sig_len
+   - pq_sig_len: 4 bytes encoding the size of the post-quantum signature
+   - pq_sig: the post-quantum signature of length pq_sig_len
+*/
+
 #include "includes.h"
 
 #include <sys/types.h>
@@ -56,6 +78,8 @@
 #define SSHKEY_INTERNAL
 #include "sshkey.h"
 #include "sshkey-xmss.h"
+#include "ssh-oqs.h"
+#include "oqs-utils.h"
 #include "match.h"
 
 #include "xmss_fast.h"
@@ -101,6 +125,51 @@
 	{ "ssh-xmss-cert-v01@openssh.com", "XMSS-CERT", NULL,
 	    KEY_XMSS_CERT, 0, 1, 0 },
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+///// OQS_TEMPLATE_FRAGMENT_ADD_PQ_KT_START
+	{ "ssh-oqsdefault", "OQSDEFAULT", NULL, KEY_OQSDEFAULT, 0, 0, 0 },
+	{ "ssh-dilithium2", "DILITHIUM2", NULL, KEY_DILITHIUM_2, 0, 0, 0 },
+	{ "ssh-falcon512", "FALCON512", NULL, KEY_FALCON_512, 0, 0, 0 },
+	{ "ssh-mqdss3148", "MQDSS3148", NULL, KEY_MQDSS_31_48, 0, 0, 0 },
+	{ "ssh-picnicl1fs", "PICNICL1FS", NULL, KEY_PICNIC_L1FS, 0, 0, 0 },
+	{ "ssh-picnic3l1", "PICNIC3L1", NULL, KEY_PICNIC3_L1, 0, 0, 0 },
+	{ "ssh-qteslapi", "QTESLAPI", NULL, KEY_QTESLA_P_I, 0, 0, 0 },
+	{ "ssh-rainbowiaclassic", "RAINBOWIACLASSIC", NULL, KEY_RAINBOW_IA_CLASSIC, 0, 0, 0 },
+	{ "ssh-rainbowiiicclassic", "RAINBOWIIICCLASSIC", NULL, KEY_RAINBOW_IIIC_CLASSIC, 0, 0, 0 },
+	{ "ssh-rainbowvcclassic", "RAINBOWVCCLASSIC", NULL, KEY_RAINBOW_VC_CLASSIC, 0, 0, 0 },
+	{ "ssh-sphincsharaka128frobust", "SPHINCSHARAKA128FROBUST", NULL, KEY_SPHINCS_HARAKA_128F_ROBUST, 0, 0, 0 },
+	{ "ssh-sphincssha256128frobust", "SPHINCSSHA256128FROBUST", NULL, KEY_SPHINCS_SHA256_128F_ROBUST, 0, 0, 0 },
+	{ "ssh-sphincsshake256128frobust", "SPHINCSSHAKE256128FROBUST", NULL, KEY_SPHINCS_SHAKE256_128F_ROBUST, 0, 0, 0 },
+///// OQS_TEMPLATE_FRAGMENT_ADD_PQ_KT_END
+#endif /* WITH_PQ_AUTH */
+#ifdef WITH_HYBRID_AUTH
+///// OQS_TEMPLATE_FRAGMENT_ADD_HYBRID_KT_START
+	{ "ssh-rsa3072-oqsdefault", "RSA3072_OQSDEFAULT", NULL, KEY_RSA3072_OQSDEFAULT, 0, 0, 0 },
+	{ "ssh-p256-oqsdefault", "P256_OQSDEFAULT", NULL, KEY_P256_OQSDEFAULT, NID_X9_62_prime256v1, 0, 0 },
+	{ "ssh-rsa3072-dilithium2", "RSA3072_DILITHIUM2", NULL, KEY_RSA3072_DILITHIUM_2, 0, 0, 0 },
+	{ "ssh-p256-dilithium2", "P256_DILITHIUM2", NULL, KEY_P256_DILITHIUM_2, NID_X9_62_prime256v1, 0, 0 },
+	{ "ssh-rsa3072-falcon512", "RSA3072_FALCON512", NULL, KEY_RSA3072_FALCON_512, 0, 0, 0 },
+	{ "ssh-p256-falcon512", "P256_FALCON512", NULL, KEY_P256_FALCON_512, NID_X9_62_prime256v1, 0, 0 },
+	{ "ssh-rsa3072-mqdss3148", "RSA3072_MQDSS3148", NULL, KEY_RSA3072_MQDSS_31_48, 0, 0, 0 },
+	{ "ssh-p256-mqdss3148", "P256_MQDSS3148", NULL, KEY_P256_MQDSS_31_48, NID_X9_62_prime256v1, 0, 0 },
+	{ "ssh-rsa3072-picnicl1fs", "RSA3072_PICNICL1FS", NULL, KEY_RSA3072_PICNIC_L1FS, 0, 0, 0 },
+	{ "ssh-p256-picnicl1fs", "P256_PICNICL1FS", NULL, KEY_P256_PICNIC_L1FS, NID_X9_62_prime256v1, 0, 0 },
+	{ "ssh-rsa3072-picnic3l1", "RSA3072_PICNIC3L1", NULL, KEY_RSA3072_PICNIC3_L1, 0, 0, 0 },
+	{ "ssh-p256-picnic3l1", "P256_PICNIC3L1", NULL, KEY_P256_PICNIC3_L1, NID_X9_62_prime256v1, 0, 0 },
+	{ "ssh-rsa3072-qteslapi", "RSA3072_QTESLAPI", NULL, KEY_RSA3072_QTESLA_P_I, 0, 0, 0 },
+	{ "ssh-p256-qteslapi", "P256_QTESLAPI", NULL, KEY_P256_QTESLA_P_I, NID_X9_62_prime256v1, 0, 0 },
+	{ "ssh-rsa3072-rainbowiaclassic", "RSA3072_RAINBOWIACLASSIC", NULL, KEY_RSA3072_RAINBOW_IA_CLASSIC, 0, 0, 0 },
+	{ "ssh-p256-rainbowiaclassic", "P256_RAINBOWIACLASSIC", NULL, KEY_P256_RAINBOW_IA_CLASSIC, NID_X9_62_prime256v1, 0, 0 },
+	{ "ssh-p384-rainbowiiicclassic", "P384_RAINBOWIIICCLASSIC", NULL, KEY_P384_RAINBOW_IIIC_CLASSIC, NID_secp384r1, 0, 0 },
+	{ "ssh-p521-rainbowvcclassic", "P521_RAINBOWVCCLASSIC", NULL, KEY_P521_RAINBOW_VC_CLASSIC, NID_secp521r1, 0, 0 },
+	{ "ssh-rsa3072-sphincsharaka128frobust", "RSA3072_SPHINCSHARAKA128FROBUST", NULL, KEY_RSA3072_SPHINCS_HARAKA_128F_ROBUST, 0, 0, 0 },
+	{ "ssh-p256-sphincsharaka128frobust", "P256_SPHINCSHARAKA128FROBUST", NULL, KEY_P256_SPHINCS_HARAKA_128F_ROBUST, NID_X9_62_prime256v1, 0, 0 },
+	{ "ssh-rsa3072-sphincssha256128frobust", "RSA3072_SPHINCSSHA256128FROBUST", NULL, KEY_RSA3072_SPHINCS_SHA256_128F_ROBUST, 0, 0, 0 },
+	{ "ssh-p256-sphincssha256128frobust", "P256_SPHINCSSHA256128FROBUST", NULL, KEY_P256_SPHINCS_SHA256_128F_ROBUST, NID_X9_62_prime256v1, 0, 0 },
+	{ "ssh-rsa3072-sphincsshake256128frobust", "RSA3072_SPHINCSSHAKE256128FROBUST", NULL, KEY_RSA3072_SPHINCS_SHAKE256_128F_ROBUST, 0, 0, 0 },
+	{ "ssh-p256-sphincsshake256128frobust", "P256_SPHINCSSHAKE256128FROBUST", NULL, KEY_P256_SPHINCS_SHAKE256_128F_ROBUST, NID_X9_62_prime256v1, 0, 0 },
+///// OQS_TEMPLATE_FRAGMENT_ADD_HYBRID_KT_END
+#endif /* WITH_HYBRID_AUTH */
 #ifdef WITH_OPENSSL
 	{ "ssh-rsa", "RSA", NULL, KEY_RSA, 0, 0, 0 },
 	{ "rsa-sha2-256", "RSA", NULL, KEY_RSA, 0, 0, 1 },
@@ -208,7 +277,7 @@
 	const struct keytype *kt;
 
 	for (kt = keytypes; kt->type != -1; kt++) {
-		if (kt->type != KEY_ECDSA && kt->type != KEY_ECDSA_CERT)
+		if (kt->type != KEY_ECDSA && kt->type != KEY_ECDSA_CERT && !IS_ECDSA_HYBRID(kt->type))
 			continue;
 		if (kt->name != NULL && strcmp(name, kt->name) == 0)
 			return kt->nid;
@@ -311,6 +380,21 @@
 	case KEY_XMSS:
 	case KEY_XMSS_CERT:
 		return 256;	/* XXX */
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+		return (k->oqs_sig == NULL ? 0 : k->oqs_sig->length_public_key);
+		/* OQS note: currently returning the public key length if initialized. OK? */
+#endif /* WITH_PQ_AUTH */
+#if defined(WITH_OPENSSL) && defined(WITH_HYBRID_AUTH)
+	/* For hybrid cases, we return the sum of the classical and PQ public key lengths */
+	CASE_KEY_RSA_HYBRID:
+		if (k->rsa == NULL)
+			return 0;
+		RSA_get0_key(k->rsa, &rsa_n, NULL, NULL);
+		return BN_num_bits(rsa_n) + (k->oqs_sig == NULL ? 0 : k->oqs_sig->length_public_key);
+	CASE_KEY_ECDSA_HYBRID:
+		return sshkey_curve_nid_to_bits(k->ecdsa_nid) + (k->oqs_sig == NULL ? 0 : k->oqs_sig->length_public_key);
+#endif /* WITH_OPENSSL && WITH_HYBRID_AUTH */
 	}
 	return 0;
 }
@@ -324,6 +408,12 @@
 	case KEY_ECDSA:
 	case KEY_ED25519:
 	case KEY_XMSS:
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+#endif /* WITH_PQ_AUTH */
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_HYBRID:
+#endif /* WITH_HYBRID_AUTH */
 		return 1;
 	default:
 		return 0;
@@ -504,10 +594,16 @@
 	k->ed25519_pk = NULL;
 	k->xmss_sk = NULL;
 	k->xmss_pk = NULL;
+	k->oqs_sig = NULL;
+	k->oqs_sk = NULL;
+	k->oqs_pk = NULL;
 	switch (k->type) {
 #ifdef WITH_OPENSSL
 	case KEY_RSA:
 	case KEY_RSA_CERT:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_RSA_HYBRID:
+#endif
 		if ((rsa = RSA_new()) == NULL) {
 			free(k);
 			return NULL;
@@ -524,6 +620,9 @@
 		break;
 	case KEY_ECDSA:
 	case KEY_ECDSA_CERT:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_ECDSA_HYBRID:
+#endif
 		/* Cannot do anything until we know the group */
 		break;
 #endif /* WITH_OPENSSL */
@@ -533,6 +632,12 @@
 	case KEY_XMSS_CERT:
 		/* no need to prealloc */
 		break;
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+		/* we simply break here to avoid the default clause. PQ processing
+		   is done after the switch statement */
+		break;
+#endif /* WITH_PQ_AUTH */
 	case KEY_UNSPEC:
 		break;
 	default:
@@ -540,6 +645,20 @@
 		return NULL;
 	}
 
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+	/* check if we need to handle a PQ key. This is done outside the
+	   switch statement above because in the hybrid case, the classical
+	   processing is done there. */
+	switch (k->type) {
+	CASE_KEY_OQS:
+	CASE_KEY_HYBRID:
+		if ((k->oqs_sig = OQS_SIG_new(get_oqs_alg_name(type))) == NULL) {
+			return NULL;
+		}
+		break;
+	}
+#endif /* WITH_PQ_AUTH || WITH_HYBRID_AUTH */
+
 	if (sshkey_is_cert(k)) {
 		if ((k->cert = cert_new()) == NULL) {
 			sshkey_free(k);
@@ -559,6 +678,9 @@
 #ifdef WITH_OPENSSL
 	case KEY_RSA:
 	case KEY_RSA_CERT:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_RSA_HYBRID:
+#endif
 		RSA_free(k->rsa);
 		k->rsa = NULL;
 		break;
@@ -570,6 +692,9 @@
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
 	case KEY_ECDSA_CERT:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_ECDSA_HYBRID:
+#endif
 		EC_KEY_free(k->ecdsa);
 		k->ecdsa = NULL;
 		break;
@@ -596,11 +721,33 @@
 		k->xmss_filename = NULL;
 		break;
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+		/* free done after this switch statement */
+		break;
+#endif /* WITH_PQ_AUTH */
 	case KEY_UNSPEC:
 		break;
 	default:
 		break;
 	}
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+	/* check if we need to handle a PQ key. This is done outside the
+	   switch statement above because in the hybrid case, the classical
+	   processing is done there. */
+	switch (k->type) {
+	CASE_KEY_OQS:
+	CASE_KEY_HYBRID:
+		if (k->oqs_sig) {
+			freezero(k->oqs_sk, k->oqs_sig->length_secret_key);
+			k->oqs_sk = NULL;
+			free(k->oqs_pk);
+			k->oqs_pk = NULL;
+			OQS_SIG_free(k->oqs_sig);
+			k->oqs_sig = NULL;
+		}
+	}
+#endif /* WITH_PQ_AUTH || WITH_HYBRID_AUTH */
 	if (sshkey_is_cert(k))
 		cert_free(k->cert);
 	freezero(k, sizeof(*k));
@@ -628,6 +775,7 @@
 int
 sshkey_equal_public(const struct sshkey *a, const struct sshkey *b)
 {
+	int rv = 0;
 #if defined(WITH_OPENSSL)
 	const BIGNUM *rsa_e_a, *rsa_n_a;
 	const BIGNUM *rsa_e_b, *rsa_n_b;
@@ -646,12 +794,16 @@
 #ifdef WITH_OPENSSL
 	case KEY_RSA_CERT:
 	case KEY_RSA:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_RSA_HYBRID:
+#endif
 		if (a->rsa == NULL || b->rsa == NULL)
 			return 0;
 		RSA_get0_key(a->rsa, &rsa_n_a, &rsa_e_a, NULL);
 		RSA_get0_key(b->rsa, &rsa_n_b, &rsa_e_b, NULL);
-		return BN_cmp(rsa_e_a, rsa_e_b) == 0 &&
+		rv = BN_cmp(rsa_e_a, rsa_e_b) == 0 &&
 		    BN_cmp(rsa_n_a, rsa_n_b) == 0;
+		break;
 	case KEY_DSA_CERT:
 	case KEY_DSA:
 		if (a->dsa == NULL || b->dsa == NULL)
@@ -660,13 +812,17 @@
 		DSA_get0_pqg(b->dsa, &dsa_p_b, &dsa_q_b, &dsa_g_b);
 		DSA_get0_key(a->dsa, &dsa_pub_key_a, NULL);
 		DSA_get0_key(b->dsa, &dsa_pub_key_b, NULL);
-		return BN_cmp(dsa_p_a, dsa_p_b) == 0 &&
+		rv = BN_cmp(dsa_p_a, dsa_p_b) == 0 &&
 		    BN_cmp(dsa_q_a, dsa_q_b) == 0 &&
 		    BN_cmp(dsa_g_a, dsa_g_b) == 0 &&
 		    BN_cmp(dsa_pub_key_a, dsa_pub_key_b) == 0;
+		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA_CERT:
 	case KEY_ECDSA:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_ECDSA_HYBRID:
+#endif
 		if (a->ecdsa == NULL || b->ecdsa == NULL ||
 		    EC_KEY_get0_public_key(a->ecdsa) == NULL ||
 		    EC_KEY_get0_public_key(b->ecdsa) == NULL)
@@ -682,24 +838,51 @@
 			return 0;
 		}
 		BN_CTX_free(bnctx);
-		return 1;
+		rv = 1;
+		break;
 # endif /* OPENSSL_HAS_ECC */
 #endif /* WITH_OPENSSL */
 	case KEY_ED25519:
 	case KEY_ED25519_CERT:
-		return a->ed25519_pk != NULL && b->ed25519_pk != NULL &&
+		rv = a->ed25519_pk != NULL && b->ed25519_pk != NULL &&
 		    memcmp(a->ed25519_pk, b->ed25519_pk, ED25519_PK_SZ) == 0;
+		break;
 #ifdef WITH_XMSS
 	case KEY_XMSS:
 	case KEY_XMSS_CERT:
-		return a->xmss_pk != NULL && b->xmss_pk != NULL &&
+		rv = a->xmss_pk != NULL && b->xmss_pk != NULL &&
 		    sshkey_xmss_pklen(a) == sshkey_xmss_pklen(b) &&
 		    memcmp(a->xmss_pk, b->xmss_pk, sshkey_xmss_pklen(a)) == 0;
+		break;
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+		/* we simply break here to avoid the default clause. PQ processing
+		   is done after the switch statement */
+		rv = 1;
+		break;
+#endif /* WITH_PQ_AUTH */
 	default:
-		return 0;
+		rv = 0;
+		break;
+	}
+	/* if classical part is not equal, no point comparing the PQ part */
+	if (rv == 0) {
+	  return rv;
 	}
-	/* NOTREACHED */
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+	/* check if we need to handle a PQ key. This is done outside the
+	   switch statement above because in the hybrid case, the classical
+	   processing is done there. */
+	switch (a->type) {
+	CASE_KEY_OQS:
+	CASE_KEY_HYBRID:
+		rv = a->oqs_pk != NULL && b->oqs_pk != NULL &&
+		    memcmp(a->oqs_pk, b->oqs_pk, a->oqs_sig->length_public_key) == 0;
+	}
+#endif /* WITH_PQ_AUTH || WITH_HYBRID_AUTH */
+
+	return rv;
 }
 
 int
@@ -766,6 +949,9 @@
 		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_ECDSA_HYBRID:
+#endif
 		if (key->ecdsa == NULL)
 			return SSH_ERR_INVALID_ARGUMENT;
 		if ((ret = sshbuf_put_cstring(b, typename)) != 0 ||
@@ -776,6 +962,9 @@
 		break;
 # endif
 	case KEY_RSA:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_RSA_HYBRID:
+#endif
 		if (key->rsa == NULL)
 			return SSH_ERR_INVALID_ARGUMENT;
 		RSA_get0_key(key->rsa, &rsa_n, &rsa_e, NULL);
@@ -806,9 +995,31 @@
 			return ret;
 		break;
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+		/* we simply serialize the type name, key handling is done after the switch statement */
+		if ((ret = sshbuf_put_cstring(b, typename)) != 0)
+			return ret;
+		break;
+#endif /* WITH_PQ_AUTH */
 	default:
 		return SSH_ERR_KEY_TYPE_UNKNOWN;
 	}
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+	/* check if we need to handle a PQ key. This is done outside the
+	   switch statement above because in the hybrid case, the classical
+	   processing is done there. */
+	switch (type) {
+	CASE_KEY_OQS:
+	CASE_KEY_HYBRID:
+		if (key->oqs_pk == NULL) {
+			return SSH_ERR_INVALID_ARGUMENT;
+		}
+		if ((ret = sshbuf_put_string(b, key->oqs_pk, key->oqs_sig->length_public_key)) != 0)
+			return ret;
+	}
+#endif /* WITH_PQ_AUTH || WITH_HYBRID_AUTH */
+
 	return 0;
 }
 
@@ -828,6 +1039,7 @@
 	if ((tmp = sshbuf_new()) == NULL)
 		return SSH_ERR_ALLOC_FAIL;
 	r = to_blob_buf(key, tmp, 0, opts);
+
 	if (r == 0)
 		r = sshbuf_put_stringb(b, tmp);
 	sshbuf_free(tmp);
@@ -1208,7 +1420,7 @@
 			continue;
 		if (memcmp(s, kt->name, l) == 0) {
 			*nid = -1;
-			if (kt->type == KEY_ECDSA || kt->type == KEY_ECDSA_CERT)
+			if (kt->type == KEY_ECDSA || kt->type == KEY_ECDSA_CERT || IS_ECDSA_HYBRID(kt->type))
 				*nid = kt->nid;
 			return kt->type;
 		}
@@ -1243,6 +1455,12 @@
 	case KEY_XMSS:
 	case KEY_XMSS_CERT:
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+#endif /* WITH_PQ_AUTH */
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_HYBRID:
+#endif /* WITH_HYBRID_AUTH */
 		break; /* ok */
 	default:
 		return SSH_ERR_INVALID_ARGUMENT;
@@ -1293,7 +1511,7 @@
 		sshkey_free(k);
 		return SSH_ERR_KEY_TYPE_MISMATCH;
 	}
-	if (sshkey_type_plain(type) == KEY_ECDSA && curve_nid != k->ecdsa_nid) {
+	if ((sshkey_type_plain(type) == KEY_ECDSA || IS_ECDSA_HYBRID(sshkey_type_plain(type))) && curve_nid != k->ecdsa_nid) {
 		sshkey_free(k);
 		return SSH_ERR_EC_CURVE_MISMATCH;
 	}
@@ -1313,6 +1531,9 @@
 	switch (sshkey_type_plain(ret->type)) {
 #ifdef WITH_OPENSSL
 	case KEY_RSA:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_RSA_HYBRID:
+#endif
 		RSA_free(ret->rsa);
 		ret->rsa = k->rsa;
 		k->rsa = NULL;
@@ -1330,6 +1551,9 @@
 		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_ECDSA_HYBRID:
+#endif
 		EC_KEY_free(ret->ecdsa);
 		ret->ecdsa = k->ecdsa;
 		ret->ecdsa_nid = k->ecdsa_nid;
@@ -1368,10 +1592,38 @@
 #endif
 		break;
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+		/* we simply break here to avoid the default clause. PQ processing
+		   is done after the switch statement */
+		break;
+#endif /* WITH_PQ_AUTH */
 	default:
 		sshkey_free(k);
 		return SSH_ERR_INTERNAL_ERROR;
 	}
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+	/* check if we need to handle a PQ key. This is done outside the
+	   switch statement above because in the hybrid case, the classical
+	   processing is done there. */
+	switch (sshkey_type_plain(ret->type)) {
+	CASE_KEY_OQS:
+	CASE_KEY_HYBRID:
+		if (ret->oqs_sig) {
+			OQS_SIG_free(ret->oqs_sig);
+		}
+		freezero(ret->oqs_pk, k->oqs_sig->length_public_key);
+		if ((ret->oqs_sig = OQS_SIG_new(get_oqs_alg_name(ret->type))) == NULL) {
+			sshkey_free(k);
+			return SSH_ERR_INTERNAL_ERROR;
+		}
+		ret->oqs_pk = k->oqs_pk;
+		k->oqs_pk = NULL;
+#ifdef DEBUG_PK
+		/* XXX */
+#endif
+	}
+#endif /* WITH_PQ_AUTH || WITH_HYBRID_AUTH */
 	sshkey_free(k);
 
 	/* success */
@@ -1635,17 +1887,40 @@
 		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_ECDSA_HYBRID:
+#endif
 		ret = ecdsa_generate_private_key(bits, &k->ecdsa_nid,
 		    &k->ecdsa);
 		break;
 # endif /* OPENSSL_HAS_ECC */
 	case KEY_RSA:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_RSA_HYBRID:
+#endif
 		ret = rsa_generate_private_key(bits, &k->rsa);
 		break;
 #endif /* WITH_OPENSSL */
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+		/* we simply break here to avoid the default clause. PQ processing
+		   is done after the switch statement */
+		break;
+#endif /* WITH_PQ_AUTH */
 	default:
 		ret = SSH_ERR_INVALID_ARGUMENT;
 	}
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+	/* check if we need to handle a PQ key. This is done outside the
+	   switch statement above because in the hybrid case, the classical
+	   processing is done there. */
+	switch (type) {
+	CASE_KEY_OQS:
+	CASE_KEY_HYBRID:
+		ret = sshkey_oqs_generate_private_key(k, type);
+	}
+#endif /* WITH_PQ_AUTH || WITH_HYBRID_AUTH */
+
 	if (ret == 0) {
 		k->type = type;
 		*keyp = k;
@@ -1771,6 +2046,9 @@
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
 	case KEY_ECDSA_CERT:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_ECDSA_HYBRID:
+#endif
 		if ((n = sshkey_new(k->type)) == NULL) {
 			r = SSH_ERR_ALLOC_FAIL;
 			goto out;
@@ -1790,6 +2068,9 @@
 # endif /* OPENSSL_HAS_ECC */
 	case KEY_RSA:
 	case KEY_RSA_CERT:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_RSA_HYBRID:
+#endif
 		if ((n = sshkey_new(k->type)) == NULL) {
 			r = SSH_ERR_ALLOC_FAIL;
 			goto out;
@@ -1844,10 +2125,36 @@
 		}
 		break;
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+		/* we simply create the key, handling is done after the switch statement */
+		if ((n = sshkey_new(k->type)) == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		break;
+#endif /* WITH_PQ_AUTH */
 	default:
 		r = SSH_ERR_KEY_TYPE_UNKNOWN;
 		goto out;
 	}
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+	/* check if we need to handle a PQ key. This is done outside the
+	   switch statement above because in the hybrid case, the classical
+	   processing is done there. */
+	switch (k->type) {
+	CASE_KEY_OQS:
+	CASE_KEY_HYBRID:
+		if (k->oqs_pk != NULL) {
+			if ((n->oqs_pk = malloc(n->oqs_sig->length_public_key)) == NULL) {
+				sshkey_free(n);
+				r = SSH_ERR_ALLOC_FAIL;
+				goto out;
+			}
+			memcpy(n->oqs_pk, k->oqs_pk, k->oqs_sig->length_public_key);
+		}
+	}
+#endif /* WITH_PQ_AUTH || WITH_HYBRID_AUTH */
 	if (sshkey_is_cert(k) && (r = sshkey_cert_copy(k, n)) != 0)
 		goto out;
 	/* success */
@@ -2053,6 +2360,9 @@
 		}
 		/* FALLTHROUGH */
 	case KEY_RSA:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_RSA_HYBRID:
+#endif
 		if ((key = sshkey_new(type)) == NULL) {
 			ret = SSH_ERR_ALLOC_FAIL;
 			goto out;
@@ -2127,6 +2437,9 @@
 		/* FALLTHROUGH */
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_ECDSA_HYBRID:
+#endif
 		if ((key = sshkey_new(type)) == NULL) {
 			ret = SSH_ERR_ALLOC_FAIL;
 			goto out;
@@ -2221,11 +2534,37 @@
 			goto out;
 		break;
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+		/* we simply create the key, handling is done after the switch statement */
+		if ((key = sshkey_new(type)) == NULL) {
+			ret = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		break;
+#endif /* WITH_PQ_AUTH */
 	case KEY_UNSPEC:
 	default:
 		ret = SSH_ERR_KEY_TYPE_UNKNOWN;
 		goto out;
 	}
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+	/* check if we need to handle a PQ key. This is done outside the
+	   switch statement above because in the hybrid case, the classical
+	   processing is done there. */
+	switch (type) {
+	CASE_KEY_OQS:
+	CASE_KEY_HYBRID:
+		if ((ret = sshbuf_get_string(b, &pk, &len)) != 0)
+			goto out;
+		if (len != key->oqs_sig->length_public_key) {
+			ret = SSH_ERR_INVALID_FORMAT;
+			goto out;
+		}
+		key->oqs_pk = pk;
+		pk = NULL;
+	}
+#endif /* WITH_PQ_AUTH || WITH_HYBRID_AUTH */
 
 	/* Parse certificate potion */
 	if (sshkey_is_cert(key) && (ret = cert_parse(b, key, copy)) != 0)
@@ -2388,6 +2727,10 @@
     u_char **sigp, size_t *lenp,
     const u_char *data, size_t datalen, const char *alg, u_int compat)
 {
+	u_char *sig_classical = NULL, *sig_pq = NULL;
+	size_t len_classical = 0, len_pq = 0;
+	int index = 0;
+	int ret = 0;
 	if (sigp != NULL)
 		*sigp = NULL;
 	if (lenp != NULL)
@@ -2398,27 +2741,99 @@
 #ifdef WITH_OPENSSL
 	case KEY_DSA_CERT:
 	case KEY_DSA:
-		return ssh_dss_sign(key, sigp, lenp, data, datalen, compat);
+		ret = ssh_dss_sign(key, &sig_classical, &len_classical, data, datalen, compat);
+		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA_CERT:
 	case KEY_ECDSA:
-		return ssh_ecdsa_sign(key, sigp, lenp, data, datalen, compat);
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_ECDSA_HYBRID:
+#endif
+		ret = ssh_ecdsa_sign(key, &sig_classical, &len_classical, data, datalen, compat);
+		break;
 # endif /* OPENSSL_HAS_ECC */
 	case KEY_RSA_CERT:
 	case KEY_RSA:
-		return ssh_rsa_sign(key, sigp, lenp, data, datalen, alg);
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_RSA_HYBRID:
+#endif
+		ret = ssh_rsa_sign(key, &sig_classical, &len_classical, data, datalen, alg);
+		break;
 #endif /* WITH_OPENSSL */
 	case KEY_ED25519:
 	case KEY_ED25519_CERT:
-		return ssh_ed25519_sign(key, sigp, lenp, data, datalen, compat);
+		ret = ssh_ed25519_sign(key, &sig_classical, &len_classical, data, datalen, compat);
+		break;
 #ifdef WITH_XMSS
 	case KEY_XMSS:
 	case KEY_XMSS_CERT:
-		return ssh_xmss_sign(key, sigp, lenp, data, datalen, compat);
+		ret = ssh_xmss_sign(key, &sig_classical, &len_classical, data, datalen, compat);
+		break;
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+		/* we simply break here to avoid the default clause. PQ processing
+		   is done after the switch statement */
+		break;
+#endif /* WITH_PQ_AUTH */
 	default:
 		return SSH_ERR_KEY_TYPE_UNKNOWN;
 	}
+	/* abort if we got an error in the classical signing */
+	if (ret != 0) {
+		return ret;
+	}
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+	/* check if we need to handle with a PQ key. This is done outside the
+	   switch statement above because in the hybrid case, the classical
+	   processing is done there. */
+	switch (key->type) {
+	CASE_KEY_OQS:
+	CASE_KEY_HYBRID:
+		ret = ssh_oqs_sign(key, &sig_pq, &len_pq, data, datalen, compat);
+		break;
+	}
+	/* abort if we got an error in the PQ signing */
+	if (ret != 0) {
+		return ret;
+	}
+#endif /* WITH_PQ_AUTH || WITH_HYBRID_AUTH */
+
+	/* return the correct signature */
+	switch (key->type) {
+	CASE_KEY_HYBRID:
+		/* classical-PQ hybrid: we concatenate the signatures */
+		*lenp = 4 + len_classical + 4 + len_pq;
+		if ((*sigp = malloc(*lenp)) == NULL) {
+			free(sig_classical);
+			free(sig_pq);
+			return SSH_ERR_ALLOC_FAIL;
+		}
+		/* encode the classical sig length */
+		POKE_U32(*sigp + index, (size_t) len_classical);
+		index += 4;
+		/* encode the classical sig */
+		memcpy(*sigp + index, sig_classical, (size_t) len_classical);
+		index += len_classical;
+		free(sig_classical);
+		/* encode the PQ sig length */
+		POKE_U32(*sigp + index, len_pq);
+		index += 4;
+		/* encode the PQ sig */
+		memcpy(*sigp + index, sig_pq, len_pq);
+		index += len_pq;
+		free(sig_pq);
+		break;
+	CASE_KEY_OQS:
+		*sigp = sig_pq;
+		*lenp = len_pq;
+		break;
+	default:
+		*sigp = sig_classical;
+		*lenp = len_classical;
+		break;
+	}
+	return ret;
 }
 
 /*
@@ -2430,33 +2845,109 @@
     const u_char *sig, size_t siglen,
     const u_char *data, size_t dlen, const char *alg, u_int compat)
 {
+	const u_char *sig_classical = NULL;
+	size_t siglen_classical = 0;
+#if defined(WITH_HYBRID_AUTH)
+	int index = 0;
+#endif
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+	const u_char *sig_pq = NULL;
+	size_t siglen_pq = 0;
+#endif /* WITH_PQ_AUTH || WITH_HYBRID_AUTH */
+	int ret = 0;
 	if (siglen == 0 || dlen > SSH_KEY_MAX_SIGN_DATA_SIZE)
 		return SSH_ERR_INVALID_ARGUMENT;
+	/* determine the type of signature: classical, PQ, or hybrid */
+	switch (key->type) {
+#if defined(WITH_HYBRID_AUTH)
+	CASE_KEY_HYBRID:
+		/* classical-PQ hybrid: we separate the signatures */
+		/* decode the classical sig length */
+		siglen_classical = (size_t) PEEK_U32(sig + index);
+		index += 4;
+		/* point to the classical sig */
+		sig_classical = sig + index;
+		index += siglen_classical;
+		/* decode the PQ sig length */
+		siglen_pq = (size_t) PEEK_U32(sig + index);
+		index += 4;
+		/* point to the PQ sig */
+		sig_pq = sig + index;
+		index += siglen_pq;
+		break;
+#endif /* WITH_HYBRID_AUTH */
+#if defined(WITH_PQ_AUTH)
+	CASE_KEY_OQS:
+		/* PQ signature */
+		sig_pq = sig;
+		siglen_pq = siglen;
+		break;
+#endif /* WITH_PQ_AUTH */
+	default:
+		/* classical signature */
+		sig_classical = sig;
+		siglen_classical = siglen;
+		break;
+	}
 	switch (key->type) {
 #ifdef WITH_OPENSSL
 	case KEY_DSA_CERT:
 	case KEY_DSA:
-		return ssh_dss_verify(key, sig, siglen, data, dlen, compat);
+		ret = ssh_dss_verify(key, sig_classical, siglen_classical, data, dlen, compat);
+		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA_CERT:
 	case KEY_ECDSA:
-		return ssh_ecdsa_verify(key, sig, siglen, data, dlen, compat);
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_ECDSA_HYBRID:
+#endif
+		ret = ssh_ecdsa_verify(key, sig_classical, siglen_classical, data, dlen, compat);
+		break;
 # endif /* OPENSSL_HAS_ECC */
 	case KEY_RSA_CERT:
 	case KEY_RSA:
-		return ssh_rsa_verify(key, sig, siglen, data, dlen, alg);
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_RSA_HYBRID:
+#endif
+		ret = ssh_rsa_verify(key, sig_classical, siglen_classical, data, dlen, alg);
+		break;
 #endif /* WITH_OPENSSL */
 	case KEY_ED25519:
 	case KEY_ED25519_CERT:
-		return ssh_ed25519_verify(key, sig, siglen, data, dlen, compat);
+		ret = ssh_ed25519_verify(key, sig_classical, siglen_classical, data, dlen, compat);
+		break;
 #ifdef WITH_XMSS
 	case KEY_XMSS:
 	case KEY_XMSS_CERT:
-		return ssh_xmss_verify(key, sig, siglen, data, dlen, compat);
+		ret = ssh_xmss_verify(key, sig_classical, siglen_classical, data, dlen, compat);
+		break;
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+		/* we simply break here to avoid the default clause. PQ processing
+		   is done after the switch statement */
+		break;
+#endif /* WITH_PQ_AUTH */
 	default:
 		return SSH_ERR_KEY_TYPE_UNKNOWN;
 	}
+	/* abort if we got an error in the classical verification */
+	if (ret != 0) {
+		return ret;
+	}
+
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+	/* check if we need to handle a PQ sig. This is done outside the
+	   switch statement above because in the hybrid case, the classical
+	   processing is done there. */
+	switch (key->type) {
+	CASE_KEY_OQS:
+	CASE_KEY_HYBRID:
+		ret = ssh_oqs_verify(key, sig_pq, siglen_pq, data, dlen, compat);
+	}
+#endif /* WITH_PQ_AUTH || WITH_HYBRID_AUTH */
+
+	return ret;
 }
 
 /* Convert a plain key to their _CERT equivalent */
@@ -2780,6 +3271,9 @@
 	switch (key->type) {
 #ifdef WITH_OPENSSL
 	case KEY_RSA:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_RSA_HYBRID:
+#endif
 		RSA_get0_key(key->rsa, &rsa_n, &rsa_e, &rsa_d);
 		RSA_get0_factors(key->rsa, &rsa_p, &rsa_q);
 		RSA_get0_crt_params(key->rsa, NULL, NULL, &rsa_iqmp);
@@ -2828,6 +3322,9 @@
 		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_ECDSA_HYBRID:
+#endif
 		if ((r = sshbuf_put_cstring(b,
 		    sshkey_curve_nid_to_name(key->ecdsa_nid))) != 0 ||
 		    (r = sshbuf_put_eckey(b, key->ecdsa)) != 0 ||
@@ -2896,10 +3393,33 @@
 			goto out;
 		break;
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+		/* we simply break here to avoid the default clause. PQ processing
+		   is done after the switch statement */
+		break;
+#endif /* WITH_PQ_AUTH */
+
 	default:
 		r = SSH_ERR_INVALID_ARGUMENT;
 		goto out;
 	}
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+	/* check if we need to handle a PQ key. This is done outside the
+	   switch statement above because in the hybrid case, the classical
+	   processing is done there. */
+	switch (key->type) {
+	CASE_KEY_OQS:
+	CASE_KEY_HYBRID:
+		if ((r = sshbuf_put_string(b, key->oqs_pk,
+		    key->oqs_sig->length_public_key)) != 0 ||
+		    (r = sshbuf_put_string(b, key->oqs_sk,
+		    key->oqs_sig->length_secret_key)) != 0)
+			goto out;
+		break;
+	}
+#endif /* WITH_PQ_AUTH || WITH_HYBRID_AUTH */
+
 	/* success */
 	r = 0;
  out:
@@ -2922,6 +3442,9 @@
 	int type, r = SSH_ERR_INTERNAL_ERROR;
 	u_char *ed25519_pk = NULL, *ed25519_sk = NULL;
 	u_char *xmss_pk = NULL, *xmss_sk = NULL;
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+	u_char *oqs_pk = NULL, *oqs_sk = NULL;
+#endif /* WITH_PQ_AUTH || WITH_HYBRID_AUTH */
 #ifdef WITH_OPENSSL
 	BIGNUM *exponent = NULL;
 	BIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;
@@ -2983,6 +3506,9 @@
 		break;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_ECDSA_HYBRID:
+#endif
 		if ((k = sshkey_new(type)) == NULL) {
 			r = SSH_ERR_ALLOC_FAIL;
 			goto out;
@@ -3033,6 +3559,9 @@
 		break;
 # endif /* OPENSSL_HAS_ECC */
 	case KEY_RSA:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_RSA_HYBRID:
+#endif
 		if ((k = sshkey_new(type)) == NULL) {
 			r = SSH_ERR_ALLOC_FAIL;
 			goto out;
@@ -3173,15 +3702,48 @@
 			goto out;
 		break;
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+		/* we simply create the key, handling is done after the switch statement */
+		if ((k = sshkey_new(type)) == NULL) {
+			r = SSH_ERR_ALLOC_FAIL;
+			goto out;
+		}
+		break;
+#endif /* WITH_PQ_AUTH */
+
 	default:
 		r = SSH_ERR_KEY_TYPE_UNKNOWN;
 		goto out;
 	}
+#if defined(WITH_PQ_AUTH) || defined(WITH_HYBRID_AUTH)
+	/* check if we need to handle a PQ key. This is done outside the
+	   switch statement above because in the hybrid case, the classical
+	   processing is done there. */
+	switch (type) {
+	CASE_KEY_OQS:
+	CASE_KEY_HYBRID:
+		if ((r = sshbuf_get_string(buf, &oqs_pk, &pklen)) != 0 ||
+		    (r = sshbuf_get_string(buf, &oqs_sk, &sklen)) != 0)
+			goto out;
+		if (pklen != k->oqs_sig->length_public_key || sklen != k->oqs_sig->length_secret_key) {
+			r = SSH_ERR_INVALID_FORMAT;
+			goto out;
+		}
+		k->oqs_pk = oqs_pk;
+		k->oqs_sk = oqs_sk;
+		oqs_pk = oqs_sk = NULL;
+		break;
+	}
+#endif /* WITH_PQ_AUTH || WITH_HYBRID_AUTH */
 #ifdef WITH_OPENSSL
 	/* enable blinding */
 	switch (k->type) {
 	case KEY_RSA:
 	case KEY_RSA_CERT:
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_RSA_HYBRID:
+#endif
 		if (RSA_blinding_on(k->rsa, NULL) != 1) {
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
@@ -3189,6 +3751,7 @@
 		break;
 	}
 #endif /* WITH_OPENSSL */
+
 	/* success */
 	r = 0;
 	if (kp != NULL) {
@@ -3218,6 +3781,10 @@
 	free(xmss_name);
 	freezero(xmss_pk, pklen);
 	freezero(xmss_sk, sklen);
+#ifdef WITH_PQ_AUTH
+	freezero(oqs_pk, pklen);
+	freezero(oqs_sk, sklen);
+#endif /* WITH_PQ_AUTH */
 	return r;
 }
 
@@ -3502,17 +4069,28 @@
 		goto out;
 	}
 
+	/* OQS note: We have changed the logic below to write "b64" out
+	 * in bursts of 70 characters to "blob", as opposed to writing it out
+	 * character by character. This greatly speeds up key-generation for the
+	 * Rainbow variants, for which b64 can be many millions of bytes.*/
 	sshbuf_reset(blob);
 	if ((r = sshbuf_put(blob, MARK_BEGIN, MARK_BEGIN_LEN)) != 0)
 		goto out;
-	for (i = 0; i < strlen(b64); i++) {
-		if ((r = sshbuf_put_u8(blob, b64[i])) != 0)
+	size_t b64_len = strlen(b64);
+	char *b64_ptr = b64;
+
+    while(b64_len >= 70) {
+		if ((r = sshbuf_put(blob, b64_ptr, 70)) != 0)
 			goto out;
-		/* insert line breaks */
-		if (i % 70 == 69 && (r = sshbuf_put_u8(blob, '\n')) != 0)
+		b64_ptr += 70;
+        b64_len -= 70;
+		if ((r = sshbuf_put_u8(blob, '\n')) != 0)
 			goto out;
+    }
+	if (b64_len > 0 && (r = sshbuf_put(blob, b64_ptr, b64_len)) != 0) {
+		goto out;
 	}
-	if (i % 70 != 69 && (r = sshbuf_put_u8(blob, '\n')) != 0)
+	if (b64_len > 0 && (r = sshbuf_put_u8(blob, '\n')) != 0)
 		goto out;
 	if ((r = sshbuf_put(blob, MARK_END, MARK_END_LEN)) != 0)
 		goto out;
@@ -3837,6 +4415,12 @@
 #ifdef WITH_XMSS
 	case KEY_XMSS:
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+#endif /* WITH_PQ_AUTH */
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_HYBRID:
+#endif /* WITH_HYBRID_AUTH */
 		return sshkey_private_to_blob2(key, blob, passphrase,
 		    comment, new_format_cipher, new_format_rounds);
 	default:
@@ -4039,6 +4623,7 @@
 	case KEY_DSA:
 	case KEY_ECDSA:
 	case KEY_RSA:
+	/* OQS note: hybrid algs use the newer format (blob2) */
 		return sshkey_parse_private_pem_fileblob(blob, type,
 		    passphrase, keyp);
 #endif /* WITH_OPENSSL */
@@ -4046,6 +4631,12 @@
 #ifdef WITH_XMSS
 	case KEY_XMSS:
 #endif /* WITH_XMSS */
+#ifdef WITH_PQ_AUTH
+	CASE_KEY_OQS:
+#endif /* WITH_PQ_AUTH */
+#ifdef WITH_HYBRID_AUTH
+	CASE_KEY_HYBRID:
+#endif /* WITH_HYBRID_AUTH */
 		return sshkey_parse_private2(blob, type, passphrase,
 		    keyp, commentp);
 	case KEY_UNSPEC:
--- a/sshkey.h
+++ b/sshkey.h
@@ -28,6 +28,9 @@
 
 #include <sys/types.h>
 
+#ifdef WITH_OQS
+#include <oqs/oqs.h>
+#endif /* WITH_OQS */
 #ifdef WITH_OPENSSL
 #include <openssl/rsa.h>
 #include <openssl/dsa.h>
@@ -48,7 +51,10 @@
 #endif /* WITH_OPENSSL */
 
 #define SSH_RSA_MINIMUM_MODULUS_SIZE	1024
-#define SSH_KEY_MAX_SIGN_DATA_SIZE	(1 << 20)
+/* OQS note: We have increased the value below from
+ * (1 << 20) to (1 << 25).
+ */
+#define SSH_KEY_MAX_SIGN_DATA_SIZE	(1 << 25)
 
 struct sshbuf;
 
@@ -64,6 +70,45 @@
 	KEY_ED25519_CERT,
 	KEY_XMSS,
 	KEY_XMSS_CERT,
+///// OQS_TEMPLATE_FRAGMENT_ENUM_KT_START
+	KEY_OQSDEFAULT,
+	KEY_DILITHIUM_2,
+	KEY_FALCON_512,
+	KEY_MQDSS_31_48,
+	KEY_PICNIC_L1FS,
+	KEY_PICNIC3_L1,
+	KEY_QTESLA_P_I,
+	KEY_RAINBOW_IA_CLASSIC,
+	KEY_RAINBOW_IIIC_CLASSIC,
+	KEY_RAINBOW_VC_CLASSIC,
+	KEY_SPHINCS_HARAKA_128F_ROBUST,
+	KEY_SPHINCS_SHA256_128F_ROBUST,
+	KEY_SPHINCS_SHAKE256_128F_ROBUST,
+	KEY_RSA3072_OQSDEFAULT,
+	KEY_P256_OQSDEFAULT,
+	KEY_RSA3072_DILITHIUM_2,
+	KEY_P256_DILITHIUM_2,
+	KEY_RSA3072_FALCON_512,
+	KEY_P256_FALCON_512,
+	KEY_RSA3072_MQDSS_31_48,
+	KEY_P256_MQDSS_31_48,
+	KEY_RSA3072_PICNIC_L1FS,
+	KEY_P256_PICNIC_L1FS,
+	KEY_RSA3072_PICNIC3_L1,
+	KEY_P256_PICNIC3_L1,
+	KEY_RSA3072_QTESLA_P_I,
+	KEY_P256_QTESLA_P_I,
+	KEY_RSA3072_RAINBOW_IA_CLASSIC,
+	KEY_P256_RAINBOW_IA_CLASSIC,
+	KEY_P384_RAINBOW_IIIC_CLASSIC,
+	KEY_P521_RAINBOW_VC_CLASSIC,
+	KEY_RSA3072_SPHINCS_HARAKA_128F_ROBUST,
+	KEY_P256_SPHINCS_HARAKA_128F_ROBUST,
+	KEY_RSA3072_SPHINCS_SHA256_128F_ROBUST,
+	KEY_P256_SPHINCS_SHA256_128F_ROBUST,
+	KEY_RSA3072_SPHINCS_SHAKE256_128F_ROBUST,
+	KEY_P256_SPHINCS_SHAKE256_128F_ROBUST,
+///// OQS_TEMPLATE_FRAGMENT_ENUM_KT_END
 	KEY_NULL,
 	KEY_UNSPEC
 };
@@ -122,6 +167,10 @@
 	void	*xmss_state;	/* depends on xmss_name, opaque */
 	u_char	*xmss_sk;
 	u_char	*xmss_pk;
+	/* OQS artefacts */
+	OQS_SIG *oqs_sig;
+	u_char	*oqs_sk;
+	u_char	*oqs_pk;
 	struct sshkey_cert *cert;
 };
 
--- a/version.h
+++ b/version.h
@@ -1,6 +1,6 @@
 /* $OpenBSD: version.h,v 1.83 2018/10/10 16:43:49 deraadt Exp $ */
 
-#define SSH_VERSION	"OpenSSH_7.9"
+#define SSH_VERSION	"OQS-OpenSSH_7.9-2020-08_"
 
 #define SSH_PORTABLE	"p1"
 #define SSH_RELEASE_MINIMUM	SSH_VERSION SSH_PORTABLE
